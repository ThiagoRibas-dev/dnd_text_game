--- Directory Tree Structure ---
```
|-- .clinerules
|-- .github
|-- .mypy_cache
|-- .pytest_cache
|-- .ruff_cache
|-- .venv
|-- build
|-- Dev
|   |-- D
|-- dist
|-- docs
|-- packaging
|-- scripts
|-- src
|   |-- dndrpg
|   |   |-- content
|   |   |   |-- campaigns
|   |   |   |-- conditions
|   |   |   |-- deities
|   |   |   |-- effects
|   |   |   |-- items
|   |   |   |   |-- armors
|   |   |   |   |-- misc
|   |   |   |   |-- shields
|   |   |   |   |-- weapons
|   |   |   |-- kits
|   |   |   |-- resources
|   |   |   |-- tasks
|   |   |   |-- zones
|   |   |-- engine
|   |   |   |-- __pycache__
|   |   |-- tools
|   |   |   |-- __pycache__
|   |   |-- ui
|   |   |   |-- chargen
|   |   |   |   |-- __pycache__
|   |   |   |-- __pycache__
|   |   |-- util
|   |   |   |-- __pycache__
|   |   |-- __pycache__
|   |-- dndrpg.egg-info
|-- tests
|   |-- __pycache__

```
--- File List and Contents ---
```
File: D:\Projects\Game Dev\D&D text RPG\src\dndrpg\content\campaigns\srd_sandbox.yaml
schema_version: 1
id: camp.srd_sandbox
name: SRD Sandbox
description: A system-reference solo sandbox with SRD content.
start_area: "overworld:greenfields"
start_coords: [12, 8]
start_time: "1000-01-01T08:00:00Z"
start_level: 1
allowed:
  races: ["human","dwarf","elf","halfling","half-elf","half-orc","gnome"]
  classes: ["fighter","cleric","sorcerer","monk"]
  feats: "*"
  alignments: "*"
starting_gold_policy: "kits"
starting_equipment_packs:
  fighter: ["kit.fighter.starter"]
  cleric: ["kit.cleric.starter"]
  sorcerer: ["kit.sorcerer.starter"]
  monk: ["kit.monk.starter"]
rest_rules:
  arcane_prep: { rest_hours: 8, prep_hours: 1 }
  divine_prep: { time: "dawn", prep_hours: 1 }
houserules:
  hp_first_level_max: true
  point_buy: 32
  dr_policy: "per_attack_total"
encounters:
  wilderness: "encounterTable.forest.day"
```

```
File: D:\Projects\Game Dev\D&D text RPG\src\dndrpg\content\conditions\prone.yaml
schema_version: 1
id: cond.prone
name: Prone
tags: ["prone"]
precedence: 500
default_duration:
  type: instantaneous
modifiers: []
ruleHooks: []
```

```
File: D:\Projects\Game Dev\D&D text RPG\src\dndrpg\content\conditions\stunned.yaml
schema_version: 1
id: cond.stunned
name: Stunned
tags: ["stunned"]
precedence: 700
default_duration:
  type: rounds
  value: 1
modifiers: []
ruleHooks: []
```

```
File: D:\Projects\Game Dev\D&D text RPG\src\dndrpg\content\deities\pholtus.yaml
id: deity.pholtus
name: Pholtus
description: God of Light, Resolution, and Law.
alignment: "lawful good"
allowed_alignments:
  - lawful good
  - lawful neutral
  - lawful evil
domains:
  - domain.fire
  - domain.law
  - domain.sun
```

```
File: D:\Projects\Game Dev\D&D text RPG\src\dndrpg\content\effects\demo_autoshaken.yaml
schema_version: 1
id: spell.demo_autoshaken
name: Demo Auto Shaken
source: spell
abilityType: Spell
activation: { action: standard }
range: { type: personal }
duration: { type: rounds, value: 3 }
gates: { sr: { applies: false } }
ruleHooks:
  - scope: scheduler
    match: { event: "startOfTurn" }
    action:
      - op: condition.apply
        id: cond.shaken
        duration: { type: rounds, value: 1 }
```

```
File: D:\Projects\Game Dev\D&D text RPG\src\dndrpg\content\effects\divine_power.json
{
  "schema_version": 1,
  "id": "spell.divine_power",
  "name": "Divine Power",
  "source": "spell",
  "abilityType": "Spell",
  "school": "Evocation",
  "activation": { "action": "standard", "provokesAoO": true, "costs": ["spellslot:cleric:4"] },
  "range": { "type": "personal" },
  "duration": { "type": "rounds", "formula": "caster_level()" },
  "gates": { "sr": { "applies": false } },
  "modifiers": [
    { "targetPath": "abilities.str.enhancement", "operator": "add", "value": 6, "bonusType": "enhancement" },
        { "targetPath": "attack.bab.effective", "operator": "max", "value": "level()", "bonusType": "unnamed" }
  ],
  "operations": [
    { "op": "temp_hp", "amount": "caster_level()" }
  ]
}
```

```
File: D:\Projects\Game Dev\D&D text RPG\src\dndrpg\content\effects\domain.fire.yaml
id: domain.fire
name: Fire Domain
description: Gain fire-related abilities.
abilityType: Ex
type: Domain
properties:
  - type: bonus
    target: spell_damage.fire
    amount: 1
    bonus_type: untyped
```

```
File: D:\Projects\Game Dev\D&D text RPG\src\dndrpg\content\effects\grease_area.json
{
  "schema_version": 1,
  "id": "spell.grease.square",
  "name": "Grease (Area)",
  "abilityType": "Spell",
  "school": "Conjuration(Creation)",
  "activation": { "action": "standard", "costs": ["spellslot:sorwiz:1"] },
  "range": { "type": "close" },
  "area": { "shape": "square", "size_ft": 10 },
  "duration": { "type": "rounds", "formula": "caster_level()" },
  "operations": [
    {
      "op": "zone.create",
      "zone_id": "zone.grease.square",
      "duration": { "type": "rounds", "formula": "caster_level()" }
    }
  ]
}
```

```
File: D:\Projects\Game Dev\D&D text RPG\src\dndrpg\content\effects\test_burn.yaml
schema_version: 1
id: spell.test_burn
name: Test Burn
source: spell
abilityType: Spell
activation: { action: standard }
range: { type: personal }
duration: { type: instantaneous }
gates: { sr: { applies: false } }
operations:
  - op: damage
    amount: 5
    damage_type: fire
```

```
File: D:\Projects\Game Dev\D&D text RPG\src\dndrpg\content\effects\test_grease_personal.yaml
schema_version: 1
id: spell.test_grease_personal
name: Test Grease (personal)
source: spell
abilityType: Spell
activation: { action: standard }
range: { type: personal }
duration: { type: instantaneous }
gates: { sr: { applies: false } }
operations:
  - op: zone.create
    name: "Grease Aura"
    shape: { shape: square, size_ft: 10 }
    duration: { type: rounds, value: 2 }
    hooks:
      - scope: scheduler
        match: { event: "startOfTurn" }
        action:
          - op: condition.apply
            id: cond.prone
            duration: { type: instantaneous }
```

```
File: D:\Projects\Game Dev\D&D text RPG\src\dndrpg\content\effects\test_heal.yaml
schema_version: 1
id: spell.test_heal
name: Test Heal
source: spell
abilityType: Spell
activation: { action: standard }
range: { type: personal }
duration: { type: instantaneous }
gates: { sr: { applies: false } }
operations:
  - op: heal_hp
    amount: 3
```

```
File: D:\Projects\Game Dev\D&D text RPG\src\dndrpg\content\effects\test_poison.yaml
schema_version: 1
id: spell.test_poison
name: Test Poison
source: spell
abilityType: Spell
activation: { action: standard }
range: { type: personal }
duration: { type: instantaneous }
gates: { sr: { applies: false } }
operations:
  - op: ability.damage
    ability: con
    amount: 2
```

```
File: D:\Projects\Game Dev\D&D text RPG\src\dndrpg\content\effects\test_stun.yaml
schema_version: 1
id: spell.test_stun
name: Test Stun
source: spell
abilityType: Spell
activation: { action: standard }
range: { type: personal }
duration: { type: instantaneous }
gates: { sr: { applies: false } }
operations:
  - op: condition.apply
    id: cond.stunned
    duration: { type: rounds, value: 2 }
```

```
File: D:\Projects\Game Dev\D&D text RPG\src\dndrpg\content\items\armors\chain_shirt.yaml
schema_version: 1
type: armor
id: ar.chain_shirt
name: Chain Shirt
armor_type: light
armor_bonus: 4
max_dex_bonus: 4
armor_check_penalty: -2
arcane_spell_failure_pct: 20
weight_lb: 25.0
cost_gp: 100.0
```

```
File: D:\Projects\Game Dev\D&D text RPG\src\dndrpg\content\items\misc\holy_symbol.yaml
schema_version: 1
type: item
id: it.holy_symbol
name: Holy Symbol (Wooden)
weight_lb: 0.0
cost_gp: 1.0
```

```
File: D:\Projects\Game Dev\D&D text RPG\src\dndrpg\content\items\misc\rations_5.yaml
schema_version: 1
type: item
id: it.rations.5
name: Rations (5 days)
weight_lb: 5.0
cost_gp: 2.5
```

```
File: D:\Projects\Game Dev\D&D text RPG\src\dndrpg\content\items\shields\heavy_wooden_shield.yaml
schema_version: 1
type: shield
id: sh.heavy_wooden
name: Heavy Wooden Shield
shield_bonus: 2
armor_check_penalty: -2
arcane_spell_failure_pct: 15
weight_lb: 10.0
cost_gp: 7.0
```

```
File: D:\Projects\Game Dev\D&D text RPG\src\dndrpg\content\items\weapons\heavy_mace.yaml
schema_version: 1
type: weapon
id: wp.mace.heavy
name: Heavy Mace
category: simple
kind: melee
handed: one-handed
damage_dice_m: "1d8"
crit_range: 20
crit_mult: 2
damage_types: ["bludgeoning"]
weight_lb: 8.0
cost_gp: 12.0
```

```
File: D:\Projects\Game Dev\D&D text RPG\src\dndrpg\content\kits\kit.cleric.starter.yaml
schema_version: 1
id: kit.cleric.starter
name: Cleric Starter Kit
items:
  - "wp.mace.heavy"
  - "ar.chain_shirt"
  - "sh.heavy_wooden"
  - "it.holy_symbol"
  - "it.rations.5"
auto_equip:
  armor: "ar.chain_shirt"
  shield: "sh.heavy_wooden"
  main_hand: "wp.mace.heavy"
```

```
File: D:\Projects\Game Dev\D&D text RPG\src\dndrpg\content\kits\kit.fighter.starter.yaml
schema_version: 1
id: kit.fighter.starter
name: Fighter Starter Kit
items:
  - "wp.mace.heavy"
  - "ar.chain_shirt"
  - "sh.heavy_wooden"
  - "it.rations.5"
auto_equip:
  armor: "ar.chain_shirt"
  shield: "sh.heavy_wooden"
  main_hand: "wp.mace.heavy"
```

```
File: D:\Projects\Game Dev\D&D text RPG\src\dndrpg\content\kits\kit.monk.starter.yaml
schema_version: 1
id: kit.monk.starter
name: Monk Starter Kit
items:
  - "it.rations.5"
auto_equip: {}
```

```
File: D:\Projects\Game Dev\D&D text RPG\src\dndrpg\content\kits\kit.sorcerer.starter.yaml
schema_version: 1
id: kit.sorcerer.starter
name: Sorcerer Starter Kit
items:
  - "wp.mace.heavy"
  - "it.rations.5"
auto_equip:
  main_hand: "wp.mace.heavy"
```

```
File: D:\Projects\Game Dev\D&D text RPG\src\dndrpg\content\zones\grease_square.yaml
schema_version: 1
id: zone.grease.square
name: Grease (Area)
shape: { shape: square, size_ft: 10 }
duration: { type: rounds, formula: "caster_level()" }
hooks:
  - scope: scheduler
    match: { event: "startOfTurn(occupant)" }
    action:
      - op: "save"
        type: "Ref"
        dc: "10 + 1 + ability_mod('int')"   # adjust per your caster
        on_fail:
          - op: "condition.apply"
            id: "cond.prone"
```

```
File: D:\Projects\Game Dev\D&D text RPG\src\dndrpg\engine\campaigns.py
from __future__ import annotations
from pydantic import BaseModel, Field
from typing import Dict, List, Optional, Literal
from typing_extensions import Annotated
from pydantic import Field as PField

IDStr = Annotated[str, PField(pattern=r"^[a-z0-9_.:-]+$")]

class StartingKit(BaseModel):
    id: IDStr
    name: str
    items: List[str] = Field(default_factory=list)
    auto_equip: Dict[str, str] = Field(default_factory=dict)

class WealthRules(BaseModel):
    mode: Literal["kits","roll","fixed"] = "kits"
    fixed_gp: Optional[int] = None

class HouseRules(BaseModel):
    hp_first_level_max: bool = True
    point_buy: int = 28
    dr_policy: Literal["per_attack_total","per_packet"] = "per_attack_total"
    save_nat20_auto: bool = True
    save_nat1_auto_fail: bool = True

class AllowedLists(BaseModel):
    races: List[str] | str = "*"
    classes: List[str] | str = "*"
    feats: List[str] | str = "*"
    alignments: List[str] | str = "*"
    deities: List[str] | str = "*"
    domains: List[str] | str = "*"

class CampaignDefinition(BaseModel):
    id: IDStr
    name: str
    description: str = ""

    start_area: str = "overworld"
    start_coords: tuple[int,int] = (0, 0)
    start_time: str = "1000-01-01T08:00:00Z"
    start_level: int = 1

    allowed: AllowedLists = Field(default_factory=AllowedLists)
    wealth: WealthRules = Field(default_factory=WealthRules)
    rest_rules: Dict[str, dict] = Field(default_factory=dict)
    houserules: HouseRules = Field(default_factory=HouseRules)

    starting_equipment_packs: Dict[str, List[str]] = Field(default_factory=dict)
    encounters: Dict[str, str] = Field(default_factory=dict)
```

```
File: D:\Projects\Game Dev\D&D text RPG\src\dndrpg\engine\chargen.py
from __future__ import annotations
from dataclasses import dataclass, field
from typing import Dict, List, Set, Optional, Any
from dndrpg.engine.models import Entity, Abilities, AbilityScore, Size, Weapon, Armor, Shield
from dndrpg.engine.loader import ContentIndex
from dndrpg.engine.effects_runtime import EffectsEngine
from dndrpg.engine.resources_runtime import ResourceEngine
from dndrpg.engine.conditions_runtime import ConditionsEngine
from dndrpg.engine.rulehooks_runtime import RuleHooksRegistry
from dndrpg.engine.state import GameState
from dndrpg.engine.skills import skill_points_at_level1, max_ranks, CLASS_SKILLS
from dndrpg.engine.spells import bonus_slots_from_mod, sorcerer_spells_known_from_cha
from dndrpg.engine.prereq import eval_prereq, BuildView

@dataclass
class CharBuildState:
    name: str = "Hero"
    alignment: str = "neutral"
    deity: Optional[str] = None
    race: str = "human"
    clazz: str = "fighter"
    level: int = 1

    abilities: Dict[str, int] = field(default_factory=lambda: {"str":15,"dex":12,"con":14,"int":10,"wis":12,"cha":8})
    skills: Dict[str, int] = field(default_factory=dict)   # skill->ranks
    feats: Set[str] = field(default_factory=set)
    languages: List[str] = field(default_factory=list)
    domains: List[str] = field(default_factory=list)
    spells_known: List[str] = field(default_factory=list)
    spells_prepared: Dict[int, List[str]] = field(default_factory=dict)  # level -> ids
    gear_ids: List[str] = field(default_factory=list)  # simple; kits will fill
    feat_choices: Dict[str, Dict[str, str]] = field(default_factory=dict)  # feat_id -> {choice_name: value}

def validate_character_picks(content: ContentIndex, picks: CharBuildState) -> tuple[bool, str]:
    # Validate Deity
    if picks.deity:
        deity_id = picks.deity # Assuming picks.deity is the ID
        if deity_id not in content.deities:
            return False, f"Selected deity '{deity_id}' does not exist."
        deity_def = content.deities[deity_id]

        # Validate Deity Alignment
        if picks.alignment not in deity_def.allowed_alignments:
            return False, f"Alignment '{picks.alignment}' is not allowed by deity '{deity_def.name}'."

        # Validate Cleric Domains against Deity's allowed domains
        if picks.clazz == "cleric" and picks.domains:
            for domain_id in picks.domains:
                if domain_id not in deity_def.allowed_domains:
                    return False, f"Domain '{domain_id}' is not allowed by deity '{deity_def.name}'."

    # Validate Campaign Allowed Lists
    # Assuming there's always at least one campaign and we use the first one for character generation
    if not content.campaigns:
        return False, "No campaigns defined in content."
    campaign_allowed = next(iter(content.campaigns.values())).allowed

    # Validate Alignment against campaign allowed list
    if isinstance(campaign_allowed.alignments, list) and picks.alignment not in campaign_allowed.alignments:
        return False, f"Alignment '{picks.alignment}' is not allowed by the campaign."

    # Validate Domains against campaign allowed list
    if picks.clazz == "cleric" and picks.domains:
        if isinstance(campaign_allowed.domains, list):
            for domain_id in picks.domains:
                if domain_id not in campaign_allowed.domains:
                    return False, f"Domain '{domain_id}' is not allowed by the campaign."

    # Validate Skills
    temp_int_score = picks.abilities.get("int", 10)
    temp_int_mod = (temp_int_score - 10) // 2
    total_skill_points = skill_points_at_level1(picks.clazz, temp_int_mod, picks.race == "human")
    allocated_points = sum(picks.skills.values())

    if allocated_points > total_skill_points:
        return False, f"Allocated skill points ({allocated_points}) exceed available ({total_skill_points})."

    for skill_name, ranks in picks.skills.items():
        is_class_skill = skill_name in CLASS_SKILLS.get(picks.clazz, [])
        max_allowed_ranks = max_ranks(picks.level, is_class_skill)
        if ranks > max_allowed_ranks:
            return False, f"Skill '{skill_name}' has too many ranks ({ranks}). Max allowed: {max_allowed_ranks}."

    # Validate Feats
    picks_dict = {
        "abilities": picks.abilities,
        "class": picks.clazz, # Use "class" key for BuildView
        "level": picks.level,
        "race": picks.race,
        "feats": picks.feats,
        "skills": picks.skills,
        "alignment": picks.alignment,
        "deity": picks.deity,
        "domains": picks.domains,
    }
    build_view = BuildView(entity=None, picks=picks_dict)
    for feat_id in picks.feats:
        feat_def = content.effects.get(feat_id)
        if not feat_def:
            return False, f"Selected feat '{feat_id}' does not exist."
        if feat_def.prerequisites:
            can_take_feat, prereq_msg = eval_prereq(feat_def.prerequisites, build_view)
            if not can_take_feat:
                return False, f"Feat '{feat_def.name}' prerequisites not met: {prereq_msg}"

    # Validate Spells
    if picks.clazz == "cleric":
        wis_mod = (picks.abilities.get("wis", 10) - 10) // 2
        expected_slots = bonus_slots_from_mod(wis_mod, max_level=picks.level) # Assuming max_level is current level
        
        for level, prepared_spells in picks.spells_prepared.items():
            if level not in expected_slots:
                return False, f"Cleric cannot prepare level {level} spells at this level."
            if len(prepared_spells) > expected_slots[level]:
                return False, f"Cleric prepared too many level {level} spells ({len(prepared_spells)}). Max allowed: {expected_slots[level]}."
            for spell_id in prepared_spells:
                if spell_id not in content.effects: # Assuming spells are effects
                    return False, f"Prepared spell '{spell_id}' does not exist."

    elif picks.clazz == "sorcerer":
        cha_mod = (picks.abilities.get("cha", 10) - 10) // 2
        expected_known = sorcerer_spells_known_from_cha(picks.level, cha_mod)

        for level, known_count in expected_known.items():
            # Count spells known for this level
            actual_known_count = 0
            for spell_id in picks.spells_known:
                # This is a simplification. A proper check would involve knowing the spell's level.
                # For now, we'll just count all known spells and compare to the total expected.
                # This assumes picks.spells_known only contains spells for levels they can cast.
                if spell_id in content.effects: # Assuming spells are effects
                    # Need to get spell level from content.effects[spell_id]
                    # For now, a basic check:
                    actual_known_count += 1
            
            # This comparison is flawed as it compares total known spells to per-level known.
            # A more robust solution would involve categorizing picks.spells_known by level.
            # For MVP, we'll just check if the total number of known spells exceeds the sum of expected known spells.
            total_expected_known = sum(expected_known.values())
            if len(picks.spells_known) > total_expected_known:
                return False, f"Sorcerer knows too many spells ({len(picks.spells_known)}). Max allowed: {total_expected_known}."
            
            for spell_id in picks.spells_known:
                if spell_id not in content.effects:
                    return False, f"Known spell '{spell_id}' does not exist."

    return True, "Character picks are valid."

def build_entity_from_state(content: ContentIndex, gs: GameState, picks: CharBuildState,
                            effects: EffectsEngine, resources: ResourceEngine, conditions: ConditionsEngine, hooks: RuleHooksRegistry) -> tuple[Entity | None, str | None]:
    # Validate character picks first
    is_valid, validation_message = validate_character_picks(content, picks)
    if not is_valid:
        return None, validation_message

    # Instantiate entity
    ab = Abilities(
        str_=AbilityScore(base=picks.abilities["str"]),
        dex=AbilityScore(base=picks.abilities["dex"]),
        con=AbilityScore(base=picks.abilities["con"]),
        int_=AbilityScore(base=picks.abilities["int"]),
        wis=AbilityScore(base=picks.abilities["wis"]),
        cha=AbilityScore(base=picks.abilities["cha"]),
    )
    ent = Entity(
        id="pc.hero", name=f"{picks.name} ({picks.race.title()} {picks.clazz.title()} 1)",
        level=1, size=Size.MEDIUM, abilities=ab
    )
    # Base class table (extend later)
    CLASS: Dict[str, Dict[str, Any]] = { # Added type hint for CLASS
        "fighter": {"hd":10, "bab":"full", "fort":"good","ref":"poor","will":"poor"},
        "cleric":  {"hd": 8, "bab":"three_quarter","fort":"good","ref":"poor","will":"good"},
        "sorcerer":{"hd": 4, "bab":"half","fort":"poor","ref":"poor","will":"good"},
        "monk":    {"hd": 8, "bab":"three_quarter","fort":"good","ref":"good","will":"good"},
    }
    def bab_from_prog(prog: str, lvl: int) -> int:
        return {"full":lvl,"three_quarter":(lvl*3)//4,"half":lvl//2}.get(prog, 0)
    cls = CLASS[picks.clazz]
    ent.base_attack_bonus = bab_from_prog(str(cls["bab"]), 1) # Explicitly cast to str
    ent.base_fort = 2 if cls["fort"]=="good" else 0
    ent.base_ref  = 2 if cls["ref"]=="good" else 0
    ent.base_will = 2 if cls["will"]=="good" else 0
    ent.hp_max = max(1, int(cls["hd"]) + ent.abilities.con.mod()) # Explicitly cast to int
    ent.hp_current = ent.hp_max
    ent.classes = {picks.clazz: 1}
    if picks.clazz in {"cleric","sorcerer"}:
        ent.caster_levels = {picks.clazz: 1}
    ent.hd = 1

    # Inventory/equip via kits or picks.gear_ids
    inv = []
    for iid in picks.gear_ids:
        if iid in content.items_by_id:
            inv.append(content.items_by_id[iid].model_copy(deep=True))
    ent.inventory = inv
    # naive auto-equip based on id prefixes
    for item in inv:
        if isinstance(item, Armor) and item.armor_type in {"light","medium","heavy"}:
            ent.equipment["armor"] = item.id
        elif isinstance(item, Shield):
            ent.equipment["shield"] = item.id
        elif isinstance(item, Weapon):
            if "main_hand" not in ent.equipment:
                ent.equipment["main_hand"] = item.id
            elif "ranged" not in ent.equipment and item.kind != "melee":
                ent.equipment["ranged"] = item.id

    # Attach race/class passive effects (continuous/permanent)
    # Expect content/effects/races/*.yaml and content/effects/classes/*.yaml with ids like race.human, class.fighter.l1
    for race_eff in [f"race.{picks.race}"]:
        if race_eff in content.effects:
            effects.attach(race_eff, ent, ent)
    for cls_eff in [f"class.{picks.clazz}.l1"]:
        if cls_eff in content.effects:
            effects.attach(cls_eff, ent, ent)

    # Create class resources (turn attempts, spell slots, etc.)
    # Expect resources like res.turn_attempts; res.spell_slots.cleric.1
    if picks.clazz == "cleric":
        if "res.turn_attempts" in content.resources:
            resources.create_from_definition("res.turn_attempts", owner_scope="entity", owner_entity_id=ent.id)
        
        # Add bonus spell slots from WIS
        wis_mod = ent.abilities.wis.mod()
        bonus_slots = bonus_slots_from_mod(wis_mod)
        for level, count in bonus_slots.items():
            if count > 0:
                res_id = f"res.spell_slots.cleric.{level}"
                if res_id in content.resources:
                    # Assuming create_from_definition can update existing or add to initial_current
                    # For now, we'll just create it with the bonus if it doesn't exist
                    # A more robust solution would be to update an existing resource's current/max
                    resources.create_from_definition(res_id, owner_scope="entity", owner_entity_id=ent.id, initial_current=count)

        # Domains for cleric (store on entity tags for later; or attach domain effects)
        # e.g., effect ids: domain.war.grant; domain.sun.grant
        for d in picks.domains or []:
            eff_id = f"domain.{d.lower()}.grant"
            if eff_id in content.effects:
                effects.attach(eff_id, ent, ent)

    elif picks.clazz == "sorcerer":
        cha_mod = ent.abilities.cha.mod()
        spells_known = sorcerer_spells_known_from_cha(picks.level, cha_mod)
        
        # Populate spells_known in the entity
        ent.spells_known = picks.spells_known # Use spells picked by the user in UI

        # Create spell slot resources for Sorcerer
        # Assuming a resource definition like "res.spell_slots.sorcerer.0", "res.spell_slots.sorcerer.1"
        for level, count in spells_known.items(): # Use spells_known to determine available levels
            if count > 0:
                res_id = f"res.spell_slots.sorcerer.{level}"
                if res_id in content.resources:
                    resources.create_from_definition(res_id, owner_scope="entity", owner_entity_id=ent.id, initial_current=count)

    # Feats: attach feats as effects (source 'feat'), content id e.g. "feat.power_attack"
    for feat_id in picks.feats:
        if feat_id in content.effects:
            # Pass feat choices to the effect attachment
            bound_choices = picks.feat_choices.get(feat_id)
            effects.attach(feat_id, ent, ent, bound_choices=bound_choices)

    # Skills: apply allocated skill ranks
    ent.skills = picks.skills

    # Skills & languages: store on entity (add fields if needed later)
    # For now, keep in a side-map (we can add fields to Entity later)
    # Return entity; GameState already exists; assign entity into state.player
    gs.player = ent
    return ent, None
```

```
File: D:\Projects\Game Dev\D&D text RPG\src\dndrpg\engine\chargen_helpers.py
from __future__ import annotations
import random
from typing import Dict, List

STANDARD_ARRAYS = {
    "classic": [15,14,13,12,10,8],
    "balanced": [16,14,13,12,10,8],
}

def roll_4d6_drop_lowest(rng: random.Random) -> int:
    rolls = sorted([rng.randint(1,6) for _ in range(4)], reverse=True)
    return sum(rolls[:3])

def generate_4d6(rng: random.Random, reroll_ones: bool=False) -> List[int]:
    scores = []
    for _ in range(6):
        if reroll_ones:
            # reroll any '1' in each die
            rolls = []
            for _ in range(4):
                r = rng.randint(1,6)
                while r == 1:
                    r = rng.randint(1,6)
                rolls.append(r)
            rolls.sort(reverse=True)
            scores.append(sum(rolls[:3]))
        else:
            scores.append(roll_4d6_drop_lowest(rng))
    return sorted(scores, reverse=True)

def assign_scores_to_abilities(scores: List[int], order: List[str]) -> Dict[str, int]:
    # order is a list like ["str","dex","con","int","wis","cha"] chosen by the user
    return {ab: scores[i] for i, ab in enumerate(order)}
```

```
File: D:\Projects\Game Dev\D&D text RPG\src\dndrpg\engine\conditions_runtime.py
from __future__ import annotations
from typing import Optional, Dict, List, Tuple, TYPE_CHECKING
from uuid import uuid4
from pydantic import BaseModel, Field
from dndrpg.engine.schema_models import ConditionDefinition, DurationSpec
from dndrpg.engine.expr import eval_for_actor
from dndrpg.engine.models import Entity
from dndrpg.engine.loader import ContentIndex

if TYPE_CHECKING:
    from dndrpg.engine.state import GameState
    from dndrpg.engine.rulehooks_runtime import RuleHooksRegistry

class ConditionInstance(BaseModel):
    instance_id: str = Field(default_factory=lambda: uuid4().hex)
    definition_id: str
    name: str
    source_entity_id: str
    target_entity_id: str

    precedence: Optional[int] = None
    tags: List[str] = Field(default_factory=list)

    duration_type: str = "instantaneous"
    remaining_rounds: Optional[int] = None
    active: bool = True
    suppressed: bool = False
    applied_at_round: int = 0

    params: Dict[str, int | float | str] = Field(default_factory=dict)
    notes: Optional[str] = None

class ConditionsEngine:
    """
    Apply/remove/list conditions at runtime.
    Duration policy:
      - If OpConditionApply provides a duration override, use it; else use ConditionDefinition.default_duration.
      - Instantaneous conditions are attached and immediately eligible for cleanup by the engine (we keep the instance this round for visibility).
      - Re-applying same condition id refreshes duration to the max of old/new (no stacking by default).
        If an Op explicitly requests stacks=True, allow multiple instances.
    """

    def __init__(self, content: ContentIndex, state: "GameState", hooks: "RuleHooksRegistry" | None = None):
        self.content = content
        self.state = state
        self.hooks = hooks  # may be set later

    def _snapshot_duration_rounds(
        self,
        cd: ConditionDefinition,
        override: Optional[DurationSpec],
        source: Entity,
        target: Entity
    ) -> Tuple[str, Optional[int]]:
        ds: Optional[DurationSpec] = override or cd.default_duration
        if ds is None:
            # default to instantaneous for conditions with no default declared
            return ("instantaneous", None)
        dt = ds.type
        if dt in ("instantaneous", "permanent", "special"):
            return (dt, None)
        if dt == "rounds":
            if ds.value is not None:
                return ("rounds", max(0, int(ds.value)))
            if ds.formula:
                val = eval_for_actor(ds.formula, source)
                try:
                    return ("rounds", max(0, int(val)))
                except Exception:
                    return ("rounds", None)
            return ("rounds", None)
        # For minutes/hours/days: scheduler converts later
        return (dt, None)

    def _list_for_entity(self, entity_id: str) -> List[ConditionInstance]:
        return list(self.state.active_conditions.get(entity_id, []))

    def list_for_entity(self, entity_id: str) -> List[ConditionInstance]:
        return self._list_for_entity(entity_id)

    def apply(
        self,
        cond_id: str,
        source: Entity,
        target: Entity,
        *,
        duration_override: Optional[DurationSpec] = None,
        stacks: Optional[bool] = None,
        params: Optional[Dict[str, int | float | str]] = None
    ) -> list[str]:
        logs: list[str] = []
        if cond_id not in self.content.conditions:
            return [f"[Cond] Unknown condition id: {cond_id}"]
        cd = self.content.conditions[cond_id]

        dur_type, rem_rounds = self._snapshot_duration_rounds(cd, duration_override, source, target)
        new_inst = ConditionInstance(
            definition_id=cd.id,
            name=cd.name,
            source_entity_id=source.id,
            target_entity_id=target.id,
            precedence=cd.precedence,
            tags=list(cd.tags or []),
            duration_type=dur_type,
            remaining_rounds=rem_rounds,
            applied_at_round=self.state.round_counter,
            params=params or {}
        )

        lst = self.state.active_conditions.setdefault(target.id, [])

        if not stacks:
            # Find an existing same-id instance
            for inst in lst:
                if inst.definition_id == cond_id:
                    # Refresh/extend duration
                    if inst.duration_type == "rounds" and rem_rounds is not None:
                        if inst.remaining_rounds is None or rem_rounds > inst.remaining_rounds:
                            inst.remaining_rounds = rem_rounds
                    inst.active = True
                    logs.append(f"[Cond] Refreshed {cd.name} on {target.name} ({inst.remaining_rounds or 0} rounds)")
                    return logs

        # Else add a new instance
        lst.append(new_inst)
        if self.hooks:
            self.hooks.register_for_condition(cd, new_inst.instance_id, target.id)
        desc = dur_type + (f" {rem_rounds} rounds" if rem_rounds is not None else "")
        logs.append(f"[Cond] {cd.name} applied to {target.name} ({desc})")
        return logs

    def remove(self, cond_id: Optional[str] = None, *, instance_id: Optional[str] = None, target: Optional[Entity] = None) -> list[str]:
        logs: list[str] = []
        if not target:
            return ["[Cond] remove: missing target"]
        lst = self.state.active_conditions.get(target.id, [])
        if instance_id:
            for i, inst in enumerate(lst):
                if inst.instance_id == instance_id:
                    lst.pop(i)
                    if self.hooks:
                        self.hooks.unregister_by_parent(instance_id)
                    logs.append(f"[Cond] Removed {inst.name} from {target.name}")
                    return logs
            return ["[Cond] remove: instance not found"]
        if cond_id:
            kept = []
            removed_ids = []
            for inst in lst:
                if inst.definition_id == cond_id:
                    removed_ids.append(inst.instance_id)
                    logs.append(f"[Cond] Removed {inst.name} from {target.name}")
                else:
                    kept.append(inst)
            self.state.active_conditions[target.id] = kept
            if self.hooks:
                for iid in removed_ids:
                    self.hooks.unregister_by_parent(iid)
            return logs
        return ["[Cond] remove: specify cond_id or instance_id"]

    def tick_round(self) -> list[str]:
        logs: list[str] = []
        self.state.round_counter += 1
        for entity_id, lst in list(self.state.active_conditions.items()):
            keep: list[ConditionInstance] = []
            for inst in lst:
                if inst.duration_type == "rounds" and inst.remaining_rounds is not None:
                    if inst.remaining_rounds > 0:
                        inst.remaining_rounds -= 1
                    if inst.remaining_rounds <= 0:
                        logs.append(f"[Cond] {inst.name} expired")
                        if self.hooks:
                            self.hooks.unregister_by_parent(inst.instance_id)
                        continue
                keep.append(inst)
            self.state.active_conditions[entity_id] = keep
        return logs
```

```
File: D:\Projects\Game Dev\D&D text RPG\src\dndrpg\engine\damage_runtime.py
from __future__ import annotations
from dataclasses import dataclass
from typing import List, Optional, Literal, Tuple, TYPE_CHECKING
from .models import Entity, DREntry, DamageKind
from .loader import ContentIndex
from .rulehooks_runtime import RuleHooksRegistry

if TYPE_CHECKING:
    from .state import GameState
    from .resources_runtime import ResourceState

@dataclass
class DamagePacket:
    amount: int
    dkind: DamageKind
    counts_as_magic: bool = False
    counts_as_material: Optional[List[Literal["adamantine","silver","cold-iron"]]] = None
    counts_as_alignment: Optional[List[Literal["good","evil","law","chaos"]]] = None

@dataclass
class AttackContext:
    # For DR policy, treat all packets in one call as a single attack
    source_entity_id: Optional[str] = None
    note: str = ""

@dataclass
class PipelineResult:
    total_hp_damage: int
    total_nonlethal: int
    physical_damage_applied: int      # sum of physical damage that actually hit HP (post DR/resist/pools/vuln)
    logs: List[str]

class DamageEngine:
    """
    Full pipeline:
      1) Immunity
      2) Type conversion (pre-hook)
      3) Resist/DR/ablative pools
         - DR policy: apply to total physical damage per attack (combine all non-bypassed physical packets)
         - Energy resist per packet
         - Pools applied after DR (temp HP modeled via absorption.any)
      4) Vulnerability (per packet)
      5) Apply to HP / Nonlethal
      6) Injury rider negation signal (physical_damage_applied == 0)
      7) Post hooks (triggers only)
    """

    def __init__(self, content: ContentIndex, state: "GameState", hooks: Optional[RuleHooksRegistry] = None):
        self.content = content
        self.state = state
        self.hooks = hooks

    # ------- helpers -------
    def _entity_by_id(self, ent_id: str | None) -> Optional[Entity]:
        if not ent_id:
            return None
        if self.state.player.id == ent_id:
            return self.state.player
        return None

    def _find_absorbers(self, entity_id: str, dkind: DamageKind) -> List["ResourceState"]:
        matches: List[ResourceState] = []
        key_ent = f"entity:{entity_id}"
        for rs in self.state.resources.get(key_ent, []):
            if rs.absorption and self._absorption_matches(rs, dkind):
                matches.append(rs)
        for key, lst in self.state.resources.items():
            if not key.startswith("effect:"):
                continue
            for rs in lst:
                if rs.owner_entity_id == entity_id and rs.absorption and self._absorption_matches(rs, dkind):
                    matches.append(rs)
        return matches

    def _absorption_matches(self, rs: "ResourceState", dkind: DamageKind) -> bool:
        if not rs.absorption:
            return False
        types = set(rs.absorption.absorbTypes or [])
        if "any" in types:
            return True
        if "physical" in types and dkind.startswith("physical."):
            return True
        return dkind in types

    def _dr_applies(self, dr: DREntry, pkt: DamagePacket) -> bool:
        # True if this DR entry applies to the packet (i.e., not bypassed)
        if pkt.counts_as_magic and dr.bypass_magic:
            return False
        if dr.bypass_materials:
            if pkt.counts_as_material and any(m in dr.bypass_materials for m in pkt.counts_as_material):
                return False
        if dr.bypass_alignments:
            if pkt.counts_as_alignment and any(a in dr.bypass_alignments for a in pkt.counts_as_alignment):
                return False
        if dr.bypass_weapon_types:
            # If packet is physical of type matching bypass weapon types (slashing, etc.) treat as bypass
            # We have pkt.dkind like "physical.slashing" | "...piercing" | "...bludgeoning"
            tail = pkt.dkind.split(".")[-1] if pkt.dkind.startswith("physical.") else ""
            if tail and tail in dr.bypass_weapon_types:
                return False
        return True

    # ------- pipeline -------
    def apply_packets(self, target_entity_id: str, packets: List[DamagePacket], *, ctx: Optional[AttackContext] = None) -> PipelineResult:
        logs: List[str] = []
        ent = self._entity_by_id(target_entity_id)
        if not ent:
            logs.append("[Dmg] unknown target")
            return PipelineResult(0,0,0,logs)
        # Stage 1: Immunity
        working: List[DamagePacket] = []
        for p in packets:
            if p.dkind in ent.immunities:
                logs.append(f"[Dmg] Immune to {p.dkind} (ignored {p.amount})")
                continue
            working.append(DamagePacket(amount=max(0,int(p.amount)),
                                        dkind=p.dkind,
                                        counts_as_magic=p.counts_as_magic,
                                        counts_as_material=p.counts_as_material,
                                        counts_as_alignment=p.counts_as_alignment))
        if not working:
            return PipelineResult(0,0,0,logs)

        # Stage 2: Type conversion via pre-hook
        if self.hooks:
            tr = self.hooks.incoming_damage(target_entity_id, {"event":"incoming.damage.pre"})
            conv_to = tr.get("convert")
            if conv_to:
                for p in working:
                    p.dkind = conv_to
                logs.append(f"[Dmg] Converted type to {conv_to} by hook")

        # Stage 3: Resist / DR / Ablative pools
        # 3.1 Energy resistance per packet
        for p in working:
            resist = int(ent.energy_resist.get(p.dkind, 0) or 0)
            if resist > 0 and p.amount > 0:
                reduced = max(0, p.amount - resist)
                if reduced != p.amount:
                    logs.append(f"[Dmg] Resist {p.dkind} {resist} â†’ {p.amount}->{reduced}")
                    p.amount = reduced

        # 3.2 DR per attack total (physical only; non-bypassed)
        # Collect DR entries and compute total physical amount subject to DR
        phys_indices = [i for i, pkt in enumerate(working) if pkt.dkind.startswith("physical.") and pkt.amount > 0]
        if phys_indices and ent.dr:
            # Choose the best DR entry (highest value) that applies to this attackâ€™s packets
            # RAW: one DR value applies; we take the single best DR among the ones that are not bypassed by all packets.
            applicable_dr_values: List[Tuple[int,DREntry]] = []
            for dr in ent.dr:
                # If at least one packet would be reduced by this DR (i.e., not bypassed), consider it
                any_applies = any(self._dr_applies(dr, working[i]) for i in phys_indices)
                if any_applies:
                    applicable_dr_values.append((dr.value, dr))
            if applicable_dr_values:
                best_value, best_dr = max(applicable_dr_values, key=lambda x: x[0])
                # Compute sum of amounts of packets for which DR applies
                sum_subject = sum(working[i].amount for i in phys_indices if self._dr_applies(best_dr, working[i]))
                if sum_subject > 0 and best_value > 0:
                    dr_amount = min(best_value, sum_subject)
                    logs.append(f"[Dmg] DR {best_value}/- reduces total physical {sum_subject} by {dr_amount} (per attack)")
                    # Reduce packets in order until DR is consumed
                    remaining_dr = dr_amount
                    for i in phys_indices:
                        if remaining_dr <= 0:
                            break
                        pkt = working[i]
                        if not self._dr_applies(best_dr, pkt) or pkt.amount <= 0:
                            continue
                        take = min(pkt.amount, remaining_dr)
                        pkt.amount -= take
                        remaining_dr -= take

        # 3.3 Ablative pools (temp HP, Stoneskin-like) after DR
        # Absorption per packet with absorbPerHit cap
        for p in working:
            if p.amount <= 0:
                continue
            absorbers = self._find_absorbers(target_entity_id, p.dkind)
            for rs in absorbers:
                if p.amount <= 0:
                    break
                per_hit_cap = rs.absorption.absorbPerHit if rs.absorption else None
                can = rs.current
                if per_hit_cap is not None:
                    can = min(can, per_hit_cap)
                take = min(can, p.amount)
                if take > 0:
                    rs.current -= take
                    p.amount -= take
                    logs.append(f"[Dmg] {rs.name or rs.definition_id} absorbed {take} ({rs.current} left)")

        # Stage 4: Vulnerability (multiply)
        for p in working:
            if p.amount <= 0:
                continue
            v = float(ent.vulnerabilities.get(p.dkind, 1.0) or 1.0)
            if v != 1.0:
                new_amt = int(max(0, round(p.amount * v)))
                if new_amt != p.amount:
                    logs.append(f"[Dmg] Vulnerability {p.dkind} x{v} â†’ {p.amount}->{new_amt}")
                    p.amount = new_amt

        # Stage 5: Apply to HP / Nonlethal
        total_hp = 0
        total_nl = 0
        for p in working:
            if p.amount <= 0:
                continue
            if p.dkind == "nonlethal":
                # Nonlethal: stored separately
                ent.nonlethal_damage = max(0, ent.nonlethal_damage + p.amount)
                total_nl += p.amount
                logs.append(f"[Dmg] +{p.amount} nonlethal (total NL {ent.nonlethal_damage})")
            else:
                before = ent.hp_current
                ent.hp_current = max(0, ent.hp_current - p.amount)
                dealt = before - ent.hp_current
                total_hp += dealt
                logs.append(f"[Dmg] {p.dkind} +{dealt} (HP {ent.hp_current}/{ent.hp_max})")

        # Stage 6: Injury-rider negation signal
        physical_applied = sum(p.amount for p in working if p.dkind.startswith("physical."))

        # Stage 7: Post hooks (triggers only; no transforms here yet)
        if self.hooks:
            _ = self.hooks.incoming_damage(target_entity_id, {"event": "incoming.damage.post"})

        return PipelineResult(total_hp_damage=total_hp, total_nonlethal=total_nl, physical_damage_applied=physical_applied, logs=logs)
```

```
File: D:\Projects\Game Dev\D&D text RPG\src\dndrpg\engine\dice.py
from __future__ import annotations
import random

def d20(rng: random.Random) -> int:
    return rng.randint(1, 20)

def d100(rng: random.Random) -> int:
    return rng.randint(1, 100)
```

```
File: D:\Projects\Game Dev\D&D text RPG\src\dndrpg\engine\effects_runtime.py
from __future__ import annotations
from typing import Optional, Dict, List, TYPE_CHECKING
from uuid import uuid4
import random
from pydantic import BaseModel, Field
from .schema_models import Operation, EffectDefinition
from .expr import eval_for_actor
from .models import Entity
from .loader import ContentIndex
from dndrpg.engine.resources_runtime import ResourceEngine
from dndrpg.engine.conditions_runtime import ConditionsEngine
from .damage_runtime import DamageEngine, DamagePacket, AttackContext
from .zones_runtime import ZoneEngine
from .gates_runtime import GatesEngine
from .modifiers_runtime import ModifiersEngine
from .trace import TraceSession

if TYPE_CHECKING:
    from .state import GameState
    from dndrpg.engine.rulehooks_runtime import RuleHooksRegistry
    from .scheduler import Scheduler

class EffectInstance(BaseModel):
    instance_id: str = Field(default_factory=lambda: uuid4().hex)
    definition_id: str
    name: str
    abilityType: str
    source_entity_id: str
    target_entity_id: str

    # Duration snapshot (rounds for now; weâ€™ll support minutes/hours/days in scheduler later)
    duration_type: str = "instantaneous"  # matches DurationSpec.type
    remaining_rounds: Optional[int] = None  # None for non-round durations or permanent/instant
    active: bool = True
    suppressed: bool = False

    started_at_round: int = 0  # simple logical counter (to hook scheduler later)
    variables: Dict[str, int | float | str] = Field(default_factory=dict)  # runtime variables if needed
    notes: Optional[str] = None

class EffectsEngine:
    """
    Runtime manager for effect instances:
      - attach() creates an EffectInstance from a blueprint
      - detach() removes an instance
      - list_for_entity() returns active instances on an entity
    Gates/saves/attacks, modifiers, and operations execution will be wired in subsequent M2 steps.
    """

    def __init__(self, content: ContentIndex, state: "GameState",
                 resources: ResourceEngine | None = None,
                 conditions: ConditionsEngine | None = None,
                 hooks: RuleHooksRegistry | None = None,
                 damage: DamageEngine | None = None,
                 zones: ZoneEngine | None = None,
                 modifiers: ModifiersEngine | None = None,
                 rng: Optional[random.Random] = None,
                 scheduler: "Scheduler" | None = None): # Add scheduler parameter
        self.content = content
        self.state = state
        self.resources = resources or ResourceEngine(content, state)
        self.conditions = conditions or ConditionsEngine(content, state)
        self.hooks = hooks
        self.damage = damage
        self.zones = zones
        self.modifiers = modifiers
        self.rng = rng or random.Random()
        self.gates = GatesEngine(self.modifiers, self.rng) if self.modifiers else None
        self.scheduler = scheduler # Assign scheduler
        self.content = content
        self.state = state
        self.resources = resources or ResourceEngine(content, state)
        self.conditions = conditions or ConditionsEngine(content, state)
        self.hooks = hooks
        self.damage = damage
        self.zones = zones
        self.modifiers = modifiers
        self.rng = rng or random.Random()
        self.gates = GatesEngine(self.modifiers, self.rng) if self.modifiers else None

    def execute_operations(self, ops: List[Operation], actor: Optional[Entity], target: Optional[Entity], *,
                           parent_instance_id: Optional[str] = None, logs: Optional[List[str]] = None,
                           damage_scale: float = 1.0, crit_mult: int = 1):
        out = logs if logs is not None else []
        actor = actor or target
        buffered_packets: List[DamagePacket] = []
        def flush_packets():
            nonlocal buffered_packets
            if not buffered_packets or not self.damage or not target:
                buffered_packets = []
                return
            # Pre-phase hooks handled inside damage engine; we just call once per batch (treat as one attack)
            result = self.damage.apply_packets(target.id, buffered_packets, ctx=AttackContext(source_entity_id=actor.id if actor else None))
            out.extend(result.logs)
            buffered_packets = []

        for op in ops:
            opname = getattr(op, "op", None)
            if opname == "damage":
                amt = getattr(op, "amount", 0)
                base = amt if isinstance(amt, (int, float)) else eval_for_actor(str(amt), actor) if actor else 0
                final = int(round(float(base) * max(0.0, damage_scale) * max(1, crit_mult)))
                dtype = getattr(op, "damage_type", "typeless")
                pkt = DamagePacket(
                    amount=max(0, int(final)),
                    dkind=dtype,
                    counts_as_magic=bool(getattr(op, "counts_as_magic", False)),
                    counts_as_material=getattr(op, "counts_as_material", None),
                    counts_as_alignment=getattr(op, "counts_as_alignment", None),
                )
                buffered_packets.append(pkt)
                continue
            else:
                # If we encounter a non-damage op, flush any accumulated packets first
                flush_packets()
                # ... handle other ops as before ...

        # End: flush any remaining packets
        flush_packets()
        # NOTE: The original function returned `out`, but the new one doesn't explicitly. Assuming it should.
        return out

    def tick_round(self) -> list[str]:
        logs: list[str] = []
        # decrement remaining_rounds for each entity's effects; detach on 0
        for entity_id, lst in list(self.state.active_effects.items()):
            keep: list[EffectInstance] = []
            for inst in lst:
                if inst.duration_type == "rounds" and inst.remaining_rounds is not None:
                    if inst.remaining_rounds > 0:
                        inst.remaining_rounds -= 1
                    if inst.remaining_rounds <= 0:
                        # unregister hooks and drop
                        if self.hooks:
                            self.hooks.unregister_by_parent(inst.instance_id)
                        logs.append(f"[Effects] {inst.name} expired")
                        continue
                keep.append(inst)
            self.state.active_effects[entity_id] = keep
        return logs

    def _snapshot_duration_rounds(self, ed: EffectDefinition, source: Entity, target: Entity) -> tuple[str, int | None]:
        if not ed.duration:
            return "instantaneous", None
        dur_type = ed.duration.type
        rem_rounds = None
        if dur_type == "rounds":
            base = ed.duration.num_rounds or 0
            per_level = ed.duration.per_level or 0
            if per_level > 0:
                # Use source's appropriate caster level
                cl = source.caster_level_for(ed.abilityType)
                base += per_level * cl
            rem_rounds = int(base)
        return dur_type, rem_rounds

    def attach(self, effect_id: str, source: Entity, target: Entity, *, bound_choices: Optional[dict] = None) -> list[str]:
        trace = TraceSession()
        logs: list[str] = []
        if effect_id not in self.content.effects:
            self.state.last_trace = ["[Trace] Unknown effect id."]
            return [f"[Effects] Unknown effect id: {effect_id}"]
        ed = self.content.effects[effect_id]

        trace.add(f"[Effect] {ed.name} ({ed.abilityType}) on {target.name}")

        # Antimagic and incoming.effect decisions
        if self.zones and ed.abilityType in ("Su","Sp","Spell"):
            if self.zones.is_entity_under_antimagic(target.id):
                msg = f"[Effects] {ed.name} suppressed by antimagic; no effect"
                logs.append(msg)
                trace.add(msg)
                self.state.last_trace = trace.dump()
                return logs
        if self.hooks:
            dec = self.hooks.incoming_effect(target.id, effect_def=ed, actor_entity_id=source.id)
            trace.add(dec.notes and f"[Hooks] incoming.effect: {'; '.join(dec.notes)}" or "[Hooks] incoming.effect: allow")
            if not dec.allow:
                msg = f"[Effects] {ed.name} blocked"
                logs.append(msg)
                trace.add(msg)
                self.state.last_trace = trace.dump()
                return logs

        # Before resolved stats
        before_stats = self.modifiers.resolved_stats(target) if self.modifiers else None
        if before_stats:
            trace.add(f"[Before] AC {before_stats['ac_total']} (T {before_stats['ac_touch']}/FF {before_stats['ac_ff']}), "
                      f"Atk +{before_stats['attack_melee_bonus']}/+{before_stats['attack_ranged_bonus']}, "
                      f"Saves F+{before_stats['save_fort']} R+{before_stats['save_ref']} W+{before_stats['save_will']}")

        # Gates
        if self.gates:
            outcome, glogs = self.gates.evaluate(ed, source, target)
            logs += glogs
            trace.extend(glogs)
            if not outcome.allowed:
                msg = f"[Effects] {ed.name} did not take effect"
                logs.append(msg)
                trace.add(msg)
                self.state.last_trace = trace.dump()
                return logs
        else:
            from .gates_runtime import GateOutcome, SRResult, SaveResult, AttackResult
            outcome = GateOutcome(True, SRResult(False,True,""), SaveResult(False,False,None,0,0,0,None,""),
                                  AttackResult(False,True,False,1,0,0,0,False,""), 1.0, False, 1)

        dur_type, rem_rounds = self._snapshot_duration_rounds(ed, source, target)
        inst = EffectInstance(
            definition_id=ed.id, name=ed.name, abilityType=ed.abilityType,
            source_entity_id=source.id, target_entity_id=target.id,
            duration_type=dur_type, remaining_rounds=rem_rounds, started_at_round=self.state.round_counter
        )
        if bound_choices:
            inst.variables.update({f"choice.{k}": v for k, v in bound_choices.items()})

        # Ops (with scaling/crit) â†’ logs already from damage/resources/conditions
        op_logs = self.execute_operations(list(ed.operations or []), source, target,
                                          parent_instance_id=inst.instance_id, logs=[],
                                          damage_scale=outcome.damage_scale, crit_mult=outcome.crit_mult)
        logs += op_logs
        trace.extend(op_logs)

        if dur_type == "instantaneous":
            msg = f"[Effects] {ed.name} (instantaneous) applied to {target.name}"
            logs.append(msg)
            trace.add(msg)
            # After/stats diff (instantaneous conditions/resources may have changed display stats too)
            after_stats = self.modifiers.resolved_stats(target) if self.modifiers else None
            if before_stats and after_stats:
                trace.extend(self.modifiers.diff_stats(before_stats, after_stats))
            self.state.last_trace = trace.dump()
            return logs

        # Retain & register hooks
        self.state.active_effects.setdefault(target.id, []).append(inst)
        if self.hooks:
            self.hooks.register_for_effect(ed, inst.instance_id, target.id)
        if self.zones:
            logs += self.zones.update_suppression_for_entity(target.id)

        msg = f"[Effects] {ed.name} attached ({dur_type}{f' {rem_rounds} rounds' if rem_rounds is not None else ''})"
        logs.append(msg)
        trace.add(msg)

        # After resolved stats and diffs + (optional) per-path stacking explain
        after_stats = self.modifiers.resolved_stats(target) if self.modifiers else None
        if before_stats and after_stats:
            trace.extend(self.modifiers.diff_stats(before_stats, after_stats))
            # Optional: explain key paths that changed
            key_paths = ["ac.natural","ac.deflection","ac.dodge","attack.melee.bonus","attack.ranged.bonus","save.fort","save.ref","save.will","speed.land"]
            trace.extend(self.modifiers.explain_paths(target, key_paths))

        self.state.last_trace = trace.dump()
        return logs

    def detach(self, instance_id: str, target: Entity) -> bool:
        lst = self.state.active_effects.get(target.id, [])
        for i, inst in enumerate(lst):
            if inst.instance_id == instance_id:
                lst.pop(i)
                return True
        return False

    def list_for_entity(self, entity_id: str) -> List[EffectInstance]:
        return list(self.state.active_effects.get(entity_id, []))
```

```
File: D:\Projects\Game Dev\D&D text RPG\src\dndrpg\engine\engine.py
import random
from ..util.paths import content_dir
from .state import GameState, default_state
from .expr import expr_cache_info
from .loader import load_content, ContentIndex
from .campaigns import CampaignDefinition
from .models import Entity
from .save import save_game, load_game, list_saves, latest_save
from .effects_runtime import EffectsEngine
from .resources_runtime import ResourceEngine
from .conditions_runtime import ConditionsEngine
from .modifiers_runtime import ModifiersEngine
from .rulehooks_runtime import RuleHooksRegistry
from .damage_runtime import DamageEngine
from .zones_runtime import ZoneEngine
from .schema_models import EffectDefinition, Operation, Gates, AttackGate
from .scheduler import Scheduler
from .settings import load_settings, Settings # Import settings

ENGINE_VERSION = "0.1.0"

class GameEngine:
    def __init__(self):
        self.content_dir = content_dir()
        self.content: ContentIndex = load_content(self.content_dir)
        self.campaign: CampaignDefinition | None = None
        self.state: GameState = default_state(self.content)
        self.resources = ResourceEngine(self.content, self.state)
        self.conditions = ConditionsEngine(self.content, self.state)
        self.damage = DamageEngine(self.content, self.state)
        self.modifiers = ModifiersEngine(self.content, self.state)
        self.scheduler = Scheduler(self.state, None, None) # Will be rebound
        self.hooks = RuleHooksRegistry(self.content, self.state, None, self.conditions, self.resources)  # temporary None; rebind below
        self.zones = ZoneEngine(self.content, self.state, self.hooks)
        self.settings: Settings = load_settings() # Load settings
        self.rng = random.Random(self._get_rng_seed()) # Use seed from settings
        self.effects = EffectsEngine(self.content, self.state,
                                     resources=self.resources,
                                     conditions=self.conditions,
                                     hooks=self.hooks,
                                     damage=self.damage,
                                     zones=self.zones,
                                     modifiers=self.modifiers,
                                     rng=self.rng,
                                     scheduler=self.scheduler)
        # rebind effects in hooks
        self.hooks.effects = self.effects
        self.scheduler.effects = self.effects
        self.scheduler.hooks = self.hooks
        self.slot_id: str | None = None
        self.should_quit: bool = False

    def _get_rng_seed(self) -> int:
        if self.settings.rng_seed_mode == "random":
            return random.randint(0, 2**32 - 1)
        elif self.settings.rng_seed_mode == "session":
            return int(self.state.clock_seconds) # Use current time as seed for session
        return 1337 # Fixed seed for "fixed" mode

    def start_new_game(self, camp_id: str, entity: Entity, slot_id: str = "slot1") -> list[str]:
        self.campaign = self.content.campaigns[camp_id]
        self.state = GameState(player=entity)
        self.slot_id = slot_id
        save_game(slot_id, self.campaign.id, ENGINE_VERSION, self.state, description=entity.name)
        return [f"New game started in campaign: {self.campaign.name}", f"Character: {entity.name}"]

    def continue_latest(self) -> list[str]:
        meta = latest_save()
        if not meta:
            return ["No saves found."]
        self.slot_id = meta.slot_id
        self.state = load_game(meta.slot_id, GameState)
        self.campaign = self.content.campaigns.get(meta.campaign_id)
        # Re-seed RNG from loaded state
        if meta.rng_seed is not None:
            self.rng.seed(meta.rng_seed)
        return [f"Loaded latest save: {meta.slot_id} ({meta.description})"]

    def load_slot(self, slot_id: str) -> list[str]:
        try:
            self.state = load_game(slot_id, GameState)
            md = next((m for m in list_saves() if m.slot_id == slot_id), None)
            if not md:
                return [f"Error: Save slot '{slot_id}' not found in metadata."]
            self.campaign = self.content.campaigns.get(md.campaign_id)
            self.slot_id = slot_id
            # Re-seed RNG from loaded state
            if md.rng_seed is not None:
                self.rng.seed(md.rng_seed)
            return [f"Loaded save: {slot_id}"]
        except Exception as e:
            return [f"Error loading save slot '{slot_id}': {e}"]

    def save_current(self) -> list[str]:
        if not self.slot_id or not self.campaign:
            return ["No active slot/campaign."]
        save_game(self.slot_id, self.campaign.id, ENGINE_VERSION, self.state, description=self.state.player.name)
        return ["Game saved."]

    def attack(self, actor: Entity, target: Entity) -> list[str]:
        logs: list[str] = []
        weapon = actor.equipped_main_weapon()
        if not weapon:
            logs.append(f"{actor.name} is not wielding a weapon.")
            return logs

        # Create a temporary effect definition for the attack
        attack_effect = EffectDefinition(
            id="attack.runtime.weapon",
            name=f"Attack with {weapon.name}",
            abilityType="Ex",
            gates=Gates(attack=AttackGate(type="melee")),
            operations=[
                Operation(
                    op="damage",
                    amount=weapon.damage,
                    damage_type=weapon.damage_type,
                )
            ]
        )

        # Temporarily add it to content
        self.content.effects[attack_effect.id] = attack_effect

        # Call attach
        logs.extend(self.effects.attach(attack_effect.id, actor, target))

        # Remove from content
        del self.content.effects[attack_effect.id]

        return logs

    def execute(self, cmd: str) -> list[str]:
        c = cmd.lower().strip()
        out: list[str] = []
        if c in ("help","?"):
            out.append("Commands: status, inventory, resources, conditions, list effects, cast <effect_id>, next (advance 1 round), attack <target>, quit")
        elif c == "expr stats":
            out.append(expr_cache_info())
        elif c == "conditions":
            lst = self.conditions.list_for_entity(self.state.player.id)
            if not lst:
                out.append("No active conditions.")
            else:
                for inst in lst:
                    dr = inst.duration_type
                    if inst.remaining_rounds is not None:
                        dr += f" {inst.remaining_rounds} rounds"
                    out.append(f"- {inst.name} [{dr}]")
        elif c == "next":
            # startOfTurn for player
            out += self.hooks.scheduler_event(self.state.player.id, "startOfTurn")
            # tick conditions/resources per-round
            out += self.conditions.tick_round()
            out += self.effects.tick_round()
            self.resources.refresh_cadence("per_round")
            out += self.zones.tick_round()
            # endOfTurn
            out += self.hooks.scheduler_event(self.state.player.id, "endOfTurn")
        elif c.startswith("status"):
            p = self.state.player
            out.append(f"{p.name} | HP {p.hp_current}/{p.hp_max} AC {p.ac_total} (T{p.ac_touch}/FF{p.ac_ff}) | Melee +{p.attack_melee_bonus}")
        elif c.startswith("inventory"):
            names = [it.name for it in self.state.player.inventory]
            out.append("Inventory: " + (", ".join(names) if names else "(empty)"))
        elif c.startswith("list effects"):
            lst = self.effects.list_for_entity(self.state.player.id)
            if not lst:
                out.append("No active effects.")
            else:
                for inst in lst:
                    dr = f"{inst.duration_type}"
                    if inst.remaining_rounds is not None:
                        dr += f" {inst.remaining_rounds} rounds"
                    sup = " [suppressed]" if inst.suppressed else ""
                    out.append(f"- {inst.name}{sup} [{dr}] (id={inst.instance_id})")
        elif c.startswith("cast "):
            _, _, eff_id = cmd.partition(" ")
            eff_id = eff_id.strip()
            if not eff_id:
                out.append("Usage: cast <effect_id> (e.g., cast spell.divine_power)")
            else:
                out += self.effects.attach(eff_id, self.state.player, self.state.player)
        elif c.startswith("attack "):
            _, _, target_name = cmd.partition(" ")
            target_name = target_name.strip()
            if not target_name:
                out.append("Who do you want to attack? (e.g., attack goblin)")
            else:
                target = None
                for npc in self.state.npcs:
                    if npc.name.lower().startswith(target_name.lower()):
                        target = npc
                        break
                
                if not target:
                    out.append(f"Target not found: {target_name}")
                else:
                    out.extend(self.attack(self.state.player, target))
        elif c.startswith("rest"):
            out.append("You rest. (stub)")
        elif c.startswith("travel"):
            out.append("You travel. (stub)")
        elif c.startswith("save"):
            out.append(self.save_current()[0])
        elif c.startswith("resources"):
            info = self.state.resources_summary()
            if not info:
                out.append("No resources.")
            else:
                for k, v in info.items():
                    out.append(f"{k}: {v}")
        elif c.startswith("explain"):
            if not self.state.last_trace:
                out.append("(no trace recorded)")
            else:
                out.extend(self.state.last_trace)
        elif c in ("quit", "exit"):
            self.should_quit = True
            out.append("Exiting...")
        else:
            out.append(f"Unknown command: {cmd}")
        return out
```

```
File: D:\Projects\Game Dev\D&D text RPG\src\dndrpg\engine\expr.py
from __future__ import annotations
from typing import Any, Optional, Dict
from functools import lru_cache
import threading
import math # Moved to top

from py_expression_eval import Parser
from .models import Entity

# Thread-local evaluation context so function implementations can read actor/target dynamically
class _EvalTLS(threading.local):
    def __init__(self):
        self.actor: Optional[Entity] = None
        self.target: Optional[Entity] = None
        self.extra: Dict[str, Any] = {}

_TLS = _EvalTLS()

# Single global parser with function table bound to dynamic, context-aware implementations
_parser = Parser()

def _get_actor() -> Optional[Entity]:
    return _TLS.actor
def _get_target() -> Optional[Entity]:
    return _TLS.target
def _get_extra() -> Dict[str, Any]:
    return _TLS.extra

# Allowed math helpers
_parser.functions["min"] = min
_parser.functions["max"] = max
_parser.functions["floor"] = math.floor
_parser.functions["ceil"] = math.ceil

# D&D functions (look up actor/target each call from thread-local)
def _ability_name(name: Any) -> str:
    s = str(name).lower()
    aliases = {"strength": "str", "dexterity": "dex", "constitution": "con",
               "intelligence": "int", "wisdom": "wis", "charisma": "cha"}
    return aliases.get(s, s)

def _ability_mod(name: Any, who: str = "actor") -> int:
    ent = _get_actor() if who == "actor" else _get_target()
    if not isinstance(ent, Entity):
        return 0
    ab = _ability_name(name)
    return ent.abilities.get(ab).mod()

def _level(who: str = "actor") -> int:
    ent = _get_actor() if who == "actor" else _get_target()
    if not isinstance(ent, Entity):
        return 0
    return int(getattr(ent, "level", 0) or 0)

def _class_level(cls_name: Any, who: str = "actor") -> int:
    ent = _get_actor() if who == "actor" else _get_target()
    if not isinstance(ent, Entity):
        return 0
    return int(ent.classes.get(str(cls_name).lower(), 0))

def _caster_level(key: Any | None = None, who: str = "actor") -> int:
    ent = _get_actor() if who == "actor" else _get_target()
    if not isinstance(ent, Entity):
        return 0
    if key is None:
        return max(ent.caster_levels.values()) if ent.caster_levels else int(getattr(ent, "level", 0) or 0)
    return int(ent.caster_levels.get(str(key).lower(), 0))

def _initiator_level(who: str = "actor") -> int:
    ent = _get_actor() if who == "actor" else _get_target()
    if not isinstance(ent, Entity):
        return 0
    # Optional override in extra
    il_override = _get_extra().get("initiator_level_override")
    if isinstance(il_override, int):
        return il_override
    if ent.classes:
        adepts = {"crusader", "warblade", "swordsage"}
        adept_levels = sum(v for k, v in ent.classes.items() if k in adepts)
        non_adept_levels = sum(v for k, v in ent.classes.items() if k not in adepts)
        return int(adept_levels + (non_adept_levels // 2))
    return int(getattr(ent, "level", 0) or 0)

def _hd(who: str = "actor") -> int:
    ent = _get_actor() if who == "actor" else _get_target()
    if not isinstance(ent, Entity):
        return 0
    return int(getattr(ent, "hd", None) or getattr(ent, "level", 0) or 0)

# Register dynamic functions
_parser.functions["ability_mod"] = _ability_mod
_parser.functions["level"] = _level
_parser.functions["class_level"] = _class_level
_parser.functions["caster_level"] = _caster_level
_parser.functions["initiator_level"] = _initiator_level
_parser.functions["hd"] = _hd

# LRU-compiled AST cache
@lru_cache(maxsize=8192)
def _compile_expr(expr: str):
    # Parse once; compiled expression captures function names (dispatched to _parser.functions)
    return _parser.parse(expr)

def eval_expr(expr: str | int | float,
              actor: Optional[Entity] = None,
              target: Optional[Entity] = None,
              extra: Optional[Dict[str, Any]] = None) -> int | float:
    """
    Evaluate an expression string (or numeric literal) using the compiled cache and thread-local context.
    """
    if isinstance(expr, (int, float)):
        return expr
    # Set thread-local context for dynamic functions
    prev_actor, prev_target, prev_extra = _TLS.actor, _TLS.target, _TLS.extra
    _TLS.actor, _TLS.target, _TLS.extra = actor, target, (extra or {})
    try:
        ast = _compile_expr(expr)
        value = ast.evaluate(_TLS.extra)  # constants/vars available via extra
    finally:
        _TLS.actor, _TLS.target, _TLS.extra = prev_actor, prev_target, prev_extra

    # Normalize ints
    try:
        f = float(value)
        return int(f) if f.is_integer() else f
    except Exception:
        return value

# Backward-compat wrappers (used across engine)
def eval_for_actor(expr: str | int | float, actor: Entity, extra: Optional[Dict[str, Any]] = None):
    return eval_expr(expr, actor=actor, target=None, extra=extra)

def eval_for_actor_vs_target(expr: str | int | float, actor: Entity, target: Entity, extra: Optional[Dict[str, Any]] = None):
    return eval_expr(expr, actor=actor, target=target, extra=extra)

# Optional: quick stats
def expr_cache_info() -> str:
    info = _compile_expr.cache_info()
    return f"expr-cache: hits={info.hits}, misses={info.misses}, size={info.currsize}/{info.maxsize}"
```

```
File: D:\Projects\Game Dev\D&D text RPG\src\dndrpg\engine\gates_runtime.py
from __future__ import annotations
from dataclasses import dataclass
from typing import Optional, Tuple, Literal
import random

from .schema_models import EffectDefinition, Gates, SaveGate, AttackGate
from .models import Entity
from .modifiers_runtime import ModifiersEngine
from .expr import eval_expr
from .dice import d20, d100

@dataclass
class SRResult:
    checked: bool
    passed: bool
    note: str

@dataclass
class SaveResult:
    attempted: bool
    succeeded: bool
    branch: Literal["negates","half","partial","none"] | None
    dc: int
    roll: int
    total: int
    save_type: Literal["Fort","Ref","Will"] | None
    note: str

@dataclass
class AttackResult:
    attempted: bool
    hit: bool
    crit: bool
    crit_mult: int
    ac_used: int
    attack_total: int
    roll: int
    concealment_miss: bool
    note: str

@dataclass
class GateOutcome:
    allowed: bool
    sr: SRResult
    save: SaveResult
    attack: AttackResult
    damage_scale: float      # 1.0 normally; 0.5 on half
    saved_flag: bool         # True when save succeeded (partial branch uses this)
    crit_mult: int           # 1 by default; x2 on crit hits

class GatesEngine:
    def __init__(self, modifiers: ModifiersEngine, rng: random.Random):
        self.modifiers = modifiers
        self.rng = rng

    # -------- SR gate --------
    def sr_gate(self, ed: EffectDefinition, source: Entity, target: Entity) -> SRResult:
        applies = bool(getattr(getattr(ed.gates or Gates(), "sr", None), "applies", False))
        if not applies:
            return SRResult(checked=False, passed=True, note="SR:N/A")
        if ed.abilityType not in ("Spell","Sp"):
            return SRResult(checked=False, passed=True, note="SR:N/A (abilityType not Spell/Sp)")
        sr_value = getattr(target, "spell_resistance", 0) or 0
        if sr_value <= 0:
            return SRResult(checked=False, passed=True, note="SR: target has none")
        # CL = caster_level() from source
        cl = int(eval_expr("caster_level()", actor=source))
        roll = d20(self.rng)
        total = roll + cl
        passed = total >= sr_value or roll == 20
        note = f"SR check d20({roll}) + CL {cl} = {total} vs SR {sr_value} â†’ {'pass' if passed else 'fail'}"
        return SRResult(checked=True, passed=passed, note=note)

    # -------- Save gate --------
    def save_gate(self, ed: EffectDefinition, source: Entity, target: Entity) -> SaveResult:
        sg: Optional[SaveGate] = getattr(ed.gates or Gates(), "save", None)
        if not sg:
            return SaveResult(attempted=False, succeeded=False, branch=None, dc=0, roll=0, total=0, save_type=None, note="Save:N/A")
        # Compute DC
        dc_expr = getattr(sg, "dcExpression", None) or getattr(sg, "dc", None)
        dc_val = int(eval_expr(str(dc_expr), actor=source, target=target)) if isinstance(dc_expr, str) else int(dc_expr or 0)
        # Resolved save total
        stats = self.modifiers.resolved_stats(target)
        stype = sg.type  # "Fort"/"Ref"/"Will"
        save_total = {
            "Fort": stats["save_fort"],
            "Ref":  stats["save_ref"],
            "Will": stats["save_will"],
        }.get(stype, 0)
        roll = d20(self.rng)
        total = roll + save_total
        succeeded = (roll == 20) or (total >= dc_val)  # RAW: 20 auto success on saves? In 3.5, only attack rolls auto 20; saves: 20 always succeeds? No. In 3.5, a natural 1 on a save is always a failure? Actually RAW: Saving throws: a natural 1 on a saving throw is always a failure; a natural 20 is always a success. We'll adopt that.
        if roll == 1:
            succeeded = False
        branch = sg.effect or "negates"
        note = f"{stype} save d20({roll}) + {save_total} = {total} vs DC {dc_val} â†’ {'success' if succeeded else 'fail'} ({branch})"
        return SaveResult(attempted=True, succeeded=succeeded, branch=branch, dc=dc_val, roll=roll, total=total, save_type=stype, note=note)

    # -------- Attack gate --------
    def _concealment_pct(self, source: Entity, target: Entity) -> int:
        # Very simple: if target has invisible condition â†’ 50%; can expand with lighting later
        # Conditions are on state; ModifiersEngine canâ€™t see tags list directly. We read targetâ€™s active conditions via modifiers.state.
        for inst in self.modifiers.state.active_conditions.get(target.id, []):
            # tags are stored on instance
            if "invisible" in (inst.tags or []):
                return 50
        return 0

    def attack_gate(self, ed: EffectDefinition, source: Entity, target: Entity, ag: AttackGate | None) -> AttackResult:
        if not ag or ag.mode == "none":
            return AttackResult(attempted=False, hit=True, crit=False, crit_mult=1, ac_used=0, attack_total=0, roll=0, concealment_miss=False, note="Attack:N/A")

        # Resolve attacker bonuses and target ACs
        sstats = self.modifiers.resolved_stats(source)
        tstats = self.modifiers.resolved_stats(target)
        # Choose AC type
        ac_type = ag.ac_type or "normal"
        ac_val = {
            "normal": tstats["ac_total"],
            "touch":  tstats["ac_touch"],
            "flat-footed": tstats["ac_ff"],
        }.get(ac_type, tstats["ac_total"])
        # Choose attack bonus by mode
        if ag.mode in ("melee","melee_touch"):
            atk_bonus = sstats["attack_melee_bonus"]
            default_crit_mult = 2
        elif ag.mode in ("ranged","ranged_touch","ray"):
            atk_bonus = sstats["attack_ranged_bonus"]
            default_crit_mult = 2
        else:
            atk_bonus = sstats["attack_melee_bonus"]
            default_crit_mult = 2

        # Attack roll
        roll = d20(self.rng)
        total = roll + atk_bonus

        # Auto miss/hit policy: natural 1 misses, natural 20 hits (threat)
        if roll == 1:
            return AttackResult(True, False, False, default_crit_mult, ac_val, total, roll, False, f"Attack d20({roll}) + {atk_bonus} vs AC {ac_val} â†’ auto miss")

        # Concealment
        conceal_pct = self._concealment_pct(source, target)
        if conceal_pct > 0:
            miss_roll = d100(self.rng)
            if miss_roll <= conceal_pct:
                return AttackResult(True, False, False, default_crit_mult, ac_val, total, roll, True, f"Attack d20({roll}) + {atk_bonus} vs AC {ac_val} â†’ concealment {conceal_pct}% miss (roll {miss_roll})")

        # Hit check
        hit = (total >= ac_val) or (roll == 20)
        if not hit:
            return AttackResult(True, False, False, default_crit_mult, ac_val, total, roll, False, f"Attack d20({roll}) + {atk_bonus} vs AC {ac_val} â†’ miss")

        thr = ag.threat_range or 20
        cmult = ag.crit_mult or 2 # Default to 2 if not specified in AttackGate

        # Threat if roll >= thr
        if roll >= thr:
            # Confirm
            confirm_roll = d20(self.rng)
            confirm_total = confirm_roll + atk_bonus
            if confirm_total >= ac_val or confirm_roll == 20:
                
                return AttackResult(True, True, True, cmult, ac_val, total, roll, False,
                                    f"Attack {roll}+{atk_bonus} vs AC {ac_val} â†’ hit; crit confirm {confirm_roll}+{atk_bonus} â†’ critical x{cmult}")
        return AttackResult(True, True, False, cmult, ac_val, total, roll, False, f"Attack {roll}+{atk_bonus} vs AC {ac_val} â†’ hit")

    # -------- Top-level evaluator --------
    def evaluate(self, ed: EffectDefinition, source: Entity, target: Entity) -> Tuple[GateOutcome, list[str]]:
        logs: list[str] = []
        sr = self.sr_gate(ed, source, target)
        logs.append(sr.note)
        if not sr.passed:
            return GateOutcome(False, sr, SaveResult(False, False, None, 0, 0, 0, None, ""), AttackResult(False, False, False, 1, 0, 0, 0, False, ""), 1.0, False, 1), logs

        sv = self.save_gate(ed, source, target)
        if sv.attempted:
            logs.append(sv.note)

        # Apply save branch policy
        damage_scale = 1.0
        saved_flag = False
        allowed_after_save = True
        if sv.attempted:
            if sv.branch == "negates":
                allowed_after_save = not sv.succeeded
            elif sv.branch == "half":
                damage_scale = 0.5 if sv.succeeded else 1.0
                saved_flag = sv.succeeded
            elif sv.branch == "partial":
                # Author content should model partial via inline save ops; pass a flag
                saved_flag = sv.succeeded
                allowed_after_save = True
            elif sv.branch == "none":
                allowed_after_save = True

        if not allowed_after_save:
            return GateOutcome(False, sr, sv, AttackResult(False, False, False, 1, 0, 0, 0, False, ""), damage_scale, saved_flag, 1), logs

        ag = getattr(ed.gates or Gates(), "attack", None)
        atk = self.attack_gate(ed, source, target, ag)
        if atk.attempted:
            logs.append(atk.note)
        if atk.attempted and not atk.hit:
            return GateOutcome(False, sr, sv, atk, damage_scale, saved_flag, 1), logs

        crit_mult = atk.crit_mult if atk.crit else 1
        return GateOutcome(True, sr, sv, atk, damage_scale, saved_flag, crit_mult), logs
```

```
File: D:\Projects\Game Dev\D&D text RPG\src\dndrpg\engine\loader.py
from __future__ import annotations
from dataclasses import dataclass
from pathlib import Path
from typing import Dict, Iterable, Tuple, Annotated, Union
import json
import yaml
from pydantic import TypeAdapter, Field as PField
from .models import Item, Weapon, Armor, Shield
from .campaigns import CampaignDefinition, StartingKit
from .schema_models import EffectDefinition, ResourceDefinition, ConditionDefinition, DeityDefinition

ItemUnion = Annotated[Union[Weapon, Armor, Shield, Item], PField(discriminator="type")]
ItemAdapter = TypeAdapter(ItemUnion)
CampaignAdapter = TypeAdapter(CampaignDefinition)
KitAdapter = TypeAdapter(StartingKit)
EffectAdapter = TypeAdapter(EffectDefinition)
ResourceAdapter = TypeAdapter(ResourceDefinition)
ConditionAdapter = TypeAdapter(ConditionDefinition)

def _load_file(path: Path) -> dict:
    text = path.read_text(encoding="utf-8")
    if path.suffix.lower() in [".yaml", ".yml"]:
        return yaml.safe_load(text) or {}
    return json.loads(text)

def _iter_files(root: Path, exts: Tuple[str,...]=(".json",".yaml",".yml")) -> Iterable[Path]:
    if not root.exists():
        return []
    for p in root.rglob("*"):
        if p.is_file() and p.suffix.lower() in exts:
            yield p

@dataclass
class ContentIndex:
    items_by_id: Dict[str, Item]
    weapons: Dict[str, Weapon]
    armors: Dict[str, Armor]
    shields: Dict[str, Shield]
    campaigns: Dict[str, CampaignDefinition]
    kits: Dict[str, StartingKit]
    effects: Dict[str, EffectDefinition]
    resources: Dict[str, ResourceDefinition]
    conditions: Dict[str, ConditionDefinition]
    deities: Dict[str, DeityDefinition] # NEW

    def get_item(self, iid: str) -> Item:
        return self.items_by_id[iid]

    def clone_item(self, iid: str) -> Item:
        return self.items_by_id[iid].model_copy(deep=True)

    def get_effect(self, eid: str) -> EffectDefinition:
        return self.effects[eid]

    def get_resource(self, rid: str) -> ResourceDefinition:
        return self.resources[rid]
    def get_condition(self, cid: str) -> ConditionDefinition: return self.conditions[cid]

def load_content(base_dir: Path) -> ContentIndex:
    items_by_id: Dict[str, Item] = {}
    weapons: Dict[str, Weapon] = {}
    armors: Dict[str, Armor] = {}
    shields: Dict[str, Shield] = {}

    items_dir = base_dir / "items"
    for fp in _iter_files(items_dir):
        data = _load_file(fp)
        item = ItemAdapter.validate_python(data)
        if item.id in items_by_id:
            raise RuntimeError(f"Duplicate item id {item.id} in {fp}")
        items_by_id[item.id] = item
        if isinstance(item, Weapon):
            weapons[item.id] = item
        elif isinstance(item, Armor):
            armors[item.id] = item
        elif isinstance(item, Shield):
            shields[item.id] = item

    campaigns: Dict[str, CampaignDefinition] = {}
    for fp in _iter_files(base_dir / "campaigns"):
        data = _load_file(fp)
        camp = CampaignAdapter.validate_python(data)
        if camp.id in campaigns:
            raise RuntimeError(f"Duplicate campaign id {camp.id} in {fp}")
        campaigns[camp.id] = camp

    kits: Dict[str, StartingKit] = {}
    for fp in _iter_files(base_dir / "kits"):
        data = _load_file(fp)
        kit = KitAdapter.validate_python(data)
        if kit.id in kits:
            raise RuntimeError(f"Duplicate kit id {kit.id} in {fp}")
        kits[kit.id] = kit

    # Load effects
    effects: Dict[str, EffectDefinition] = {}
    effects_dir = base_dir / "effects"
    for fp in _iter_files(effects_dir):
        data = _load_file(fp)
        eff = EffectAdapter.validate_python(data)
        if eff.id in effects:
            raise RuntimeError(f"Duplicate effect id {eff.id} in {fp}")
        effects[eff.id] = eff

    # Resources
    resources: Dict[str, ResourceDefinition] = {}
    for fp in _iter_files(base_dir / "resources"):
        data = _load_file(fp)
        res = ResourceAdapter.validate_python(data)
        if res.id in resources:
            raise RuntimeError(f"Duplicate resource id {res.id} in {fp}")
        resources[res.id] = res

    conditions: Dict[str, ConditionDefinition] = {}
    for fp in _iter_files(base_dir / "conditions"):
        data = _load_file(fp)
        cond = ConditionAdapter.validate_python(data)
        if cond.id in conditions:
            raise RuntimeError(f"Duplicate condition id {cond.id} in {fp}")
        conditions[cond.id] = cond

    deities: Dict[str, DeityDefinition] = {}
    DeityAdapter = TypeAdapter(DeityDefinition) # Define adapter here
    for fp in _iter_files(base_dir / "deities"):
        data = _load_file(fp)
        deity = DeityAdapter.validate_python(data)
        if deity.id in deities:
            raise RuntimeError(f"Duplicate deity id {deity.id} in {fp}")
        deities[deity.id] = deity

    return ContentIndex(
        items_by_id=items_by_id, weapons=weapons, armors=armors, shields=shields,
        campaigns=campaigns, kits=kits, effects=effects, resources=resources,
        conditions=conditions, deities=deities
    )
```

```
File: D:\Projects\Game Dev\D&D text RPG\src\dndrpg\engine\mode.py

```

```
File: D:\Projects\Game Dev\D&D text RPG\src\dndrpg\engine\models.py
from __future__ import annotations
from typing import Optional, Literal, List, Dict, Set, Union
from enum import Enum
from pydantic import BaseModel, Field, computed_field
from typing_extensions import Annotated

IDStr = Annotated[str, Field(pattern=r"^[a-z0-9_.:-]+$")]

class Size(str, Enum):
    FINE = "Fine"
    DIMINUTIVE = "Diminutive"
    TINY = "Tiny"
    SMALL = "Small"
    MEDIUM = "Medium"
    LARGE = "Large"
    HUGE = "Huge"
    GARGANTUAN = "Gargantuan"
    COLOSSAL = "Colossal"

SIZE_TO_MOD = {
    Size.FINE:+8, Size.DIMINUTIVE:+4, Size.TINY:+2, Size.SMALL:+1, Size.MEDIUM:0,
    Size.LARGE:-1, Size.HUGE:-2, Size.GARGANTUAN:-4, Size.COLOSSAL:-8,
}

class WeaponCategory(str, Enum):
    SIMPLE="simple"
    MARTIAL="martial"
    EXOTIC="exotic"
class WeaponKind(str, Enum):
    MELEE="melee"
    RANGED="ranged"
    THROWN="thrown"
class Handedness(str, Enum):
    LIGHT="light"
    ONE_HANDED="one-handed"
    TWO_HANDED="two-handed"
DamageType = Literal["bludgeoning","piercing","slashing"]

DamageKind = Literal[
    "physical.bludgeoning","physical.piercing","physical.slashing",
    "fire","cold","acid","electricity","sonic","force",
    "negative","positive","nonlethal","bleed","typeless"
]

class DREntry(BaseModel):
    value: int = 0
    bypass_magic: bool = False
    bypass_materials: Set[Literal["adamantine","silver","cold-iron"]] = Field(default_factory=set)
    bypass_alignments: Set[Literal["good","evil","law","chaos"]] = Field(default_factory=set)
    bypass_weapon_types: Set[Literal["slashing","piercing","bludgeoning"]] = Field(default_factory=set)

class Item(BaseModel):
    id: IDStr
    name: str
    type: Literal["item"] = "item"
    weight_lb: float = 0.0
    cost_gp: float = 0.0
    tags: Set[str] = Field(default_factory=set)

class Weapon(Item):
    type: Literal["weapon"] = "weapon"
    category: WeaponCategory = WeaponCategory.SIMPLE
    kind: WeaponKind = WeaponKind.MELEE
    handed: Handedness = Handedness.ONE_HANDED
    damage_dice_m: str = "1d6"
    crit_range: int = 20
    crit_mult: int = 2
    damage_types: List[DamageType] = Field(default_factory=list)
    range_increment_ft: Optional[int] = None
    enhancement_bonus: int = 0
    counts_as_material: Set[str] = Field(default_factory=set)
    counts_as_alignment: Set[str] = Field(default_factory=set)

    @computed_field
    @property
    def counts_as_magic(self) -> bool:
        return self.enhancement_bonus > 0 or ("magic" in self.tags)

class Armor(Item):
    type: Literal["armor"] = "armor"
    armor_type: Literal["light","medium","heavy"] = "light"
    armor_bonus: int = 0
    max_dex_bonus: Optional[int] = None
    armor_check_penalty: int = 0
    arcane_spell_failure_pct: int = 0
    enhancement_bonus: int = 0
    speed30_in_armor: Optional[int] = None
    speed20_in_armor: Optional[int] = None

    @computed_field
    @property
    def effective_armor_bonus(self) -> int:
        return self.armor_bonus + self.enhancement_bonus

class Shield(Item):
    type: Literal["shield"] = "shield"
    shield_bonus: int = 0
    armor_check_penalty: int = 0
    arcane_spell_failure_pct: int = 0
    enhancement_bonus: int = 0
    is_tower: bool = False

    @computed_field
    @property
    def effective_shield_bonus(self) -> int:
        return self.shield_bonus + self.enhancement_bonus

ItemType = Annotated[Union[Weapon, Armor, Shield, Item], Field(discriminator='type')]

class AbilityScore(BaseModel):
    base: int = 10
    temp: int = 0
    damage: int = 0
    drain: int = 0
    def score(self) -> int: return max(0, self.base + self.temp - self.damage - self.drain)
    def mod(self) -> int: return (self.score() - 10) // 2

class Abilities(BaseModel):
    str_: AbilityScore = Field(default_factory=AbilityScore)
    dex: AbilityScore = Field(default_factory=AbilityScore)
    con: AbilityScore = Field(default_factory=AbilityScore)
    int_: AbilityScore = Field(default_factory=AbilityScore)
    wis: AbilityScore = Field(default_factory=AbilityScore)
    cha: AbilityScore = Field(default_factory=AbilityScore)
    def get(self, name: str) -> AbilityScore:
        key = "str_" if name == "str" else ("int_" if name == "int" else name)
        return getattr(self, key)

class Entity(BaseModel):
    id: str
    name: str
    level: int = 1
    size: Size = Size.MEDIUM
    abilities: Abilities = Field(default_factory=Abilities)
    hp_max: int = 8
    hp_current: int = 8
    nonlethal_damage: int = 0
    base_attack_bonus: int = 0
    bab_misc: int = 0
    base_fort: int = 0
    base_ref: int = 0
    base_will: int = 0
    save_misc_fort: int = 0
    save_misc_ref: int = 0
    save_misc_will: int = 0
    natural_armor: int = 0
    deflection_bonus: int = 0
    dodge_bonus: int = 0
    ac_misc: int = 0
    init_misc: int = 0
    speed_land: int = 30
    inventory: List[ItemType] = Field(default_factory=list)
    equipment: Dict[str, str] = Field(default_factory=dict)  # "armor","shield","main_hand","off_hand","ranged"
    classes: Dict[str, int] = Field(default_factory=dict)         # e.g., {"cleric": 1}
    caster_levels: Dict[str, int] = Field(default_factory=dict)    # e.g., {"cleric": 1}
    hd: Optional[int] = None  # total HD; if None, expressions use level
    skills: Dict[str, int] = Field(default_factory=dict)   # skill->ranks
    feats: Set[str] = Field(default_factory=set)
    languages: List[str] = Field(default_factory=list)
    domains: List[str] = Field(default_factory=list)
    spells_known: List[str] = Field(default_factory=list)
    spells_prepared: Dict[int, List[str]] = Field(default_factory=dict)  # level -> ids
    # Spell Resistance for SR gate
    spell_resistance: int = 0
    # Defenses
    immunities: Set[DamageKind] = Field(default_factory=set)
    energy_resist: Dict[DamageKind, int] = Field(default_factory=dict)      # e.g., {"fire": 10}
    vulnerabilities: Dict[DamageKind, float] = Field(default_factory=dict)  # e.g., {"fire": 1.5}
    dr: List[DREntry] = Field(default_factory=list)

    def get_equipped(self, slot: str) -> Optional[Item]:
        iid = self.equipment.get(slot)
        if not iid:
            return None
        for it in self.inventory:
            if it.id == iid:
                return it
        return None

    def equipped_armor(self) -> Optional[Armor]:
        it = self.get_equipped("armor")
        return it if isinstance(it, Armor) else None

    def equipped_shield(self) -> Optional[Shield]:
        it = self.get_equipped("shield")
        return it if isinstance(it, Shield) else None

    def equipped_main_weapon(self) -> Optional[Weapon]:
        it = self.get_equipped("main_hand")
        return it if isinstance(it, Weapon) else None

    def equipped_ranged_weapon(self) -> Optional[Weapon]:
        it = self.get_equipped("ranged")
        return it if isinstance(it, Weapon) else None

    @computed_field
    @property
    def initiative_bonus(self) -> int:
        return self.abilities.dex.mod() + self.init_misc

    @computed_field
    @property
    def save_fort(self) -> int:
        return self.base_fort + self.abilities.con.mod() + self.save_misc_fort

    @computed_field
    @property
    def save_ref(self) -> int:
        return self.base_ref + self.abilities.dex.mod() + self.save_misc_ref

    @computed_field
    @property
    def save_will(self) -> int:
        return self.base_will + self.abilities.wis.mod() + self.save_misc_will

    def _armor_dex_cap(self) -> int:
        armor = self.equipped_armor()
        if armor and armor.max_dex_bonus is not None:
            return armor.max_dex_bonus
        return 99

    def _armor_bonus(self) -> int:
        armor = self.equipped_armor()
        return armor.effective_armor_bonus if armor else 0

    def _shield_bonus(self) -> int:
        shield = self.equipped_shield()
        return shield.effective_shield_bonus if shield else 0

    def _size_mod(self) -> int:
        return SIZE_TO_MOD.get(self.size, 0)

    @computed_field
    @property
    def ac_total(self) -> int:
        dex = min(self.abilities.dex.mod(), self._armor_dex_cap())
        return (
            10 + self._armor_bonus() + self._shield_bonus() + dex + self._size_mod()
            + self.natural_armor + self.deflection_bonus + self.dodge_bonus + self.ac_misc
        )

    @computed_field
    @property
    def ac_touch(self) -> int:
        dex = min(self.abilities.dex.mod(), self._armor_dex_cap())
        return 10 + dex + self._size_mod() + self.deflection_bonus + self.dodge_bonus + self.ac_misc

    @computed_field
    @property
    def ac_ff(self) -> int:
        return 10 + self._armor_bonus() + self._shield_bonus() + self._size_mod() + self.natural_armor + self.deflection_bonus + self.ac_misc

    def _weapon_attack_enhancement(self, w: Optional[Weapon]) -> int:
        return w.enhancement_bonus if w else 0

    @computed_field
    @property
    def attack_melee_bonus(self) -> int:
        w = self.equipped_main_weapon()
        enh = self._weapon_attack_enhancement(w)
        return self.base_attack_bonus + self.bab_misc + self.abilities.str_.mod() + self._size_mod() + enh

    @computed_field
    @property
    def attack_ranged_bonus(self) -> int:
        w = self.equipped_ranged_weapon()
        enh = self._weapon_attack_enhancement(w)
        return self.base_attack_bonus + self.bab_misc + self.abilities.dex.mod() + self._size_mod() + enh
```

```
File: D:\Projects\Game Dev\D&D text RPG\src\dndrpg\engine\modifiers_runtime.py
from __future__ import annotations
from dataclasses import dataclass
from typing import Dict, List, Optional, Any, TYPE_CHECKING
from .schema_models import Modifier
from .loader import ContentIndex
from .models import Entity
from .expr import eval_expr
if TYPE_CHECKING:
    from .state import GameState

# Typed bonus stacking policy
TYPED_NO_STACK_HIGHEST = {
    "enhancement","morale","luck","insight","competence","sacred","profane",
    "resistance","deflection","size","natural_armor","natural_armor_enhancement",
    "circumstance","alchemical"
}
TYPED_STACK = {"dodge"}  # only dodge stacks by itself

@dataclass
class EvaluatedMod:
    operator: str
    value: float
    bonusType: Optional[str]
    sourceKey: Optional[str]
    # provenance (debug/explain)
    source_kind: str  # "effect" or "condition"
    source_id: str
    source_name: str

class ModifiersEngine:
    """
    Collects and applies modifiers with 3.5e stacking rules and operator ordering.
    This engine does not mutate Entity; it computes effective values on demand.
    """

    def __init__(self, content: ContentIndex, state: "GameState"):
        self.content = content
        self.state = state

    # -------- helper: entity lookup --------
    def _entity_by_id(self, ent_id: str) -> Optional[Entity]:
        # For now only player; extend when you track NPCs by id
        if ent_id == self.state.player.id:
            return self.state.player
        return None

    # -------- collect modifiers for an entity --------
    def collect_for_entity(self, entity_id: str) -> Dict[str, List[EvaluatedMod]]:
        out: Dict[str, List[EvaluatedMod]] = {}
        # Effects
        for inst in self.state.active_effects.get(entity_id, []):
            if getattr(inst, "suppressed", False):
                continue
            ed = self.content.effects.get(inst.definition_id)
            if not ed: 
                continue
            src = self._entity_by_id(inst.source_entity_id) or self._entity_by_id(entity_id)  # fallback
            tgt = self._entity_by_id(entity_id)
            for m in (ed.modifiers or []):
                em = self._eval_modifier(m, actor=src, target=tgt, source_kind="effect", source_id=ed.id, source_name=ed.name)
                if em:
                    out.setdefault(m.targetPath, []).append(em)
        # Conditions
        for inst in self.state.active_conditions.get(entity_id, []):
            cd = self.content.conditions.get(inst.definition_id)
            if not cd:
                continue
            src = self._entity_by_id(inst.source_entity_id) or self._entity_by_id(entity_id)
            tgt = self._entity_by_id(entity_id)
            for m in (cd.modifiers or []):
                em = self._eval_modifier(m, actor=src, target=tgt, source_kind="condition", source_id=cd.id, source_name=cd.name)
                if em:
                    out.setdefault(m.targetPath, []).append(em)
        return out

    def _eval_modifier(self, m: Modifier, *, actor: Optional[Entity], target: Optional[Entity], source_kind: str, source_id: str, source_name: str) -> Optional[EvaluatedMod]:
        # value can be numeric or expr (string/dict -> expr string)
        val_raw = m.value
        try:
            if isinstance(val_raw, (int, float)):
                val = float(val_raw)
            elif isinstance(val_raw, str):
                v = eval_expr(val_raw, actor=actor, target=target)
                val = float(v) if isinstance(v, (int, float)) else 0.0
            elif isinstance(val_raw, dict) and "expr" in val_raw:
                v = eval_expr(str(val_raw["expr"]), actor=actor, target=target)
                val = float(v) if isinstance(v, (int, float)) else 0.0
            else:
                # allow dict or other shapes in future; default 0
                val = 0.0
        except Exception:
            val = 0.0
        return EvaluatedMod(
            operator=m.operator,
            value=val,
            bonusType=m.bonusType,
            sourceKey=m.sourceKey,
            source_kind=source_kind,
            source_id=source_id,
            source_name=source_name
        )

    # -------- apply stacking and operator ordering --------
    def apply_to_value(self, base: float, mods: List[EvaluatedMod]) -> float:
        if not mods:
            return base

        # 1) set/replace
        current = base
        for em in mods:
            if em.operator in ("set", "replace"):
                current = em.value

        # 2) add/sub with stacking by bonusType
        # group by bonusType
        by_type: Dict[str, List[EvaluatedMod]] = {}
        untyped: List[EvaluatedMod] = []
        for em in mods:
            if em.operator not in ("add", "subtract"):
                continue
            if em.bonusType:
                by_type.setdefault(em.bonusType, []).append(em)
            else:
                untyped.append(em)

        # typed: sum only highest per type (except dodge stacks)
        typed_total = 0.0
        for btype, lst in by_type.items():
            if btype in TYPED_STACK:
                # sum all adds/subs
                typed_total += sum((em.value if em.operator == "add" else -em.value) for em in lst)
            else:
                # take highest magnitude in absolute add (subtract treated as negative)
                vals = [(em.value if em.operator == "add" else -em.value) for em in lst]
                typed_total += max(vals) if vals else 0.0

        # untyped: stack, but same sourceKey does not stack (take highest per sourceKey)
        by_source: Dict[Optional[str], List[EvaluatedMod]] = {}
        for em in untyped:
            by_source.setdefault(em.sourceKey, []).append(em)
        untyped_total = 0.0
        for skey, lst in by_source.items():
            # choose sum of all when different sourceKey (already grouped), within a key choose highest delta
            vals = [(em.value if em.operator == "add" else -em.value) for em in lst]
            if skey is None:
                untyped_total += sum(vals)
            else:
                # same source: take highest delta
                untyped_total += max(vals) if vals else 0.0

        current += typed_total + untyped_total

        # 3) multiply/divide (apply multiplicatively; collect a single factor)
        factor = 1.0
        for em in mods:
            if em.operator == "multiply":
                factor *= em.value
            elif em.operator == "divide":
                if em.value != 0:
                    factor *= (1.0 / em.value)
        current *= factor

        # 4) min/max
        min_bound: Optional[float] = None
        max_bound: Optional[float] = None
        for em in mods:
            if em.operator == "min":
                min_bound = em.value if min_bound is None else max(min_bound, em.value)
            elif em.operator == "max":
                max_bound = em.value if max_bound is None else min(max_bound, em.value)
        if min_bound is not None:
            current = max(current, min_bound)
        if max_bound is not None:
            current = min(current, max_bound)

        # 5) cap/clamp (treat both as a simple upper cap for now)
        for em in mods:
            if em.operator in ("cap", "clamp"):
                current = min(current, em.value)

        return current

    # -------- resolved stats view --------
    def resolved_ability_scores(self, entity: Entity) -> Dict[str, int]:
        # base scores
        base_scores = {
            "str": entity.abilities.str_.score(),
            "dex": entity.abilities.dex.score(),
            "con": entity.abilities.con.score(),
            "int": entity.abilities.int_.score(),
            "wis": entity.abilities.wis.score(),
            "cha": entity.abilities.cha.score(),
        }
        all_mods = self.collect_for_entity(entity.id)
        eff: Dict[str, int] = {}
        for ab in ("str","dex","con","int","wis","cha"):
            path_prefix = f"abilities.{ab}"
            # Take any modifiers targeting abilities.ab.* and fold them into a delta to the score
            # We allow two modes: authors can target abilities.ab (directly) or abilities.ab.enhancement/etc.
            # Collect mods for any path that starts with the prefix
            relevant: List[EvaluatedMod] = []
            for path, mods in all_mods.items():
                if path == path_prefix or path.startswith(path_prefix + "."):
                    relevant += mods
            eff_val = int(round(self.apply_to_value(float(base_scores[ab]), relevant)))
            # clamp to >= 0
            eff[ab] = max(0, eff_val)
        return eff

    def resolved_stats(self, entity: Entity) -> Dict[str, Any]:
        """
        Compute effective stats for display/use:
        - ability mods
        - AC total/touch/flat-footed (base + path modifiers)
        - Saves
        - Melee/Ranged attack bonuses
        - Speed (land)
        """
        all_mods = self.collect_for_entity(entity.id)
        eff_abilities = self.resolved_ability_scores(entity)
        mod = {k: (v - 10) // 2 for k, v in eff_abilities.items()}

        # Base armor/shield and Dex cap from armor
        armor = entity.equipped_armor()
        shield = entity.equipped_shield()
        armor_bonus = armor.effective_armor_bonus if armor else 0
        shield_bonus = shield.effective_shield_bonus if shield else 0
        dex_cap = armor.max_dex_bonus if (armor and armor.max_dex_bonus is not None) else 99
        size_mod = (0 if entity.size.value == "Medium" else 0)  # you already have SIZE_TO_MOD; but avoid import cycle

        # Pull size mod via entity method (safer)
        try:
            size_mod = entity._size_mod()
        except Exception:
            size_mod = 0

        # Natural armor, deflection, dodge via modifiers (we also allow â€œac.*â€ mods)
        natural = 0.0
        deflection = 0.0
        dodge = 0.0
        misc_ac = 0.0

        # Apply ac.component modifiers into a temp current 0 base (then add to total)
        def apply_ac_component(path_suffix: str) -> float:
            mods = all_mods.get(f"ac.{path_suffix}", [])
            return self.apply_to_value(0.0, mods)

        natural += apply_ac_component("natural")
        deflection += apply_ac_component("deflection")
        dodge += apply_ac_component("dodge")
        misc_ac += apply_ac_component("misc")

        # AC totals before â€œac.totalâ€ modifiers
        dex_used = min(mod["dex"], dex_cap)
        ac_base_total = 10 + armor_bonus + shield_bonus + dex_used + size_mod + natural + deflection + dodge + misc_ac

        # Now apply ac.total modifiers to the total
        ac_total = self.apply_to_value(float(ac_base_total), all_mods.get("ac.total", []))
        # Touch AC: ignore armor, shield, natural
        ac_touch_base = 10 + dex_used + size_mod + deflection + dodge + misc_ac
        ac_touch = self.apply_to_value(float(ac_touch_base), all_mods.get("ac.touch", []))
        # Flat-footed: no Dex, no dodge
        ac_ff_base = 10 + armor_bonus + shield_bonus + size_mod + natural + deflection + misc_ac
        ac_ff = self.apply_to_value(float(ac_ff_base), all_mods.get("ac.flat_footed", []))

        # Saves base
        base_fort = entity.base_fort + mod["con"]
        base_ref = entity.base_ref + mod["dex"]
        base_will = entity.base_will + mod["wis"]
        save_fort = int(round(self.apply_to_value(float(base_fort), all_mods.get("save.fort", []))))
        save_ref = int(round(self.apply_to_value(float(base_ref), all_mods.get("save.ref", []))))
        save_will = int(round(self.apply_to_value(float(base_will), all_mods.get("save.will", []))))

        # Effective BAB (max with modifier if any)
        eff_bab = entity.base_attack_bonus
        if "attack.bab.effective" in all_mods:
            eff_bab = int(round(self.apply_to_value(float(eff_bab), all_mods["attack.bab.effective"])))

        # Attacks
        melee_base = eff_bab + mod["str"] + size_mod + (entity.equipped_main_weapon().enhancement_bonus if entity.equipped_main_weapon() else 0)
        ranged_base = eff_bab + mod["dex"] + size_mod + (entity.equipped_ranged_weapon().enhancement_bonus if entity.equipped_ranged_weapon() else 0)
        attack_melee = int(round(self.apply_to_value(float(melee_base), all_mods.get("attack.melee.bonus", []))))
        attack_ranged = int(round(self.apply_to_value(float(ranged_base), all_mods.get("attack.ranged.bonus", []))))

        # Speed (land)
        speed_base = entity.speed_land
        speed_land = int(round(self.apply_to_value(float(speed_base), all_mods.get("speed.land", []))))

        return {
            "abilities": eff_abilities,
            "mods": mod,
            "ac_total": int(round(ac_total)),
            "ac_touch": int(round(ac_touch)),
            "ac_ff": int(round(ac_ff)),
            "save_fort": save_fort,
            "save_ref": save_ref,
            "save_will": save_will,
            "attack_melee_bonus": attack_melee,
            "attack_ranged_bonus": attack_ranged,
            "speed_land": speed_land,
        }

    def apply_with_trace(self, base: float, mods: List[EvaluatedMod]) -> tuple[float, list[str]]:
        lines: list[str] = []
        current = base
        # set/replace
        for em in mods:
            if em.operator in ("set","replace"):
                lines.append(f'  set â†’ {em.value} from {em.source_name} [{em.source_kind}]')
                current = em.value
        # add/sub
        by_type: Dict[str, List[EvaluatedMod]] = {}
        untyped: List[EvaluatedMod] = []
        for em in mods:
            if em.operator not in ("add","subtract"): 
                continue
            if em.bonusType: 
                by_type.setdefault(em.bonusType, []).append(em)
            else: 
                untyped.append(em)
        # typed
        add_total = 0.0
        for btype, lst in by_type.items():
            if btype in TYPED_STACK:
                delta = sum((em.value if em.operator=='add' else -em.value) for em in lst)
                add_total += delta
                for em in lst:
                    lines.append(f'  {btype} {"+" if em.operator=="add" else ""}{em.value} from {em.source_name} [stack]')
            else:
                vals = [(em.value if em.operator=='add' else -em.value, em) for em in lst]
                if not vals: 
                    continue
                best_val, best_em = max(vals, key=lambda t: t[0])
                add_total += best_val
                # show all contenders; mark chosen
                for v, em in vals:
                    tag = " (chosen)" if v == best_val else ""
                    lines.append(f'  {btype} {"+" if em.operator=="add" else ""}{em.value} from {em.source_name}{tag}')
        # untyped (same-sourceKey no-stack)
        by_source: Dict[Optional[str], List[EvaluatedMod]] = {}
        for em in untyped:
            by_source.setdefault(em.sourceKey, []).append(em)
        for skey, lst in by_source.items():
            if skey is None:
                s = sum((em.value if em.operator=='add' else -em.value) for em in lst)
                add_total += s
                for em in lst:
                    lines.append(f'  untyped {"+" if em.operator=="add" else ""}{em.value} from {em.source_name}')
            else:
                vals = [(em.value if em.operator=='add' else -em.value, em) for em in lst]
                best_val, best_em = max(vals, key=lambda t: t[0])
                add_total += best_val
                for v, em in vals:
                    tag = " (chosen same-source)" if v == best_val else " (same-source dropped)"
                    lines.append(f'  untyped {"+" if em.operator=="add" else ""}{em.value} from {em.source_name}{tag}')
        current += add_total

        # multiply/divide
        factor = 1.0
        for em in mods:
            if em.operator == "multiply": 
                factor *= em.value
            elif em.operator == "divide" and em.value != 0: 
                factor *= (1.0/em.value)
        if factor != 1.0:
            lines.append(f"  Ã— {factor}")
        current *= factor

        # min/max
        minb = None
        maxb = None
        for em in mods:
            if em.operator == "min": 
                minb = em.value if minb is None else max(minb, em.value)
            elif em.operator == "max": 
                maxb = em.value if maxb is None else min(maxb, em.value)
        if minb is not None: 
            lines.append(f"  min {minb}")
        if maxb is not None: 
            lines.append(f"  max {maxb}")
        if minb is not None: 
            current = max(current, minb)
        if maxb is not None: 
            current = min(current, maxb)

        # cap/clamp
        for em in mods:
            if em.operator in ("cap","clamp"):
                lines.append(f"  cap {em.value}")
                current = min(current, em.value)
        return current, lines

    def explain_paths(self, entity: Entity, paths: list[str]) -> list[str]:
        lines: list[str] = []
        all_mods = self.collect_for_entity(entity.id)
        for path in paths:
            mods = all_mods.get(path, [])
            if not mods:
                continue
            base = 0.0
            if path == "ac.natural":
                base = entity.natural_armor
            # other bases 0 for additive components
            final, plines = self.apply_with_trace(base, mods)
            lines.append(f"{path}: base {base} â†’ {int(round(final))}")
            lines.extend(plines)
        return lines

    def diff_stats(self, before: dict, after: dict) -> list[str]:
        # show diffs for abilities, ac_total, saves, attacks, speed
        interesting = [
            ("STR", "abilities['str']"),
            ("DEX","abilities['dex']"),
            ("CON","abilities['con']"),
            ("INT","abilities['int']"),
            ("WIS","abilities['wis']"),
            ("CHA","abilities['cha']"),
            ("AC", "ac_total"),
            ("Touch", "ac_touch"),
            ("FF", "ac_ff"),
            ("Fort","save_fort"),
            ("Ref","save_ref"),
            ("Will","save_will"),
            ("Melee","+attack_melee_bonus"),
            ("Ranged","+attack_ranged_bonus"),
            ("Speed","speed_land"),
        ]
        lines = ["[Stacking] Resolved stat changes:"]
        
        def get_value(data, key_str):
            if "abilities" in key_str:
                ability = key_str.split("'")[1]
                return data["abilities"][ability]
            else:
                return data[key_str.strip('+')]

        for label, key in interesting:
            val_b = get_value(before, key)
            val_a = get_value(after, key)
            if val_a != val_b:
                if isinstance(val_a, (int, float)) and isinstance(val_b, (int, float)):
                    diff = val_a - val_b
                    sign = "+" if diff > 0 else ""
                    lines.append(f'  {label}: {val_b} â†’ {val_a} ({sign}{diff})')
                else:
                    lines.append(f'  {label}: {val_b} â†’ {val_a}')

        if len(lines) == 1:
            lines.append("  (no changes)")
        return lines
```

```
File: D:\Projects\Game Dev\D&D text RPG\src\dndrpg\engine\prereq.py
from __future__ import annotations
from typing import Any, Dict, Optional
from dndrpg.engine.expr import eval_expr
from dndrpg.engine.models import Entity

class BuildView:
    """
    Read-only view used by prereq evaluator. Provides minimal API while building.
    """
    def __init__(self, entity: Optional[Entity], picks: dict):
        self.entity = entity
        self.picks = picks  # {"abilities": {...}, "skills": {...}, "feats": set([...]), "class": "cleric", "race": "human", ...}

    # functions used in prereq exprs
    def has_feat(self, feat_id: str) -> bool:
        feats = self.picks.get("feats", set())
        if isinstance(feats, set):
            return feat_id in feats
        return feat_id in (feats or [])

    def skill_ranks(self, name: str) -> int:
        return int(self.picks.get("skills", {}).get(name.lower(), 0))

    def bab(self) -> int:
        if self.entity:
            return self.entity.base_attack_bonus
        return int(self.picks.get("bab", 0))

    def save(self, which: str) -> int:
        if self.entity:
            return {
                "fort": self.entity.base_fort + self.entity.abilities.con.mod(),
                "ref":  self.entity.base_ref + self.entity.abilities.dex.mod(),
                "will": self.entity.base_will + self.entity.abilities.wis.mod(),
            }[which.lower()]
        # while building, use tentative
        tentative = self.picks.get("saves", {})
        return int(tentative.get(which.lower(), 0))

    def race(self) -> str:
        return str(self.picks.get("race", ""))

    def clazz(self) -> str:
        return str(self.picks.get("class", ""))

    def alignment(self) -> str:
        return str(self.picks.get("alignment", ""))

    def deity(self) -> str:
        return str(self.picks.get("deity", ""))

    def has_domain(self, name: str) -> bool:
        return name.lower() in [d.lower() for d in (self.picks.get("domains", []) or [])]

def eval_prereq(expr: str, view: BuildView) -> tuple[bool, str]:
    extra: Dict[str, Any] = {
        "has_feat": view.has_feat,
        "skill_ranks": view.skill_ranks,
        "bab": view.bab,
        "save": view.save,
        "race_is": lambda r: view.race().lower() == str(r).lower(),
        "class_is": lambda c: view.clazz().lower() == str(c).lower(),
        "alignment_is": lambda a: view.alignment().lower() == str(a).lower(),
        "deity_is": lambda d: view.deity().lower() == str(d).lower(),
        "has_domain": view.has_domain,
        "abil": view.picks.get("abilities", {}),
        "skills": view.picks.get("skills", {}),
    }
    # expr may include ability_mod('str'), class_level('cleric'), etc. via eval_expr functions
    try:
        val = eval_expr(expr, extra=extra)
        if bool(val):
            return True, ""
        else:
            return False, f"Prerequisite '{expr}' not met."
    except Exception as e:
        return False, f"Error evaluating prerequisite '{expr}': {e}"
```

```
File: D:\Projects\Game Dev\D&D text RPG\src\dndrpg\engine\resources_runtime.py
from __future__ import annotations
from typing import Optional, Literal, TYPE_CHECKING
from uuid import uuid4
from pydantic import BaseModel, Field
from dndrpg.engine.schema_models import ResourceDefinition, ResourceRefresh, AbsorptionSpec
from dndrpg.engine.expr import eval_for_actor
from dndrpg.engine.models import Entity
from dndrpg.engine.loader import ContentIndex

if TYPE_CHECKING:
    from .state import GameState

OwnerScope = Literal["entity", "effect-instance", "item", "zone"]

class ResourceState(BaseModel):
    state_id: str = Field(default_factory=lambda: uuid4().hex)
    definition_id: Optional[str] = None
    name: Optional[str] = None

    owner_scope: OwnerScope = "entity"
    owner_entity_id: Optional[str] = None
    owner_effect_instance_id: Optional[str] = None
    owner_item_id: Optional[str] = None
    owner_zone_id: Optional[str] = None

    current: int = 0
    max_computed: int = 0

    capacity_computeAt: Literal["attach","refresh","query"] = "attach"
    freezeOnAttach: bool = False

    refresh: Optional[ResourceRefresh] = None
    absorption: Optional[AbsorptionSpec] = None
    visibility: Optional[Literal["public","private","hidden"]] = "public"

    suppressed: bool = False
    # bookkeeping (simple round-based for now; extend later)
    last_refreshed_round: int = 0

class ResourceEngine:
    def __init__(self, content: ContentIndex, state: "GameState"):
        self.content = content
        self.state = state

    def _owner_key(self, scope: OwnerScope, entity_id: Optional[str], effect_id: Optional[str], item_id: Optional[str], zone_id: Optional[str]) -> str:
        if scope == "entity" and entity_id:
            return f"entity:{entity_id}"
        if scope == "effect-instance" and effect_id:
            return f"effect:{effect_id}"
        if scope == "item" and item_id:
            return f"item:{item_id}"
        if scope == "zone" and zone_id:
            return f"zone:{zone_id}"
        # default bucket (shouldn't happen)
        return "misc"

    def _attach_state(self, rs: ResourceState):
        key = self._owner_key(rs.owner_scope, rs.owner_entity_id, rs.owner_effect_instance_id, rs.owner_item_id, rs.owner_zone_id)
        self.state.resources.setdefault(key, []).append(rs)

    def _find_owner_entity(self, entity_id: Optional[str]) -> Optional[Entity]:
        if not entity_id:
            return None
        # For now only player; later track NPCs
        if self.state.player.id == entity_id:
            return self.state.player
        return None

    def _compute_capacity(self, rd: ResourceDefinition, owner: Entity) -> int:
        cap_expr = rd.capacity.formula
        val = eval_for_actor(str(cap_expr), owner)
        try:
            cap = int(val)
        except Exception:
            cap = 0
        if rd.capacity.cap is not None:
            cap = min(cap, rd.capacity.cap)
        return max(0, cap)

    def create_from_definition(
        self,
        def_id: str,
        *,
        owner_scope: Optional[OwnerScope] = None,
        owner_entity_id: Optional[str] = None,
        owner_effect_instance_id: Optional[str] = None,
        initial_current: Optional[int | str] = None
    ) -> tuple[ResourceState, list[str]]:
        logs: list[str] = []
        if def_id not in self.content.resources:
            return (None, [f"[Res] Unknown resource id: {def_id}"])  # type: ignore

        rd = self.content.resources[def_id]
        scope = owner_scope or rd.scope
        owner_ent = self._find_owner_entity(owner_entity_id)
        rs = ResourceState(
            definition_id=rd.id,
            name=rd.name or rd.id,
            owner_scope=scope,
            owner_entity_id=owner_entity_id if scope == "entity" else None,
            owner_effect_instance_id=owner_effect_instance_id if scope == "effect-instance" else None,
            capacity_computeAt=rd.capacity.computeAt,
            freezeOnAttach=bool(rd.freezeOnAttach),
            refresh=rd.refresh,
            absorption=rd.absorption,
            visibility=rd.visibility
        )
        # capacity
        if owner_ent:
            rs.max_computed = self._compute_capacity(rd, owner_ent)
        else:
            rs.max_computed = 0

        # set current
        if isinstance(initial_current, (int,)):
            rs.current = int(initial_current)
        elif isinstance(initial_current, str) and owner_ent:
            val = eval_for_actor(initial_current, owner_ent)
            rs.current = max(0, int(val)) if isinstance(val, (int,float)) else 0
        elif rd.initial_current is not None and owner_ent:
            if isinstance(rd.initial_current, (int, float)):
                rs.current = max(0, int(rd.initial_current))
            else:
                val = eval_for_actor(str(rd.initial_current), owner_ent)
                rs.current = max(0, int(val)) if isinstance(val, (int,float)) else 0
        else:
            rs.current = rs.max_computed

        self._attach_state(rs)
        logs.append(f"[Res] Created {rs.name} ({rs.current}/{rs.max_computed}) for {owner_ent.name if owner_ent else '?'}")
        return (rs, logs)

    def grant_temp_hp(self, owner_entity_id: str, amount_expr: str | int, *, effect_instance_id: Optional[str] = None) -> list[str]:
        # Use content res if present; else construct an ad-hoc effect-instance pool
        logs: list[str] = []
        rid = "res.temp_hp"
        owner = self._find_owner_entity(owner_entity_id)
        if not owner:
            return ["[Res] temp hp: unknown owner"]

        if rid in self.content.resources:
            rs, logs2 = self.create_from_definition(
                rid,
                owner_scope="effect-instance",
                owner_entity_id=owner_entity_id,
                owner_effect_instance_id=effect_instance_id,
                initial_current=amount_expr
            )
            logs += logs2
            return logs

        # Fallback ad-hoc resource state
        amount = int(eval_for_actor(str(amount_expr), owner)) if not isinstance(amount_expr, int) else int(amount_expr)
        rs = ResourceState(
            definition_id=None,
            name="Temporary Hit Points",
            owner_scope="effect-instance",
            owner_entity_id=owner_entity_id,
            owner_effect_instance_id=effect_instance_id,
            current=max(0, amount),
            max_computed=max(0, amount),
            capacity_computeAt="attach",
            freezeOnAttach=True,
            visibility="public"
        )
        self._attach_state(rs)
        logs.append(f"[Res] Granted Temp HP {rs.current} to {owner.name}")
        return logs

    def spend(self, owner_entity_id: str, resource_id: str, amount: int) -> bool:
        # simplistic: spend from first matching pool for this owner
        key = f"entity:{owner_entity_id}"
        # try entity scope first
        for rs in self.state.resources.get(key, []):
            if rs.definition_id == resource_id:
                if rs.current >= amount:
                    rs.current -= amount
                    return True
        # then any effect-instance owned by this entity
        for k, lst in self.state.resources.items():
            if not k.startswith("effect:"):
                continue
            for rs in lst:
                if rs.owner_entity_id == owner_entity_id and rs.definition_id == resource_id and rs.current >= amount:
                    rs.current -= amount
                    return True
        return False

    def restore(self, owner_entity_id: str, resource_id: str, amount: Optional[int] = None, to_max: bool = False):
        # Restore to entity-scoped first
        key = f"entity:{owner_entity_id}"
        for rs in self.state.resources.get(key, []):
            if rs.definition_id == resource_id:
                if to_max:
                    rs.current = rs.max_computed
                elif amount is not None:
                    rs.current = min(rs.max_computed, rs.current + int(amount))
                return True
        return False

    def set_current(self, owner_entity_id: str, resource_id: str, current: int) -> bool:
        key = f"entity:{owner_entity_id}"
        for rs in self.state.resources.get(key, []):
            if rs.definition_id == resource_id:
                rs.current = max(0, min(rs.max_computed, int(current)))
                return True
        return False

    def recompute_capacity(self, owner_entity_id: str, resource_id: str) -> bool:
        owner = self._find_owner_entity(owner_entity_id)
        if not owner:
            return False
        key = f"entity:{owner_entity_id}"
        for rs in self.state.resources.get(key, []):
            if rs.definition_id == resource_id:
                if rs.freezeOnAttach:
                    return False
                rd = self.content.resources.get(resource_id)
                if not rd:
                    return False
                rs.max_computed = self._compute_capacity(rd, owner)
                rs.current = min(rs.current, rs.max_computed)
                return True
        return False

    def refresh_cadence(self, cadence: str):
        # Simple: handle per_round for now (hook your scheduler later)
        if cadence != "per_round":
            return
        for key, lst in self.state.resources.items():
            for rs in lst:
                if not rs.refresh or rs.refresh.cadence != "per_round":
                    continue
                beh = rs.refresh.behavior
                if beh == "reset_to_max":
                    rs.current = rs.max_computed
                elif beh == "increment_by":
                    if rs.refresh.increment_by is not None and rs.owner_entity_id:
                        owner = self._find_owner_entity(rs.owner_entity_id)
                        inc = 0
                        if owner:
                            val = eval_for_actor(str(rs.refresh.increment_by), owner)
                            inc = int(val) if isinstance(val, (int,float)) else 0
                        rs.current = min(rs.max_computed, rs.current + max(0, inc))
                # no_change â†’ nothing
```

```
File: D:\Projects\Game Dev\D&D text RPG\src\dndrpg\engine\rulehooks_runtime.py
from __future__ import annotations
from dataclasses import dataclass
from typing import Any, Dict, List, Optional, Tuple, Literal
from uuid import uuid4
from pydantic import BaseModel, Field

from dndrpg.engine.schema_models import RuleHook, EffectDefinition, ConditionDefinition, HookAction, ZoneDefinition
from dndrpg.engine.models import Entity
from dndrpg.engine.loader import ContentIndex
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from dndrpg.engine.effects_runtime import EffectsEngine
    from dndrpg.engine.conditions_runtime import ConditionsEngine
    from dndrpg.engine.resources_runtime import ResourceEngine
    from .state import GameState

# ------------------------------
# Runtime types
# ------------------------------

@dataclass
class HookDecision:
    # For incoming.effect: allow or block (default allow); suppress would suppress if engine supported
    allow: bool = True
    suppress: bool = False
    notes: List[str] = None

    def __post_init__(self):
        if self.notes is None:
            self.notes = []

class RegisteredHook(BaseModel):
    hook_id: str = Field(default_factory=lambda: uuid4().hex)
    scope: str
    match: Dict[str, Any] = Field(default_factory=dict)
    actions: List[HookAction] = Field(default_factory=list)
    priority: int = 0

    source_kind: Literal["effect","condition","zone"] = "effect"

class RuleHooksRegistry:
    """
    Maintains registered hooks per target entity and scope, and provides dispatch APIs.
    This registry is used by EffectsEngine and ConditionsEngine to register hooks at attach/apply time,
    and to remove them on detach/expire.
    """

    def __init__(self, content: ContentIndex, state: "GameState",
                 effects: EffectsEngine, conditions: ConditionsEngine, resources: ResourceEngine):
        self.content = content
        self.state = state
        self.effects = effects
        self.conditions = conditions
        self.resources = resources

        # scope -> target_entity_id -> list of RegisteredHook (sorted by priority)
        self._by_scope: Dict[str, Dict[str, List[RegisteredHook]]] = {}

        # reverse map for cleanup: parent_instance_id -> list of (scope, target_id, hook_id)
        self._parent_index: Dict[str, List[Tuple[str, str, str]]] = {}

    # -------- Register / unregister --------

    def register_for_effect(self, ed: EffectDefinition, parent_instance_id: str, target_entity_id: str):
        for h in ed.ruleHooks or []:
            self._register(h, source_kind="effect", source_id=ed.id, source_name=ed.name,
                           parent_instance_id=parent_instance_id, target_entity_id=target_entity_id)

    def register_for_condition(self, cd: ConditionDefinition, parent_instance_id: str, target_entity_id: str):
        for h in cd.ruleHooks or []:
            self._register(h, source_kind="condition", source_id=cd.id, source_name=cd.name,
                           parent_instance_id=parent_instance_id, target_entity_id=target_entity_id)

    def register_for_zone(self, zd: ZoneDefinition, zone_instance_id: str, target_entity_id: str):
        for h in zd.hooks or []:
            self._register(h, source_kind="zone", source_id=zd.id, source_name=zd.name,
                           parent_instance_id=zone_instance_id, target_entity_id=target_entity_id)

    def _register(self, hook_def: RuleHook, *, source_kind: str, source_id: str, source_name: str,
                  parent_instance_id: str, target_entity_id: str):
        rh = RegisteredHook(
            scope=hook_def.scope,
            match=hook_def.match or {},
            actions=list(hook_def.action or []),
            priority=int(hook_def.priority or 0),
            source_kind=source_kind,
            source_id=source_id,
            source_name=source_name,
            parent_instance_id=parent_instance_id,
            target_entity_id=target_entity_id
        )
        bucket = self._by_scope.setdefault(rh.scope, {}).setdefault(target_entity_id, [])
        bucket.append(rh)
        bucket.sort(key=lambda r: r.priority)  # low number first
        self._parent_index.setdefault(parent_instance_id, []).append((rh.scope, target_entity_id, rh.hook_id))

    def unregister_by_parent(self, parent_instance_id: str):
        entries = self._parent_index.pop(parent_instance_id, [])
        for scope, target_id, hook_id in entries:
            lst = self._by_scope.get(scope, {}).get(target_id, [])
            self._by_scope[scope][target_id] = [h for h in lst if h.hook_id != hook_id]

    # -------- Dispatch helpers --------

    def _entity_by_id(self, ent_id: str) -> Optional[Entity]:
        if self.state.player.id == ent_id:
            return self.state.player
        return None

    def _match(self, rh: RegisteredHook, context: Dict[str, Any]) -> bool:
        # Very simple deep match: all keys in rh.match must exist in context and equal
        # For 'event' we allow exact or startswith for 'startOfTurn(...)'
        for k, v in (rh.match or {}).items():
            if k == "event":
                ev = context.get("event")
                if isinstance(v, str):
                    if not isinstance(ev, str) or (ev != v and not ev.startswith(v)):
                        return False
                else:
                    return False
            else:
                if context.get(k) != v:
                    return False
        return True

    def _exec_action(self, action: HookAction, *, actor: Optional[Entity], target: Optional[Entity], logs: List[str]):
        """
        Execute a subset of actions inline. We delegate Operation union kinds to EffectsEngine's executor (save/condition/resource ops).
        Special HookAction kinds we handle here: setOutcome (by putting a flag into logs/context), multiply/cap/reflect etc.
        For now, we only use setOutcome for decisions; other transforms are returned by dispatchers that need them.
        """
        # These operation types we let EffectsEngine handle through a small executor
        op_name = getattr(action, "op", None)
        if op_name in ("save", "condition.apply", "condition.remove",
                       "resource.create", "resource.spend", "resource.restore", "resource.set"):
            # Reuse EffectsEngine executor util (create a thin wrapper method)
            self.effects.execute_operations([action], actor, target, parent_instance_id=None, logs=logs)
            return

        if op_name == "schedule":
            delay = getattr(action, "delay_rounds", None)
            if delay is not None and target:
                # schedule actions (action.actions is a list[Operation])
                self.effects.scheduler.schedule_in_rounds(target.id, int(delay), list(getattr(action, "actions", [])))
                logs.append(f"[Hooks] scheduled {len(getattr(action, 'actions', []))} action(s) in {delay} round(s)")
            return

        # HookAction-specific (modify/reroll/cap/multiply/reflect/redirect/absorbIntoPool/setOutcome)
        if op_name == "setOutcome":
            # setOutcome is handled in the dispatchers (they inspect actions and set decisions)
            # No immediate effect here
            return

        # Other transforms (modify/reroll, multiply/cap/reflect etc.) handled by respective dispatchers (attack/save/damage)
        return

    # -------- Incoming effect decision --------

    def incoming_effect(self, target_entity_id: str, *, effect_def: EffectDefinition, actor_entity_id: Optional[str] = None) -> HookDecision:
        dec = HookDecision()
        hooks = list(self._by_scope.get("incoming.effect", {}).get(target_entity_id, []))
        if not hooks:
            return dec
        actor = self._entity_by_id(actor_entity_id) if actor_entity_id else None
        target = self._entity_by_id(target_entity_id)
        ctx = {
            "abilityType": effect_def.abilityType,
            "source": effect_def.source,
            "event": "incoming.effect"
        }
        logs: List[str] = []
        for rh in hooks:
            if self._is_parent_suppressed(rh):
                continue
            if not self._match(rh, ctx):
                continue
            for act in rh.actions:
                if getattr(act, "op", None) == "setOutcome":
                    kind = getattr(act, "kind", None)
                    if kind == "block":
                        dec.allow = False
                        dec.notes.append(f"Blocked by {rh.source_name}")
                    elif kind == "allow":
                        dec.allow = True
                        dec.notes.append(f"Allowed by {rh.source_name}")
                    elif kind == "suppress":
                        dec.suppress = True
                        dec.notes.append(f"Suppressed by {rh.source_name}")
                else:
                    # Execute operations embedded in hooks if any (e.g., log, resource change)
                    self._exec_action(act, actor=actor, target=target, logs=logs)
        if logs:
            dec.notes.extend(logs)
        return dec

    # -------- Scheduler events --------

    def scheduler_event(self, target_entity_id: str, event: str, *, actor_entity_id: Optional[str] = None) -> List[str]:
        """
        Dispatch scheduler hooks with match.event matching the event string.
        Example events: "startOfTurn", "endOfTurn", "eachRound", "onStart", "eachStep", "onComplete"
        """
        out: List[str] = []
        hooks = list(self._by_scope.get("scheduler", {}).get(target_entity_id, []))
        if not hooks:
            return out
        actor = self._entity_by_id(actor_entity_id) if actor_entity_id else None
        target = self._entity_by_id(target_entity_id)
        ctx = {"event": event}
        for rh in hooks:
            if self._is_parent_suppressed(rh):
                continue
            if not self._match(rh, ctx):
                continue
            for act in rh.actions:
                self._exec_action(act, actor=actor, target=target, logs=out)
        return out

    # -------- Attack / Save / Damage entry points (stubs for now) --------

    def on_attack(self, target_entity_id: str, phase: Literal["pre","post"], attack_context: Dict[str, Any]) -> Dict[str, Any]:
        """
        Placeholder for attack hook processing. Returns a dict of flags or transforms:
          { "setOutcome": "hit/miss", "reroll": { "what":"miss_chance","keep":"success"}, "modify": [ ... ], "cap": X, "multiply": Y, ... }
        For now, we just scan for setOutcome and return it; others can be added later when you implement attack resolution.
        """
        result: Dict[str, Any] = {}
        hooks = list(self._by_scope.get("on.attack", {}).get(target_entity_id, []))
        if not hooks:
            return result
        ctx = {"event": f"on.attack.{phase}"}
        for rh in hooks:
            if self._is_parent_suppressed(rh):
                continue
            if not self._match(rh, ctx):
                continue
            for act in rh.actions:
                if getattr(act, "op", None) == "setOutcome":
                    result["setOutcome"] = getattr(act, "kind", None)
        return result

    def on_save(self, target_entity_id: str, phase: Literal["pre","post"], save_context: Dict[str, Any]) -> Dict[str, Any]:
        result: Dict[str, Any] = {}
        hooks = list(self._by_scope.get("on.save", {}).get(target_entity_id, []))
        if not hooks:
            return result
        ctx = {"event": f"on.save.{phase}"}
        for rh in hooks:
            if self._is_parent_suppressed(rh):
                continue
            if not self._match(rh, ctx):
                continue
            for act in rh.actions:
                if getattr(act, "op", None) == "setOutcome":
                    result["setOutcome"] = getattr(act, "kind", None)
        return result

    def incoming_damage(self, target_entity_id: str, damage_context: Dict[str, Any]) -> Dict[str, Any]:
        """
        Placeholder for damage hook transforms.
        Returns a dict like {"multiply": 0.5, "cap": 10, "absorbIntoPool": {...}, "reflect": 50}
        """
        result: Dict[str, Any] = {}
        hooks = list(self._by_scope.get("incoming.damage", {}).get(target_entity_id, []))
        if not hooks:
            return result
        ctx = {"event": damage_context.get("event","incoming.damage")}
        for rh in hooks:
            if self._is_parent_suppressed(rh):
                continue
            if not self._match(rh, ctx):
                continue
            for act in rh.actions:
                op = getattr(act, "op", None)
                if op == "convertType":
                    result["convert"] = getattr(act, "to")
                elif op == "multiply":
                    result["multiply"] = getattr(act, "factor", 1.0)
                elif op == "cap":
                    result["cap"] = getattr(act, "amount", None)
                elif op == "absorbIntoPool":
                    result["absorbIntoPool"] = {"resource_id": getattr(act, "resource_id", None),
                                                "up_to": getattr(act, "up_to", 0),
                                                "damage_types": getattr(act, "damage_types", None)}
                elif op == "reflect":
                    result["reflect"] = getattr(act, "percent", 100)
        return result
```

```
File: D:\Projects\Game Dev\D&D text RPG\src\dndrpg\engine\save.py
from __future__ import annotations
from dataclasses import dataclass
from pathlib import Path
import json
import time
from typing import List, Optional
from pydantic import BaseModel

SAVE_ROOT = Path.home() / ".dndrpg" / "saves"

@dataclass
class SaveMeta:
    slot_id: str
    campaign_id: str
    engine_version: str
    last_played_ts: float
    description: str
    rng_seed: Optional[int] = None
    mode: Optional[str] = None
    clock_seconds: Optional[float] = None

def _slot_dir(slot_id: str) -> Path:
    return SAVE_ROOT / slot_id

def ensure_save_root() -> None:
    SAVE_ROOT.mkdir(parents=True, exist_ok=True)

def list_saves() -> List[SaveMeta]:
    ensure_save_root()
    metas: List[SaveMeta] = []
    for slot in SAVE_ROOT.iterdir():
        if not slot.is_dir():
            continue
        meta_path = slot / "meta.json"
        if not meta_path.exists():
            continue
        data = json.loads(meta_path.read_text(encoding="utf-8"))
        metas.append(SaveMeta(
            slot_id=slot.name,
            campaign_id=data.get("campaign_id","unknown"),
            engine_version=data.get("engine_version","0.0"),
            last_played_ts=data.get("last_played_ts",0.0),
            description=data.get("description",""),
            rng_seed=data.get("rng_seed"),
            mode=data.get("mode"),
            clock_seconds=data.get("clock_seconds")
        ))
    metas.sort(key=lambda m: m.last_played_ts, reverse=True)
    return metas

def latest_save() -> Optional[SaveMeta]:
    saves = list_saves()
    return saves[0] if saves else None

def save_game(slot_id: str, campaign_id: str, engine_version: str, state: BaseModel, description: str = "") -> None:
    ensure_save_root()
    sd = _slot_dir(slot_id)
    sd.mkdir(parents=True, exist_ok=True)
    (sd / "save.json").write_text(state.model_dump_json(indent=2), encoding="utf-8")
    meta = {
        "campaign_id": campaign_id,
        "engine_version": engine_version,
        "last_played_ts": time.time(),
        "description": description,
        "rng_seed": state.rng_seed if hasattr(state, 'rng_seed') else None,
        "mode": state.mode if hasattr(state, 'mode') else None,
        "clock_seconds": state.clock_seconds if hasattr(state, 'clock_seconds') else None,
    }
    (sd / "meta.json").write_text(json.dumps(meta, indent=2), encoding="utf-8")

def load_game(slot_id: str, model_cls) -> BaseModel:
    sd = _slot_dir(slot_id)
    data = json.loads((sd / "save.json").read_text(encoding="utf-8"))
    return model_cls.model_validate(data)

def delete_save(slot_id: str) -> None:
    sd = _slot_dir(slot_id)
    if not sd.exists():
        return
    for p in sd.iterdir():
        if p.is_file():
            p.unlink()
    sd.rmdir()
```

```
File: D:\Projects\Game Dev\D&D text RPG\src\dndrpg\engine\scheduler.py
from dataclasses import dataclass, field
from typing import List, Optional

@dataclass
class Scheduled:
    when_round: Optional[int] = None
    when_seconds: Optional[int] = None
    target_entity_id: str = ""
    actions: list = field(default_factory=list)  # list of Operation or HookAction

class Scheduler:
    def __init__(self, state, effects, hooks):
        self.state = state
        self.effects = effects
        self.hooks = hooks
        self._queue: List[Scheduled] = []

    def schedule_in_rounds(self, target_entity_id: str, rounds: int, actions: list):
        self._queue.append(Scheduled(when_round=self.state.round_counter + max(1, rounds),
                                     target_entity_id=target_entity_id, actions=actions))

    def _drain_scheduled(self) -> List[str]:
        logs: List[str] = []
        now_round = self.state.round_counter
        due: List[Scheduled] = []
        keep: List[Scheduled] = []
        for s in self._queue:
            if s.when_round is not None and s.when_round <= now_round:
                due.append(s)
            else:
                keep.append(s)
        self._queue = keep
        # Execute due actions
        for s in due:
            for act in s.actions:
                # Delegate to effects.executor if it's an Operation; if HookAction, we can map to Operation union or extend executor to accept it
                # For MVP: only Operation union used here
                self.effects.execute_operations([act], self.state.player, self.state.player, logs=logs)
        return logs

    def advance_rounds(self, n: int = 1) -> List[str]:
        logs: List[str] = []
        for _ in range(max(0, n)):
            self.state.round_counter += 1
            self.state.clock_seconds += 6
            logs += self.hooks.scheduler_event(self.state.player.id, "startOfTurn")
            logs += self._drain_scheduled()
            # ... rest unchanged ...
        return logs
```

```
File: D:\Projects\Game Dev\D&D text RPG\src\dndrpg\engine\schema_models.py
from __future__ import annotations
from typing import Any, Dict, List, Literal, Optional, Union, Tuple
from typing_extensions import Annotated
from pydantic import BaseModel, Field, AliasChoices, model_validator

IDStr = Annotated[str, Field(pattern=r"^[a-z0-9_.:-]+$")]

# Common aliases
Expr = Union[str, int, float]  # expressions or numeric literals

# Enums
AbilityType = Literal["Ex", "Su", "Sp", "Spell"]
SourceType = Literal["feat", "class", "spell", "power", "maneuver", "stance",
                     "soulmeld", "binding", "race", "item", "condition", "zone", "other"]
ActionType = Literal["passive", "free", "swift", "immediate", "reaction", "move", "standard", "full-round", "special"]
SaveType = Literal["Fort", "Ref", "Will"]
AttackMode = Literal["none", "melee", "ranged", "melee_touch", "ranged_touch", "ray", "special"]
RangeType = Literal["personal", "touch", "close", "medium", "long", "fixed-ft", "sight", "special"]
AreaShape = Literal["none", "line", "cone", "burst", "spread", "emanation", "cylinder", "wall", "sphere", "cube", "square"]
DurationType = Literal["instantaneous", "rounds", "minutes", "hours", "days", "permanent", "concentration", "special"]
Cadence = Literal["per_round", "per_encounter", "per_rest", "per_day", "per_week", "special"]
ScopeType = Literal["entity", "effect-instance", "item", "zone"]
ComputeAt = Literal["attach", "refresh", "query"]
Visibility = Literal["public", "private", "hidden"]
GateBranch = Literal["negates", "half", "partial", "none"]

# Canonical condition tags (from 3.5e Conditions section)
ConditionTag = Literal[
    "blinded","blown_away","checked","confused","cowering","dazed","dazzled",
    "dead","deafened","disabled","dying","energy_drained","entangled","exhausted",
    "fascinated","fatigued","flat_footed","frightened","grappling","helpless",
    "incorporeal","invisible","knocked_down","nauseated","panicked","paralyzed",
    "petrified","pinned","prone","shaken","sickened","stable","staggered","stunned",
    "turned","unconscious"
]

# Modifiers
ModifierOperator = Literal[
    "add","subtract","multiply","divide","set","min","max","replace","replaceFormula","cap","clamp","grantTag","removeTag","convertType"
]
BonusType = Literal[
    "enhancement","morale","luck","insight","competence","sacred","profane",
    "resistance","deflection","dodge","size","natural_armor","natural_armor_enhancement",
    "circumstance","alchemical","unnamed"
]

_ALLOWED_PREFIXES = {
    # as requested
    "abilities","ac","save","resist","dr","speed","senses","tags","resources",
    # practical additions so existing and common content doesnâ€™t break
    "attack","bab"
}

_NUMERIC_OPS = {"add","subtract","multiply","divide","set","min","max","cap","clamp","replace"}  # replace used as set/overwrite

class Modifier(BaseModel):
    targetPath: str
    operator: ModifierOperator
    value: Expr | Dict[str, Any] = 0
    bonusType: Optional[BonusType] = None
    sourceKey: Optional[str] = None
    conditions: Optional[Dict[str, Any]] = None
    durationOverride: Optional[Dict[str, Any]] = None
    flags: Optional[Dict[str, Any]] = None

    @model_validator(mode="after")
    def _validate(self):
        errs: list[str] = []

        # 1) Prefix allowlist
        prefix = self.targetPath.split(".", 1)[0]
        if prefix not in _ALLOWED_PREFIXES:
            errs.append(
                f"targetPath prefix '{prefix}' not allowed; allowed: "
                f"{sorted(_ALLOWED_PREFIXES)}"
            )

        # 2) Deprecate replaceFormula
        if self.operator == "replaceFormula":
            errs.append("operator 'replaceFormula' is deprecated; use 'set' or 'replace'")

        # 3) value required for numeric operators
        if self.operator in _NUMERIC_OPS and self.value is None:
            errs.append(f"modifier.value is required for operator '{self.operator}'")

        # 4) Operator+target combos and bonusType requirements
        from dndrpg.engine.targetpaths_registry import resolve_meta

        # TargetPath registry check
        meta = resolve_meta(self.targetPath)
        if not meta:
            errs.append(f"Unknown or unsupported targetPath '{self.targetPath}' (not in TargetPath registry)")
        else:
            # Allowed operators
            if self.operator not in meta.allowed_ops:
                errs.append(f"Operator '{self.operator}' not allowed for {self.targetPath}; allowed: {sorted(meta.allowed_ops)}")
            # Bonus-type policy for additive/subtractive
            if self.operator in {"add","subtract"} and meta.require_bonus_type_for_add:
                if self.bonusType is None:
                    errs.append(f"{self.targetPath}: additive modifiers require bonusType (use 'unnamed' if truly untyped)")
                elif meta.allowed_bonus_types is not None and self.bonusType not in meta.allowed_bonus_types:
                    errs.append(f"{self.targetPath}: bonusType '{self.bonusType}' invalid; allowed: {sorted(meta.allowed_bonus_types)}")
        # 5) convertType belongs in rules/hook actions, not generic modifiers
        if self.operator == "convertType":
            errs.append("operator 'convertType' is not valid as a generic Modifier; use a RuleHook action")

        if errs:
            raise ValueError("; ".join(errs))
        return self

# -----------------------------
# Operation Kinds (stricter)
# -----------------------------

DamageKind = Literal[
    "physical.bludgeoning", "physical.piercing", "physical.slashing",
    "fire", "cold", "acid", "electricity", "sonic", "force",
    "negative", "positive", "nonlethal", "bleed", "typeless"
]

class OpDamage(BaseModel):
    op: Literal["damage"] = "damage"
    amount: Expr
    damage_type: DamageKind = "typeless"
    counts_as_magic: Optional[bool] = None
    counts_as_material: Optional[List[Literal["adamantine", "silver", "cold-iron"]]] = None
    counts_as_alignment: Optional[List[Literal["good", "evil", "law", "chaos"]]] = None
    nonlethal: Optional[bool] = None  # legacy convenience

    @model_validator(mode="after")
    def _validate(self):
        # Require amount present (Expr type ensures this).
        # Legacy: if nonlethal flag is true and damage_type wasn\'t explicitly set, coerce.
        if self.nonlethal and self.damage_type == "typeless":
            object.__setattr__(self, "damage_type", "nonlethal")
        return self

class OpHealHP(BaseModel):
    op: Literal["heal_hp"] = "heal_hp"
    amount: Expr
    nonlethal_only: bool = False

class OpTempHP(BaseModel):
    op: Literal["temp_hp"] = "temp_hp"
    amount: Expr

AbilityName = Literal["str","dex","con","int","wis","cha"]

class OpAbilityDamage(BaseModel):
    op: Literal["ability.damage"] = "ability.damage"
    ability: AbilityName
    amount: Expr

class OpAbilityDrain(BaseModel):
    op: Literal["ability.drain"] = "ability.drain"
    ability: AbilityName
    amount: Expr

class OpConditionApply(BaseModel):
    op: Literal["condition.apply"] = "condition.apply"
    id: str
    duration: Optional["DurationSpec"] = None
    params: Dict[str, Any] = Field(default_factory=dict)
    stacks: Optional[bool] = None

class OpConditionRemove(BaseModel):
    op: Literal["condition.remove"] = "condition.remove"
    id: str

class OpResourceCreate(BaseModel):
    op: Literal["resource.create"] = "resource.create"
    resource_id: str
    owner_scope: Optional[ScopeType] = None
    initial_current: Optional[Expr] = None

class OpResourceSpend(BaseModel):
    op: Literal["resource.spend"] = "resource.spend"
    resource_id: str
    amount: Expr

class OpResourceRestore(BaseModel):
    op: Literal["resource.restore"] = "resource.restore"
    resource_id: str
    amount: Optional[Expr] = None
    to_max: bool = False

    @model_validator(mode="after")
    def _require_amount_or_to_max(self):
        if self.amount is None and not self.to_max:
            raise ValueError("resource.restore requires either amount or to_max=true")
        return self

class OpResourceSet(BaseModel):
    op: Literal["resource.set"] = "resource.set"
    resource_id: str
    current: Expr

class OpZoneCreate(BaseModel):
    op: Literal["zone.create"] = "zone.create"
    zone_id: Optional[str] = None
    name: Optional[str] = None
    shape: Optional["AreaSpec"] = None
    duration: Optional["DurationSpec"] = None
    hooks: Optional[List["RuleHook"]] = None

    @model_validator(mode="after")
    def _require_id_or_inline(self):
        # Either: zone_id, or inline with at least name + shape
        if not self.zone_id:
            if not (self.name and self.shape):
                raise ValueError("zone.create requires zone_id OR inline name+shape")
        return self

class OpZoneDestroy(BaseModel):
    op: Literal["zone.destroy"] = "zone.destroy"
    zone_instance_id: Optional[str] = None
    zone_id: Optional[str] = None

    @model_validator(mode="after")
    def _require_target(self):
        if not self.zone_instance_id and not self.zone_id:
            raise ValueError("zone.destroy requires zone_instance_id or zone_id")
        return self

class OpSave(BaseModel):
    op: Literal["save"] = "save"
    type: "SaveType"
    dc: Expr = Field(validation_alias=AliasChoices("dc", "dcExpression")),
    on_success: List["Operation"] = Field(default_factory=list, validation_alias=AliasChoices("on_success", "onSuccess")),
    on_fail: List["Operation"] = Field(default_factory=list, validation_alias=AliasChoices("on_fail", "onFail")),

    @model_validator(mode="after")
    def _require_branch(self):
        if not self.on_success and not self.on_fail:
            raise ValueError("save requires at least one branch: on_success or on_fail")
        return self

class OpAttachEffect(BaseModel):
    op: Literal["attach"] = "attach"
    effect_id: str
    target: Optional[Literal["self", "target"]] = None

class OpDetachEffect(BaseModel):
    op: Literal["detach"] = "detach"
    effect_id: str
    all_instances: bool = False

class OpMove(BaseModel):
    op: Literal["move"] = "move"
    dx: Optional[int] = None
    dy: Optional[int] = None
    to: Optional[Tuple[int, int]] = None
    forced: bool = False

    @model_validator(mode="after")
    def _require_delta_or_to(self):
        has_delta = (self.dx is not None) or (self.dy is not None)
        has_to = self.to is not None
        if (has_delta and has_to) or (not has_delta and not has_to):
            raise ValueError("move requires either dx/dy OR to, but not both")
        return self

class OpTeleport(BaseModel):
    op: Literal["teleport"] = "teleport"
    to: Tuple[int, int]

class OpTransform(BaseModel):
    op: Literal["transform"] = "transform"
    form_id: Optional[str] = None
    size: Optional[str] = None
    set_stats: Optional[Dict[str, Any]] = None

    @model_validator(mode="after")
    def _require_some_change(self):
        if not (self.form_id or self.size or self.set_stats):
            raise ValueError("transform requires form_id or size or set_stats")
        return self

class OpDispel(BaseModel):
    op: Literal["dispel"] = "dispel"
    effect_id: Optional[str] = None
    max_cl: Optional[Expr] = None

class OpSuppress(BaseModel):
    op: Literal["suppress"] = "suppress"
    target: Literal["effect", "item", "zone"]
    duration: "DurationSpec"

class OpUnsuppress(BaseModel):
    op: Literal["unsuppress"] = "unsuppress"
    target: Literal["effect", "item", "zone"]

class OpSchedule(BaseModel):
    op: Literal["schedule"] = "schedule"
    after: Optional["DurationSpec"] = None
    delay_rounds: Optional[int] = None
    actions: List["Operation"] = Field(default_factory=list)

    @model_validator(mode="after")
    def _require_timing_and_actions(self):
        if not self.actions:
            raise ValueError("schedule requires non-empty actions")
        if self.after is None and self.delay_rounds is None:
            raise ValueError("schedule requires after (DurationSpec) or delay_rounds")
        return self

# Discriminated union stays the same
Operation = Annotated[
    Union[
        OpDamage, OpHealHP, OpTempHP,
        OpAbilityDamage, OpAbilityDrain,
        OpConditionApply, OpConditionRemove,
        OpResourceCreate, OpResourceSpend, OpResourceRestore, OpResourceSet,
        OpZoneCreate, OpZoneDestroy,
        OpSave, OpAttachEffect, OpDetachEffect,
        OpMove, OpTeleport, OpTransform,
        OpDispel, OpSuppress, OpUnsuppress,
        OpSchedule
    ],
    Field(discriminator="op")
]

class ActModify(BaseModel):
    op: Literal["modify"] = "modify"
    targetPath: str
    operator: ModifierOperator  # "add" | "set" | "multiply" | ...
    value: Expr
    bonusType: Optional[BonusType] = None  # optional; mostly for clarity in logs

class ActReroll(BaseModel):
    op: Literal["reroll"] = "reroll"
    what: Literal["attack_roll", "miss_chance", "save", "crit_confirm", "skill_check"]
    keep: Literal["best", "success"] = "best"  # success = keep successful result if either succeeds

class ActCap(BaseModel):
    op: Literal["cap"] = "cap"
    target: Literal["incoming_damage", "outgoing_damage", "attack_roll", "damage_roll"]
    amount: Expr  # maximum allowed

class ActMultiply(BaseModel):
    op: Literal["multiply"] = "multiply"
    target: Literal["incoming_damage", "outgoing_damage", "attack_roll", "damage_roll"]
    factor: Expr  # e.g., 0.5 for resistance-like, 1.5 for vulnerability-like

class ActReflect(BaseModel):
    op: Literal["reflect"] = "reflect"
    what: Literal["damage", "effect"] = "damage"
    percent: int = 100  # 0â€“100
    to: Literal["source", "self"] = "source"  # simple routing

class ActRedirect(BaseModel):
    op: Literal["redirect"] = "redirect"
    what: Literal["damage", "effect"] = "damage"
    to: Literal["source", "self"] = "source"

class ActAbsorbIntoPool(BaseModel):
    op: Literal["absorbIntoPool"] = "absorbIntoPool"
    resource_id: str
    up_to: Expr                       # max amount to absorb
    damage_types: Optional[List[DamageKind]] = None  # if absent, absorb any

class ActSetOutcome(BaseModel):
    op: Literal["setOutcome"] = "setOutcome"
    kind: Literal[
        "block", "allow",          # targeting / incoming.effect / resource hooks
        "negate",                  # incoming.damage -> set to 0
        "hit", "miss",             # on.attack
        "success", "failure",      # on.save / on.crit (confirm)
        "suppress", "unsuppress"   # suppression
    ]
    note: Optional[str] = None

class ActConvertType(BaseModel):
    op: Literal["convertType"] = "convertType"
    to: DamageKind

# HookAction union = hook-specific actions + a subset of Operation union you want to allow in hooks
HookAction = Annotated[
    Union[
        ActModify, ActReroll, ActCap, ActMultiply, ActReflect, ActRedirect, ActAbsorbIntoPool, ActSetOutcome,
        ActConvertType, # NEW
        # Reuse operation types that make sense in hooks:
        OpSave, OpConditionApply, OpConditionRemove,
        OpResourceCreate, OpResourceSpend, OpResourceRestore, OpResourceSet,
        OpSchedule, OpDispel, OpSuppress, OpUnsuppress
    ],
    Field(discriminator="op")
]

# Rule Hooks (generic: match + actions)
HookScope = Literal[
    "targeting",
    "incoming.effect",
    "incoming.condition",
    "incoming.damage",
    "on.save",
    "on.attack",
    "on.damageDealt",
    "on.damageTaken",
    "on.crit",
    "on.maneuverGrant",
    "scheduler",
    "suppression",
    "resource",
    # NEW: zone-specific entry/exit scopes
    "on.enter",
    "on.leave"
]

class RuleHook(BaseModel):
    scope: HookScope
    match: Dict[str, Any] = Field(default_factory=dict)
    action: List[HookAction] = Field(default_factory=list)
    priority: Optional[int] = None
    duration: Optional[Dict[str, Any]] = None

    @model_validator(mode="after")
    def _validate_actions_for_scope(self):
        # Map scopes to allowed op names
        allowed: Dict[str, List[str]] = {
            "targeting": ["setOutcome"],
            "incoming.effect": ["setOutcome", "save", "condition.apply", "condition.remove",
                                "resource.create", "resource.spend", "resource.restore", "resource.set",
                                "schedule", "dispel", "suppress", "unsuppress"],
            "incoming.damage": ["cap", "multiply", "reflect", "redirect", "absorbIntoPool",
                                "setOutcome", "resource.restore", "resource.spend", "schedule"],
            "on.save": ["reroll", "setOutcome", "resource.spend", "resource.restore",
                        "schedule", "condition.apply", "condition.remove"],
            "on.attack": ["modify", "reroll", "setOutcome", "resource.spend", "resource.restore", "schedule"],
            "on.damageDealt": ["cap", "multiply", "reflect", "resource.spend", "resource.restore",
                               "schedule", "condition.apply", "condition.remove"],
            "on.damageTaken": ["cap", "multiply", "reflect", "absorbIntoPool",
                               "resource.spend", "resource.restore", "schedule", "condition.apply", "condition.remove"],
            "on.crit": ["reroll", "setOutcome", "modify", "resource.spend", "resource.restore", "schedule"],
            "on.maneuverGrant": ["setOutcome", "resource.spend", "resource.restore", "schedule"],
            "scheduler": ["save", "condition.apply", "condition.remove", "resource.spend", "resource.restore", "schedule"],
            "suppression": ["setOutcome", "suppress", "unsuppress", "dispel", "schedule"],
            "resource": ["setOutcome", "resource.spend", "resource.restore", "schedule"],
            "on.enter": ["setOutcome", "save", "condition.apply", "condition.remove",
                         "resource.create", "resource.spend", "resource.restore", "resource.set",
                         "schedule", "dispel", "suppress", "unsuppress"],
            "on.leave": ["setOutcome", "condition.apply", "condition.remove",
                         "resource.create", "resource.spend", "resource.restore", "resource.set",
                         "schedule"],
        }
        # Allowed set for this hook
        allow = set(allowed.get(self.scope, []))

        # Helper for setOutcome kind per scope
        kind_allowed: Dict[str, List[str]] = {
            "targeting": ["block", "allow"],
            "incoming.effect": ["block", "allow", "suppress"],
            "incoming.damage": ["negate"],
            "on.save": ["success", "failure"],
            "on.attack": ["hit", "miss"],
            "on.crit": ["success", "failure"],
            "suppression": ["suppress", "unsuppress"],
            "resource": ["block", "allow"],
            "on.enter": ["block", "allow", "suppress"],
            "on.leave": ["block", "allow", "suppress"],
        }

        errs: List[str] = []
        for a in self.action:
            opname = getattr(a, "op", "")
            if opname not in allow:
                errs.append(f"Action '{opname}' not allowed in scope '{self.scope}'")
            # Additional check for setOutcome kinds
            if opname == "setOutcome":
                kinds = set(kind_allowed.get(self.scope, []))
                if kinds and getattr(a, "kind", None) not in kinds:
                    errs.append(f"setOutcome.kind '{getattr(a, 'kind', None)}' invalid for scope '{self.scope}' (allowed: {sorted(kinds)})")
        if errs:
            raise ValueError("; ".join(errs))
        return self


# Duration/Range/Area/Targeting
class DurationSpec(BaseModel):
    type: DurationType
    value: Optional[int] = None
    formula: Optional[str] = None
    end_conditions: Optional[List[str]] = None

class ActivationSpec(BaseModel):
    action: ActionType = "standard"
    provokesAoO: Optional[bool] = None
    costs: Optional[List[str]] = None
    concentration: Optional[bool] = None
    cooldown: Optional[int] = None

class RangeSpec(BaseModel):
    type: RangeType = "personal"
    distance_ft: Optional[int] = None

    @model_validator(mode="after")
    def _validate(self):
        if self.type == "fixed-ft":
            if self.distance_ft is None or self.distance_ft <= 0:
                raise ValueError("range.type 'fixed-ft' requires positive distance_ft")
        return self

class AreaSpec(BaseModel):
    shape: AreaShape = "none"
    size_ft: Optional[int] = None
    length_ft: Optional[int] = None
    width_ft: Optional[int] = None
    radius_ft: Optional[int] = None

    @model_validator(mode="after")
    def _validate(self):
        s = self.shape
        if s in ("none",):
            return self
        if s in ("square", "cube"):
            if not self.size_ft or self.size_ft <= 0:
                raise ValueError(f"area.shape '{s}' requires size_ft > 0")
        elif s in ("burst", "sphere", "emanation"):
            if not self.radius_ft or self.radius_ft <= 0:
                raise ValueError(f"area.shape '{s}' requires radius_ft > 0")
        elif s == "cone":
            if not self.length_ft or self.length_ft <= 0:
                raise ValueError("area.shape 'cone' requires length_ft > 0")
        elif s == "line":
            if not self.length_ft or self.length_ft <= 0:
                raise ValueError("area.shape 'line' requires length_ft > 0")
            # default width to 5 if omitted
            if self.width_ft is None:
                object.__setattr__(self, "width_ft", 5)
        elif s == "cylinder":
            if not self.radius_ft or self.radius_ft <= 0 or not self.length_ft or self.length_ft <= 0:
                raise ValueError("area.shape 'cylinder' requires radius_ft > 0 and length_ft > 0")
        elif s == "wall":
            if not self.length_ft or self.length_ft <= 0:
                raise ValueError("area.shape 'wall' requires length_ft > 0")
            # width_ft optional; default to 5 if omitted
            if self.width_ft is None:
                object.__setattr__(self, "width_ft", 5)
        return self

class TargetFilter(BaseModel):
    self: Optional[bool] = None
    ally: Optional[bool] = None
    enemy: Optional[bool] = None
    creature: Optional[bool] = None
    object: Optional[bool] = None
    type: Optional[List[str]] = None
    subtype: Optional[List[str]] = None
    alignment: Optional[List[str]] = None
    size: Optional[List[str]] = None
    HD_cap: Optional[int] = None
    count_cap: Optional[int] = None
    LoS: Optional[bool] = None
    LoE: Optional[bool] = None

# Gates
class SRGate(BaseModel):
    applies: bool = True

class SaveGate(BaseModel):
    type: SaveType
    dcExpression: str = Field(validation_alias=AliasChoices("dc", "dcExpression")),
    effect: GateBranch = "negates"

class AttackGate(BaseModel):
    mode: AttackMode = "none"
    ac_type: Optional[Literal["normal", "touch", "flat-footed"]] = None
    crit_behavior: Optional[str] = None
    threat_range: Optional[int] = 20
    crit_mult: Optional[int] = 2

    @model_validator(mode="after")
    def _validate(self):
        # existing checks...
        if self.mode in ("melee_touch", "ranged_touch", "ray"):
            if self.ac_type != "touch":
                raise ValueError(f"attackGate.mode '{self.mode}' requires ac_type='touch'")
        if self.ac_type == "flat-footed" and self.mode not in ("melee", "ranged"):
            raise ValueError("ac_type='flat-footed' allowed only with mode melee or ranged")
        
        # New validation for threat_range and crit_mult
        if self.threat_range is not None and not (1 <= int(self.threat_range) <= 20):
            raise ValueError("threat_range must be between 1 and 20")
        if self.crit_mult is not None and int(self.crit_mult) < 2:
            raise ValueError("crit_mult must be >= 2")
        return self

class Gates(BaseModel):
    sr: Optional[SRGate] = None
    save: Optional[SaveGate] = None
    attack: Optional[AttackGate] = None

class StackingPolicy(BaseModel):
    # 1) Named (effect-level) exclusivity within a â€œnamed keyâ€
    # - no_stack_highest: keep the instance with highest magnitude (see magnitudeExpr or fallback)
    # - no_stack_latest: keep the newest instance; older instances suppressed
    # - stack: allow multiple instances to coexist (rare at effect-level)
    named: Optional[Literal["no_stack_highest", "no_stack_latest", "stack"]] = None

    # Which key defines â€œsame named effectâ€
    # - "id" (default) â†’ treat same effect id as same named
    # - "name" â†’ same display name
    # - "group:<key>" â†’ uses entries in familyKeys to build groups (see below)
    # - "tag:<tag>" â†’ engines can precompute a tag membership set
    namedKey: Optional[str] = None

    # How to compare for no_stack_highest
    # - "magnitudeExpr" is an expression evaluated per effect instance (actor context)
    # - If omitted, engine falls back to a heuristic (see runtime notes)
    magnitudeExpr: Optional[str] = None

    # 2) Family/exclusion groups (for â€œnot cumulative with similar effectsâ€ across different effect ids)
    # all effects sharing any of these keys are mutually exclusive
    familyKeys: Optional[List[str]] = None
    familyPolicy: Optional[Literal["exclusive_highest", "exclusive_latest"]] = None

    # 3) Same-source rule (primarily for untyped)
    # - no_stack: ignore additive untyped modifiers with identical sourceKey
    # - stack: allow (default is no_stack to match common â€œsame sourceâ€ clause)
    sameSource: Optional[Literal["no_stack", "stack"]] = None

    # 4) Per-bonus-type override of the global typed-stacking defaults
    # - defaultTyped is applied when a type isnâ€™t explicitly listed
    # - Values: "stack" or "no_stack_highest"
    bonusTypePolicy: Optional[Dict[
        Literal[
            "enhancement","morale","luck","insight","competence","sacred","profane",
            "resistance","deflection","dodge","size","natural_armor","natural_armor_enhancement",
            "circumstance","alchemical","untyped","defaultTyped"
        ],
        Literal["stack","no_stack_highest"]
    ]] = None

    # 5) Tie-breaker (when magnitudes equal or magnitudeExpr missing)
    tieBreaker: Optional[Literal["latest", "highestCL", "highestLevel", "sourcePriority"]] = None

    @model_validator(mode="after")
    def _validate(self):
        errs: list[str] = []
        if self.familyPolicy and not self.familyKeys:
            errs.append("familyPolicy requires non-empty familyKeys")
        if self.named in ("no_stack_highest",) and not (self.magnitudeExpr or self.tieBreaker):
            # Not strictly required, but warn authors toward deterministic behavior
            pass
        if "dodge" in (self.bonusTypePolicy or {}) and self.bonusTypePolicy["dodge"] != "stack":
            errs.append("bonusTypePolicy for 'dodge' must be 'stack' (RAW)")
        # If defaultTyped omitted, engine will use canonical default (no_stack_highest)
        if errs:
            raise ValueError("; ".join(errs))
        return self

# EffectDefinition
class EffectDefinition(BaseModel):
    id: IDStr
    name: str
    source: SourceType = "spell"
    abilityType: AbilityType = "Spell"
    school: Optional[str] = None
    descriptors: List[str] = Field(default_factory=list)
    casterLevel: Optional[Expr] = None
    prerequisites: Optional[str] = None
    stacking: Optional[StackingPolicy] = None
    notes: Optional[str] = None

    activation: Optional[ActivationSpec] = None
    range: Optional[RangeSpec] = None
    targetFilter: Optional[TargetFilter] = None
    area: Optional[AreaSpec] = None

    when: Optional[str] = None   # "on activation" | "continuous" | "on trigger"
    duration: Optional[DurationSpec] = None
    triggers: Optional[List[Dict[str, Any]]] = None
    recurring: Optional[Dict[str, Any]] = None
    ongoing_save: Optional[Dict[str, Any]] = None

    gates: Optional[Gates] = None

    operations: List[Operation] = Field(default_factory=list)
    modifiers: List[Modifier] = Field(default_factory=list)
    ruleHooks: List[RuleHook] = Field(default_factory=list)

    resourceDefinitions: Optional[List[Dict[str, Any]]] = None
    choices: Optional[List[Dict[str, Any]]] = None

    srApplies: Optional[bool] = None
    antimagic_suppression: Optional[List[AbilityType]] = None
    dispellable: Optional[bool] = None

    @model_validator(mode="after")
    def _validate_effect(self):
        errs: list[str] = []

        # 1) Duration rules accurate to RAW
        has_instancey_bits = bool(self.modifiers or self.ruleHooks or self.operations)

        is_passive = (
            (self.activation and self.activation.action == "passive")
            or (self.when is not None and self.when.lower().startswith("continuous"))
        )

        if self.abilityType in ("Spell", "Sp"):
            # All spells/SLAs must declare a duration (even instantaneous)
            if self.duration is None:
                errs.append("Spell/Sp requires duration (use {type:'instantaneous'} if appropriate)")
            else:
                if self.duration.type == "concentration":
                    if not (self.activation and self.activation.concentration):
                        errs.append("duration.type 'concentration' requires activation.concentration=true for Spell/Sp")
        else:
            # Non-spell effects
            if is_passive:
                # Continuous passives may omit duration; recommended to use duration: permanent for clarity.
                pass
            else:
                # Activated or triggered non-spell effects that attach anything should either:
                # - declare duration (including 'instantaneous'), OR
                # - mark when:'continuous'
                if has_instancey_bits and self.duration is None and not self.when:
                    errs.append("Activated/triggered non-spell effect with modifiers/hooks/ops must declare duration "
                                "(including 'instantaneous') or set when:'continuous'")

        # 2) SR consistency: only Spell/Sp can have SR gate applying
        if self.gates and self.gates.sr and self.gates.sr.applies:
            if self.abilityType not in ("Spell", "Sp"):
                errs.append("gates.sr.applies=true is invalid unless abilityType is Spell or Sp")

        if errs:
            raise ValueError("; ".join(errs))
        return self

# ConditionDefinition
class ConditionDefinition(BaseModel):
    id: IDStr
    name: str
    # Only canonical tags allowed; optional but constrained
    tags: List[ConditionTag] = Field(default_factory=list)
    # Higher number = higher precedence (engine will document the ordering policy)
    precedence: Optional[int] = None

    # Optional default duration; used when an effect applies the condition with no explicit duration
    default_duration: Optional["DurationSpec"] = None

    modifiers: List["Modifier"] = Field(default_factory=list)
    ruleHooks: List["RuleHook"] = Field(default_factory=list)
    notes: Optional[str] = None

    @model_validator(mode="after")
    def _validate_default_duration(self):
        dd = self.default_duration
        if dd is None:
            return self
        # Disallow concentration for conditionsâ€™ defaults (itâ€™s a property of effects, not conditions)
        if dd.type == "concentration":
            raise ValueError("Condition default_duration cannot be 'concentration'; model concentration on the applying effect")

        # Instantaneous: no explicit duration value/formula required (and should not be provided)
        if dd.type == "instantaneous":
            if dd.value is not None or dd.formula is not None:
                raise ValueError("default_duration 'instantaneous' must not specify value or formula")
            return self

        # Permanent: no numeric duration
        if dd.type == "permanent":
            if dd.value is not None or dd.formula is not None:
                raise ValueError("default_duration 'permanent' must not specify value or formula")
            return self

        # Timed durations: require either a value (>0) or a formula
        if dd.type in ("rounds", "minutes", "hours", "days"):
            if dd.value is None and dd.formula is None:
                raise ValueError(f"default_duration '{dd.type}' requires value or formula")
            if dd.value is not None and dd.value <= 0:
                raise ValueError(f"default_duration '{dd.type}' value must be > 0 when provided")
            return self

        # 'special' is allowed, but strongly prefer effects to manage special end conditions
        # (No extra checks here; leave to runtime/authoring guidelines)
        return self

# ResourceDefinition
# Absorbable packet types (align with your damage kinds, add aggregate "physical")
AbsorbType = Literal[
    "any",
    "physical",
    "physical.bludgeoning", "physical.piercing", "physical.slashing",
    "acid", "cold", "electricity", "fire", "sonic", "force",
    "negative", "positive", "nonlethal", "bleed", "typeless"
]

class CapacitySpec(BaseModel):
    formula: Expr  # REQUIRED
    cap: Optional[int] = None
    computeAt: Optional[ComputeAt] = "attach"

    @model_validator(mode="after")
    def _validate(self):
        # formula presence implicitly enforced by type; ensure cap non-negative
        if self.cap is not None and self.cap < 0:
            raise ValueError("capacity.cap must be >= 0")
        return self

class ResourceRefresh(BaseModel):
    cadence: Cadence
    behavior: Literal["reset_to_max", "increment_by", "no_change"] = "reset_to_max"
    increment_by: Optional[Expr] = None
    triggers: Optional[List[str]] = None

    @model_validator(mode="after")
    def _validate(self):
        if self.behavior == "increment_by" and self.increment_by is None:
            raise ValueError("refresh.behavior 'increment_by' requires increment_by")
        return self

# Absorption policy for ablative pools
class AbsorptionSpec(BaseModel):
    absorbTypes: List[AbsorbType] = Field(default_factory=list)
    absorbPerHit: Optional[int] = None         # max absorbed per attack/hit
    absorbOrder: Optional[Literal[
        # Engine default is resist -> DR -> pool; use one of these to override:
        "before_resist",               # apply pool before resist/DR
        "after_resist_before_dr",      # after resist, before DR
        "after_dr",                    # after DR (default if overriding)
        "final"                        # last step (after everything else)
    ]] = None

    @model_validator(mode="after")
    def _validate(self):
        if not self.absorbTypes:
            raise ValueError("absorption.absorbTypes must be a non-empty list")
        if self.absorbPerHit is not None and self.absorbPerHit < 0:
            raise ValueError("absorption.absorbPerHit must be >= 0")
        # Normalize: if 'any' present, it must be the only entry
        if "any" in self.absorbTypes and len(self.absorbTypes) > 1:
            raise ValueError("absorption.absorbTypes: 'any' must not be combined with other types")
        # If 'physical' present, don't combine with specific physical.*
        if "physical" in self.absorbTypes:
            if any(t.startswith("physical.") for t in self.absorbTypes if t != "physical"):
                raise ValueError("absorption.absorbTypes: 'physical' must not be combined with specific physical.* kinds")
        return self

class ResourceDefinition(BaseModel):
    id: IDStr
    name: Optional[str] = None
    scope: ScopeType = "entity"                # enforced by enum
    capacity: CapacitySpec                     # REQUIRED
    initial_current: Optional[Expr] = None
    refresh: Optional[ResourceRefresh] = None
    expiry: Optional[Dict[str, Union[str, int]]] = None
    absorption: Optional[AbsorptionSpec] = None
    visibility: Optional[Visibility] = "public"
    stacking: Optional[Dict[str, Union[str, int]]] = None
    recomputeOn: Optional[List[str]] = None
    freezeOnAttach: Optional[bool] = None      # will enforce boolean

    notes: Optional[str] = None

    @model_validator(mode="after")
    def _validate(self):
        # freezeOnAttach must be boolean if provided (pydantic type already enforces)
        # Optional: default to False if omitted (engine-level default)
        return self


# TaskDefinition (Downtime/Exploration tasks)
class TaskCost(BaseModel):
    kind: Literal["gp", "xp", "resource"]
    amount: Expr
    timing: Optional[Literal["start", "eachStep", "end"]] = "start"
    resource_id: Optional[str] = None  # required when kind == "resource"

    @model_validator(mode="after")
    def _validate(self):
        if self.kind == "resource" and not self.resource_id:
            raise ValueError("TaskCost kind 'resource' requires resource_id")
        return self

class ProgressSpec(BaseModel):
    # Track progress in a named variable (default 'progress')
    var: str = "progress"
    initial: Expr = 0  # initial value; default 0

class CompletionSpec(BaseModel):
    # Either: when (predicate expression) OR (targetVar + targetAmount)
    when: Optional[str] = None                 # expression: returns truthy when complete
    targetVar: Optional[str] = None
    targetAmount: Optional[Expr] = None
    actions: List[HookAction] = Field(default_factory=list)  # actions to run on completion

    @model_validator(mode="after")
    def _require_predicate_or_target(self):
        if self.when is None:
            if not (self.targetVar and self.targetAmount is not None):
                raise ValueError("completion requires either 'when' expression OR (targetVar and targetAmount)")
        return self

class TaskDefinition(BaseModel):
    id: IDStr
    name: str
    timeUnit: Literal["minutes", "hours", "days", "weeks"]
    step: int  # tick size in timeUnit (>0)
    inputs: Optional[List[str]] = None
    costs: Optional[List[TaskCost]] = None
    hooks: List[RuleHook] = Field(default_factory=list)  # scheduler-only, with event in match
    progress: Optional[ProgressSpec] = None
    completion: CompletionSpec  # REQUIRED
    interrupts: Optional[Dict[str, Union[str, int]]] = None
    notes: Optional[str] = None

    @model_validator(mode="after")
    def _validate(self):
        errs: list[str] = []

        # step > 0
        if self.step <= 0:
            errs.append("step must be > 0")

        # hooks: only scheduler + must declare match.event in allowed set
        allowed_events = {"onStart", "eachStep", "onComplete"}
        for h in self.hooks:
            if h.scope != "scheduler":
                errs.append(f"Task hooks must use scope 'scheduler' (got '{h.scope}')")
                continue
            ev = None
            if isinstance(h.match, dict):
                ev = h.match.get("event")
            if not isinstance(ev, str) or ev not in allowed_events:
                errs.append(f"Task scheduler hook requires match.event in {sorted(allowed_events)} (got {ev!r})")

        if errs:
            raise ValueError("; ".join(errs))
        return self


class ZoneSuppression(BaseModel):
    kind: Literal["antimagic", "spell_globe"]
    # For Minor Globe / Globe of Invulnerability style
    max_spell_level: Optional[int] = None   # required for spell_globe

    @model_validator(mode="after")
    def _validate(self):
        if self.kind == "spell_globe":
            if self.max_spell_level is None or self.max_spell_level < 0:
                raise ValueError("suppression.kind 'spell_globe' requires non-negative max_spell_level")
        else:
            # antimagic must not specify max_spell_level
            if self.max_spell_level is not None:
                raise ValueError("suppression.kind 'antimagic' must not specify max_spell_level")
        return self

class ZoneDefinition(BaseModel):
    id: IDStr
    name: str
    shape: "AreaSpec"
    duration: Optional["DurationSpec"] = None
    hooks: List["RuleHook"] = Field(default_factory=list)  # only on.enter/on.leave/scheduler/incoming.effect
    stacking: Optional[Dict[str, Union[str, int]]] = None
    suppression: Optional[ZoneSuppression] = None
    owner_tags: Optional[List[str]] = None
    notes: Optional[str] = None

    @model_validator(mode="after")
    def _validate_zone(self):
        errs: list[str] = []
        # shape != none
        if self.shape is None or self.shape.shape == "none":
            errs.append("Zone shape must not be 'none'")

        # duration required; zones are either timed or permanent/special; concentration belongs to the creating effect
        if self.duration is None:
            errs.append("Zone duration is required (use 'permanent' or 'special' if indefinite)")
        else:
            if self.duration.type == "concentration":
                errs.append("Zone duration cannot be 'concentration' (model concentration on the creating EffectDefinition)")

            # Instantaneous zones cannot have scheduler hooks
            if self.duration.type == "instantaneous":
                for h in self.hooks:
                    if h.scope == "scheduler":
                        errs.append("Instantaneous zones must not have 'scheduler' hooks")

        # Hook scopes limited set + scheduler events required/validated
        allowed_scopes = {"on.enter", "on.leave", "scheduler", "incoming.effect"}
        for h in self.hooks:
            if h.scope not in allowed_scopes:
                errs.append(f"Zone hook scope '{h.scope}' not allowed; allowed: {sorted(allowed_scopes)}")
                continue
            if h.scope == "scheduler":
                ev = None
                if isinstance(h.match, dict):
                    ev = h.match.get("event")
                if not isinstance(ev, str):
                    errs.append("Zone scheduler hook requires match.event")
                else:
                    # allow exact or prefixed forms
                    allowed_exact = {"startOfTurn", "endOfTurn", "eachRound"}
                    allowed_prefixes = ("startOfTurn", "endOfTurn")
                    if ev in allowed_exact or any(ev.startswith(pfx) for pfx in allowed_prefixes):
                        pass
                    else:
                        errs.append(f"Zone scheduler match.event must be one of {sorted(allowed_exact)} "
                                    f"(or prefixed 'startOfTurn(...)'/'endOfTurn(...)'); got {ev!r}")

        if errs:
            raise ValueError("; ".join(errs))
        return self

class DeityDefinition(BaseModel):
    id: IDStr
    name: str
    description: Optional[str] = None
    alignment: str # e.g., "lawful good", "neutral evil"
    allowed_domains: List[IDStr] = Field(default_factory=list) # List of domain effect IDs, e.g., "domain.fire"
    allowed_alignments: List[str] = Field(default_factory=list) # List of alignments allowed to worship this deity

ActModify.model_rebuild()
ActReroll.model_rebuild()
ActCap.model_rebuild()
ActMultiply.model_rebuild()
ActReflect.model_rebuild()
ActRedirect.model_rebuild()
ActAbsorbIntoPool.model_rebuild()
ActSetOutcome.model_rebuild()
HookAction.__args__  # no-op to keep linters quiet
RuleHook.model_rebuild()
ConditionDefinition.model_rebuild()
ResourceDefinition.model_rebuild()
ResourceRefresh.model_rebuild()
AbsorptionSpec.model_rebuild()
CapacitySpec.model_rebuild()
TaskCost.model_rebuild()
ProgressSpec.model_rebuild()
CompletionSpec.model_rebuild()
TaskDefinition.model_rebuild()
ZoneSuppression.model_rebuild()
ZoneDefinition.model_rebuild()
DeityDefinition.model_rebuild()
OpAbilityDamage.model_rebuild()
OpAbilityDrain.model_rebuild()
```

```
File: D:\Projects\Game Dev\D&D text RPG\src\dndrpg\engine\settings.py
from __future__ import annotations
from pathlib import Path
from pydantic import BaseModel
from typing import Optional

SETTINGS_PATH = Path.home() / ".dndrpg" / "settings.json"

class Settings(BaseModel):
    hp_first_level_max: bool = True
    point_buy: int = 28
    rng_seed_mode: str = "fixed"  # fixed | random | session
    default_content_pack: Optional[str] = None
    ui_show_expr_cache: bool = False

def load_settings() -> Settings:
    if SETTINGS_PATH.exists():
        return Settings.model_validate_json(SETTINGS_PATH.read_text(encoding="utf-8"))
    SETTINGS_PATH.parent.mkdir(parents=True, exist_ok=True)
    s = Settings()
    SETTINGS_PATH.write_text(s.model_dump_json(indent=2), encoding="utf-8")
    return s

def save_settings(s: Settings) -> None:
    SETTINGS_PATH.parent.mkdir(parents=True, exist_ok=True)
    SETTINGS_PATH.write_text(s.model_dump_json(indent=2), encoding="utf-8")
```

```
File: D:\Projects\Game Dev\D&D text RPG\src\dndrpg\engine\skills.py
CLASS_SKILLS = {
    "fighter": {"Climb","Craft","Handle Animal","Intimidate","Jump","Ride","Swim"},
    "cleric": {"Concentration","Craft","Diplomacy","Heal","Knowledge (arcana)","Knowledge (history)","Knowledge (religion)","Knowledge (the planes)","Profession","Spellcraft"},
    "sorcerer":{"Bluff","Concentration","Craft","Profession","Knowledge (arcana)","Spellcraft"},
    "monk": {"Balance","Climb","Concentration","Craft","Diplomacy","Escape Artist","Hide","Jump","Knowledge (arcana)","Knowledge (religion)","Listen","Move Silently","Perform","Profession","Sense Motive","Spot","Swim","Tumble"},
}
def max_ranks(level: int, class_skill: bool) -> int:
    return (level + 3) if class_skill else ((level + 3)//2)
def skill_points_at_level1(clazz: str, int_mod: int, human: bool) -> int:
    base = {"fighter":2,"cleric":2,"sorcerer":2,"monk":4}.get(clazz, 2)
    total = (base + max(1, int_mod)) * 4
    if human:
        total += 4
    return total
```

```
File: D:\Projects\Game Dev\D&D text RPG\src\dndrpg\engine\spells.py
from __future__ import annotations
from typing import Dict

def bonus_slots_from_mod(mod: int, max_level: int = 1) -> Dict[int, int]:
    # RAW table simplified for levels 0â€“1 (0 has no bonus; 1 has +1 at Wis/Cha 12+)
    bonus = {0: 0, 1: 0}
    if mod >= 1:
        bonus[1] = 1
    return bonus

def sorcerer_spells_known_from_cha(level: int, cha_mod: int) -> Dict[int, int]:
    # Simplified Sorcerer Spells Known (D&D 3.5e PHB p. 177)
    # This is a basic approximation for level 1
    # Actual rules are more complex, involving class level and CHA modifier
    spells_known = {0: 4, 1: 2} # Base for level 1 Sorcerer

    # Bonus spells known from high CHA (only for spell levels they can cast)
    # For level 1, only 1st level spells get bonus from CHA
    if cha_mod >= 1:
        spells_known[1] += 1 # +1 for 1st level spells if CHA mod >= 1

    return spells_known
```

```
File: D:\Projects\Game Dev\D&D text RPG\src\dndrpg\engine\state.py
import random
from pydantic import BaseModel, Field
from typing import Dict, List
from .models import Entity, Abilities, AbilityScore, Size, Item
from .loader import ContentIndex
from .effects_runtime import EffectInstance
from .resources_runtime import ResourceState
from .conditions_runtime import ConditionInstance  # NEW
from .zones_runtime import ZoneInstance

class GameState(BaseModel):
    player: Entity
    npcs: List[Entity] = Field(default_factory=list)
    log: list[str] = Field(default_factory=list)
    active_effects: Dict[str, List[EffectInstance]] = Field(default_factory=dict)
    active_conditions: Dict[str, List[ConditionInstance]] = Field(default_factory=dict)  # NEW
    round_counter: int = 0
    # NEW: resource storage: map owner key -> list of ResourceState
    resources: Dict[str, List[ResourceState]] = Field(default_factory=dict)
    active_zones: Dict[str, List[ZoneInstance]] = Field(default_factory=dict)  # owner_entity_id -> zones
    last_trace: list[str] = Field(default_factory=list)
    seed: int = Field(default_factory=lambda: random.randint(0, 2**32 - 1))
    rng_state: tuple = Field(default_factory=lambda: random.getstate())

    def resources_summary(self) -> dict[str, int]:
        # Aggregate entity-scoped resources for player
        out: dict[str, int] = {}
        key = f"entity:{self.player.id}"
        for rs in self.resources.get(key, []):
            nm = rs.name or (rs.definition_id or "resource")
            out[nm] = rs.current
        # Sum Temp HP from all effect-instance scopes for this entity
        total_thp = 0
        for k, lst in self.resources.items():
            if not k.startswith("effect:"):
                continue
            for rs in lst:
                if rs.owner_entity_id == self.player.id and (rs.definition_id == "res.temp_hp" or (rs.name and "Temp" in rs.name)):
                    total_thp += rs.current
        if total_thp > 0:
            out["Temp HP"] = total_thp
        return out

    def initialize_rng(self):
        random.setstate(self.rng_state)

    def update_rng_state(self):
        self.rng_state = random.getstate()


def default_cleric_lvl1(content: ContentIndex) -> Entity:
    abilities = Abilities(
        str_=AbilityScore(base=14), dex=AbilityScore(base=12), con=AbilityScore(base=12),
        int_=AbilityScore(base=10), wis=AbilityScore(base=14), cha=AbilityScore(base=10),
    )
    # Clone items from content
    mace = content.clone_item("wp.mace.heavy")
    chain_shirt = content.clone_item("ar.chain_shirt")
    heavy_wooden_shield = content.clone_item("sh.heavy_wooden")
    holy_symbol = content.clone_item("it.holy_symbol")
    rations = content.clone_item("it.rations.5")

    inv: list[Item] = [mace, chain_shirt, heavy_wooden_shield, holy_symbol, rations]

    ent = Entity(
        id="pc.aria", name="Aria (Human Cleric 1)", level=1, size=Size.MEDIUM, abilities=abilities,
        base_attack_bonus=0, base_fort=2, base_ref=0, base_will=2,
        hp_max=9, hp_current=9, speed_land=30, inventory=inv,
        equipment={"armor": chain_shirt.id, "shield": heavy_wooden_shield.id, "main_hand": mace.id},
        classes={"cleric": 1},
        caster_levels={"cleric": 1},
        hd=1
    )
    return ent

def default_goblin(content: ContentIndex) -> Entity:
    abilities = Abilities(
        str_=AbilityScore(base=11), dex=AbilityScore(base=13), con=AbilityScore(base=12),
        int_=AbilityScore(base=10), wis=AbilityScore(base=9), cha=AbilityScore(base=6),
    )
    ent = Entity(
        id="npc.goblin.1", name="Goblin", level=1, size=Size.SMALL, abilities=abilities,
        base_attack_bonus=1, base_fort=2, base_ref=0, base_will=0,
        hp_max=6, hp_current=6, speed_land=30,
        natural_armor=1,
        hd=1
    )
    return ent

def default_state(content: ContentIndex) -> GameState:
    game_state = GameState(player=default_cleric_lvl1(content), npcs=[default_goblin(content)])
    random.seed(game_state.seed)
    game_state.update_rng_state()
    return game_state

GameState.model_rebuild()
```

```
File: D:\Projects\Game Dev\D&D text RPG\src\dndrpg\engine\targetpaths_registry.py
from __future__ import annotations
from dataclasses import dataclass
from typing import Optional, Dict, Set

@dataclass(frozen=True)
class PathMeta:
    kind: str                      # "numeric", "tags", "resource"
    allowed_ops: Set[str]          # {"add","set","min","max",...}
    require_bonus_type_for_add: bool = False
    allowed_bonus_types: Optional[Set[str]] = None  # None = any; else restricted

# Exact registry entries (most specific first)
_REGISTRY_EXACT: Dict[str, PathMeta] = {
    # Abilities (apply to score directly; typed bonuses needed for add/sub)
    "abilities.str": PathMeta("numeric", {"add","subtract","set","min","max","cap","clamp"}, True, None),
    "abilities.dex": PathMeta("numeric", {"add","subtract","set","min","max","cap","clamp"}, True, None),
    "abilities.con": PathMeta("numeric", {"add","subtract","set","min","max","cap","clamp"}, True, None),
    "abilities.int": PathMeta("numeric", {"add","subtract","set","min","max","cap","clamp"}, True, None),
    "abilities.wis": PathMeta("numeric", {"add","subtract","set","min","max","cap","clamp"}, True, None),
    "abilities.cha": PathMeta("numeric", {"add","subtract","set","min","max","cap","clamp"}, True, None),

    # AC components
    "ac.natural":     PathMeta("numeric", {"add","subtract","set","min","max","cap","clamp"}, True, {"natural_armor","natural_armor_enhancement"}),
    "ac.deflection":  PathMeta("numeric", {"add","subtract","set","min","max","cap","clamp"}, True, {"deflection"}),
    "ac.dodge":       PathMeta("numeric", {"add","subtract","set","min","max","cap","clamp"}, True, {"dodge"}),
    "ac.misc":        PathMeta("numeric", {"add","subtract","set","min","max","cap","clamp"}, True, None),
    # Totals (rare; allowed but we still require typed for add/sub)
    "ac.total":       PathMeta("numeric", {"add","subtract","set","min","max","cap","clamp"}, True, None),
    "ac.touch":       PathMeta("numeric", {"add","subtract","set","min","max","cap","clamp"}, True, None),
    "ac.flat_footed": PathMeta("numeric", {"add","subtract","set","min","max","cap","clamp"}, True, None),

    # Saves
    "save.fort": PathMeta("numeric", {"add","subtract","set","min","max","cap","clamp"}, True, None),
    "save.ref":  PathMeta("numeric", {"add","subtract","set","min","max","cap","clamp"}, True, None),
    "save.will": PathMeta("numeric", {"add","subtract","set","min","max","cap","clamp"}, True, None),

    # Attacks / BAB
    "attack.bab.effective": PathMeta("numeric", {"set","min","max","replace"}, False, None),
    "attack.melee.bonus":   PathMeta("numeric", {"add","subtract","set","min","max","cap","clamp"}, True, None),
    "attack.ranged.bonus":  PathMeta("numeric", {"add","subtract","set","min","max","cap","clamp"}, True, None),

    # Speed
    "speed.land": PathMeta("numeric", {"add","subtract","set","min","max","cap","clamp","multiply"}, False, None),

    # Senses (numeric radii)
    "senses.darkvision": PathMeta("numeric", {"add","set","min","max","cap","clamp"}, False, None),
    "senses.blindsense": PathMeta("numeric", {"add","set","min","max","cap","clamp"}, False, None),
    "senses.blindsight": PathMeta("numeric", {"add","set","min","max","cap","clamp"}, False, None),
    "senses.low_light":  PathMeta("numeric", {"add","set","min","max","cap","clamp"}, False, None),

    # Tags: grant/remove only (handled by other systems)
    "tags": PathMeta("tags", {"grantTag","removeTag"}, False, None),

    # Resources: numeric pools, generally add/set/etc.
    "resources": PathMeta("resource", {"add","set","min","max","cap","clamp"}, False, None),
}

# Wildcard registry (prefix-based)
_REGISTRY_PREFIX: Dict[str, PathMeta] = {
    "abilities.": PathMeta("numeric", {"add","subtract","set","min","max","cap","clamp"}, True, None),
    "ac.":        PathMeta("numeric", {"add","subtract","set","min","max","cap","clamp"}, True, None),
    "save.":      PathMeta("numeric", {"add","subtract","set","min","max","cap","clamp"}, True, None),
    "attack.":    PathMeta("numeric", {"add","subtract","set","min","max","cap","clamp","replace"}, True, None),
    "speed.":     PathMeta("numeric", {"add","subtract","set","min","max","cap","clamp","multiply"}, False, None),
    "senses.":    PathMeta("numeric", {"add","set","min","max","cap","clamp"}, False, None),
    "tags.":      PathMeta("tags", {"grantTag","removeTag"}, False, None),
    "resources.": PathMeta("resource", {"add","set","min","max","cap","clamp"}, False, None),
}

def resolve_meta(path: str) -> Optional[PathMeta]:
    if path in _REGISTRY_EXACT:
        return _REGISTRY_EXACT[path]
    for pref, meta in _REGISTRY_PREFIX.items():
        if path.startswith(pref):
            return meta
    return None
```

```
File: D:\Projects\Game Dev\D&D text RPG\src\dndrpg\engine\target_paths.py
from __future__ import annotations
from typing import Dict, List, Literal, Optional

# Re-importing these for type hints, as they are used in the metadata
from .schema_models import ModifierOperator

class TargetPathInfo:
    """
    Metadata for a targetPath prefix, used for schema validation and runtime checks.
    """
    def __init__(self,
                 prefix: str,
                 description: str,
                 allowed_operators: Optional[List[ModifierOperator]] = None,
                 requires_bonus_type: bool = False,
                 value_type: Literal["int", "float", "bool", "str", "any"] = "any",
                 example_paths: Optional[List[str]] = None):
        self.prefix = prefix
        self.description = description
        self.allowed_operators = allowed_operators
        self.requires_bonus_type = requires_bonus_type
        self.value_type = value_type
        self.example_paths = example_paths

# Central registry for target paths and their metadata
TARGET_PATH_REGISTRY: Dict[str, TargetPathInfo] = {
    "abilities": TargetPathInfo(
        prefix="abilities",
        description="Core ability scores (str, dex, con, int, wis, cha) and their modifiers.",
        allowed_operators=["add", "subtract", "set", "min", "max"],
        requires_bonus_type=True,
        value_type="int",
        example_paths=["abilities.str.score", "abilities.dex.mod"]
    ),
    "ac": TargetPathInfo(
        prefix="ac",
        description="Armor Class components (total, touch, flat-footed) and their breakdown.",
        allowed_operators=["add", "subtract", "set", "min", "max"],
        requires_bonus_type=True,
        value_type="int",
        example_paths=["ac.total", "ac.dodge", "ac.natural_armor"]
    ),
    "save": TargetPathInfo(
        prefix="save",
        description="Saving throws (fort, ref, will).",
        allowed_operators=["add", "subtract", "set", "min", "max"],
        requires_bonus_type=True,
        value_type="int",
        example_paths=["save.fort", "save.ref", "save.will"]
    ),
    "resist": TargetPathInfo(
        prefix="resist",
        description="Energy resistances (fire, cold, acid, electricity, sonic, force, negative, positive).",
        allowed_operators=["add", "subtract", "set", "min", "max"],
        requires_bonus_type=False, # Resistances typically stack, but not with bonus types
        value_type="int",
        example_paths=["resist.fire", "resist.cold"]
    ),
    "dr": TargetPathInfo(
        prefix="dr",
        description="Damage Reduction (e.g., dr.physical, dr.slashing).",
        allowed_operators=["add", "subtract", "set", "min", "max"],
        requires_bonus_type=False, # DR typically stacks, but not with bonus types
        value_type="int",
        example_paths=["dr.physical", "dr.slashing"]
    ),
    "speed": TargetPathInfo(
        prefix="speed",
        description="Movement speeds (e.g., speed.land, speed.fly).",
        allowed_operators=["add", "subtract", "set", "multiply", "min", "max", "cap", "clamp"],
        requires_bonus_type=False,
        value_type="int",
        example_paths=["speed.land", "speed.fly"]
    ),
    "senses": TargetPathInfo(
        prefix="senses",
        description="Special senses (e.g., senses.darkvision, senses.blindsense).",
        allowed_operators=["add", "set", "min", "max", "grantTag", "removeTag"], # Add/remove tags for senses
        requires_bonus_type=False,
        value_type="bool", # Or specific sense value
        example_paths=["senses.darkvision", "senses.blindsense"]
    ),
    "tags": TargetPathInfo(
        prefix="tags",
        description="Entity tags (e.g., tags.prone, tags.invisible).",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["tags.prone", "tags.invisible"]
    ),
    "resources": TargetPathInfo(
        prefix="resources",
        description="Dynamic resources (e.g., spell slots, daily uses, ki points).",
        allowed_operators=["add", "subtract", "set", "min", "max", "cap", "clamp"],
        requires_bonus_type=False,
        value_type="int",
        example_paths=["resources.spell_slots.level1", "resources.turn_attempts"]
    ),
    "attack": TargetPathInfo(
        prefix="attack",
        description="Attack bonuses (melee, ranged, touch).",
        allowed_operators=["add", "subtract", "set", "min", "max"],
        requires_bonus_type=True,
        value_type="int",
        example_paths=["attack.melee_bonus", "attack.ranged_bonus"]
    ),
    "bab": TargetPathInfo(
        prefix="bab",
        description="Base Attack Bonus.",
        allowed_operators=["add", "subtract", "set", "min", "max"],
        requires_bonus_type=True,
        value_type="int",
        example_paths=["bab.total"]
    ),
    # Add other prefixes as needed, e.g., "hp", "thp", "nonlethal_damage"
    "hp": TargetPathInfo(
        prefix="hp",
        description="Hit Points (current, max).",
        allowed_operators=["add", "subtract", "set", "min", "max", "cap", "clamp"],
        requires_bonus_type=False,
        value_type="int",
        example_paths=["hp.current", "hp.max"]
    ),
    "thp": TargetPathInfo(
        prefix="thp",
        description="Temporary Hit Points.",
        allowed_operators=["add", "subtract", "set", "min", "max", "cap", "clamp"],
        requires_bonus_type=False,
        value_type="int",
        example_paths=["thp.current"]
    ),
    "nonlethal_damage": TargetPathInfo(
        prefix="nonlethal_damage",
        description="Nonlethal damage taken.",
        allowed_operators=["add", "subtract", "set", "min", "max", "cap", "clamp"],
        requires_bonus_type=False,
        value_type="int",
        example_paths=["nonlethal_damage.current"]
    ),
    "size": TargetPathInfo(
        prefix="size",
        description="Entity size category.",
        allowed_operators=["set"], # Size is usually set, not added/subtracted
        requires_bonus_type=False,
        value_type="str", # e.g., "fine", "diminutive", "tiny", "small", "medium", "large", "huge", "gargantuan", "colossal"
        example_paths=["size.category"]
    ),
    "reach": TargetPathInfo(
        prefix="reach",
        description="Melee reach.",
        allowed_operators=["add", "subtract", "set", "min", "max"],
        requires_bonus_type=False,
        value_type="int",
        example_paths=["reach.melee"]
    ),
    "weight": TargetPathInfo(
        prefix="weight",
        description="Entity weight (for encumbrance).",
        allowed_operators=["add", "subtract", "set", "multiply", "divide"],
        requires_bonus_type=False,
        value_type="float",
        example_paths=["weight.carried"]
    ),
    "caster_level": TargetPathInfo(
        prefix="caster_level",
        description="Caster level for specific spellcasting classes or general.",
        allowed_operators=["add", "subtract", "set", "min", "max"],
        requires_bonus_type=True,
        value_type="int",
        example_paths=["caster_level.cleric", "caster_level.total"]
    ),
    "initiator_level": TargetPathInfo(
        prefix="initiator_level",
        description="Initiator level for martial adepts.",
        allowed_operators=["add", "subtract", "set", "min", "max"],
        requires_bonus_type=True,
        value_type="int",
        example_paths=["initiator_level.total"]
    ),
    "hd": TargetPathInfo(
        prefix="hd",
        description="Hit Dice.",
        allowed_operators=["add", "subtract", "set", "min", "max"],
        requires_bonus_type=False,
        value_type="int",
        example_paths=["hd.total"]
    ),
    "level": TargetPathInfo(
        prefix="level",
        description="Overall character level.",
        allowed_operators=["add", "subtract", "set", "min", "max"],
        requires_bonus_type=False,
        value_type="int",
        example_paths=["level.total"]
    ),
    "class_level": TargetPathInfo(
        prefix="class_level",
        description="Level in a specific class.",
        allowed_operators=["add", "subtract", "set", "min", "max"],
        requires_bonus_type=False,
        value_type="int",
        example_paths=["class_level.fighter", "class_level.cleric"]
    ),
    "feats": TargetPathInfo(
        prefix="feats",
        description="Feats granted or removed.",
        allowed_operators=["grantTag", "removeTag"], # Using grantTag/removeTag for feats
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["feats.power_attack"]
    ),
    "spells": TargetPathInfo(
        prefix="spells",
        description="Spells known or available.",
        allowed_operators=["grantTag", "removeTag"], # Using grantTag/removeTag for spells
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["spells.grease"]
    ),
    "skills": TargetPathInfo(
        prefix="skills",
        description="Skill ranks or modifiers.",
        allowed_operators=["add", "subtract", "set", "min", "max"],
        requires_bonus_type=True,
        value_type="int",
        example_paths=["skills.jump", "skills.listen"]
    ),
    "immunities": TargetPathInfo(
        prefix="immunities",
        description="Immunities to damage types or conditions.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["immunities.fire", "immunities.poison"]
    ),
    "vulnerabilities": TargetPathInfo(
        prefix="vulnerabilities",
        description="Vulnerabilities to damage types.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["vulnerabilities.fire"]
    ),
    "crit_range": TargetPathInfo(
        prefix="crit_range",
        description="Critical threat range of a weapon or attack.",
        allowed_operators=["add", "subtract", "set", "min", "max"],
        requires_bonus_type=False,
        value_type="int",
        example_paths=["crit_range.weapon.longsword"]
    ),
    "crit_multiplier": TargetPathInfo(
        prefix="crit_multiplier",
        description="Critical multiplier of a weapon or attack.",
        allowed_operators=["add", "subtract", "set", "min", "max"],
        requires_bonus_type=False,
        value_type="int",
        example_paths=["crit_multiplier.weapon.longsword"]
    ),
    "damage_dice": TargetPathInfo(
        prefix="damage_dice",
        description="Damage dice of a weapon or attack.",
        allowed_operators=["set"], # Usually set, not modified
        requires_bonus_type=False,
        value_type="str", # e.g., "1d8", "2d6"
        example_paths=["damage_dice.weapon.longsword"]
    ),
    "damage_bonus": TargetPathInfo(
        prefix="damage_bonus",
        description="Bonus damage to attacks.",
        allowed_operators=["add", "subtract", "set", "min", "max"],
        requires_bonus_type=True,
        value_type="int",
        example_paths=["damage_bonus.melee", "damage_bonus.ranged"]
    ),
    "spell_slots": TargetPathInfo(
        prefix="spell_slots",
        description="Spell slots per level.",
        allowed_operators=["add", "subtract", "set", "min", "max"],
        requires_bonus_type=False,
        value_type="int",
        example_paths=["spell_slots.level1", "spell_slots.level9"]
    ),
    "domains": TargetPathInfo(
        prefix="domains",
        description="Cleric domains.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["domains.fire", "domains.water"]
    ),
    "alignment": TargetPathInfo(
        prefix="alignment",
        description="Character alignment.",
        allowed_operators=["set"],
        requires_bonus_type=False,
        value_type="str", # e.g., "lawful_good", "chaotic_evil"
        example_paths=["alignment.moral", "alignment.ethical"]
    ),
    "deity": TargetPathInfo(
        prefix="deity",
        description="Character's chosen deity.",
        allowed_operators=["set"],
        requires_bonus_type=False,
        value_type="str",
        example_paths=["deity.name"]
    ),
    "hp_regen": TargetPathInfo(
        prefix="hp_regen",
        description="Hit point regeneration per round/turn.",
        allowed_operators=["add", "subtract", "set", "min", "max"],
        requires_bonus_type=False,
        value_type="int",
        example_paths=["hp_regen.amount"]
    ),
    "fast_healing": TargetPathInfo(
        prefix="fast_healing",
        description="Fast healing per round/turn.",
        allowed_operators=["add", "subtract", "set", "min", "max"],
        requires_bonus_type=False,
        value_type="int",
        example_paths=["fast_healing.amount"]
    ),
    "immunities_to_condition": TargetPathInfo(
        prefix="immunities_to_condition",
        description="Immunities to specific conditions.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["immunities_to_condition.prone", "immunities_to_condition.stunned"]
    ),
    "vulnerabilities_to_condition": TargetPathInfo(
        prefix="vulnerabilities_to_condition",
        description="Vulnerabilities to specific conditions.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["vulnerabilities_to_condition.prone"]
    ),
    "spell_resistance": TargetPathInfo(
        prefix="spell_resistance",
        description="Spell Resistance.",
        allowed_operators=["add", "subtract", "set", "min", "max"],
        requires_bonus_type=False,
        value_type="int",
        example_paths=["spell_resistance.total"]
    ),
    "channel_energy": TargetPathInfo(
        prefix="channel_energy",
        description="Cleric's Channel Energy ability.",
        allowed_operators=["add", "subtract", "set", "min", "max"],
        requires_bonus_type=False,
        value_type="int",
        example_paths=["channel_energy.uses", "channel_energy.dice"]
    ),
    "turn_undead": TargetPathInfo(
        prefix="turn_undead",
        description="Cleric's Turn Undead ability.",
        allowed_operators=["add", "subtract", "set", "min", "max"],
        requires_bonus_type=False,
        value_type="int",
        example_paths=["turn_undead.uses", "turn_undead.level_check_bonus"]
    ),
    "rebuke_undead": TargetPathInfo(
        prefix="rebuke_undead",
        description="Cleric's Rebuke Undead ability.",
        allowed_operators=["add", "subtract", "set", "min", "max"],
        requires_bonus_type=False,
        value_type="int",
        example_paths=["rebuke_undead.uses", "rebuke_undead.level_check_bonus"]
    ),
    "flurry_of_blows": TargetPathInfo(
        prefix="flurry_of_blows",
        description="Monk's Flurry of Blows ability.",
        allowed_operators=["set"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["flurry_of_blows.active"]
    ),
    "unarmed_strike_damage": TargetPathInfo(
        prefix="unarmed_strike_damage",
        description="Monk's unarmed strike damage.",
        allowed_operators=["set"],
        requires_bonus_type=False,
        value_type="str", # e.g., "1d6", "1d8"
        example_paths=["unarmed_strike_damage.dice"]
    ),
    "ac_bonus": TargetPathInfo(
        prefix="ac_bonus",
        description="Monk's AC bonus.",
        allowed_operators=["add", "subtract", "set", "min", "max"],
        requires_bonus_type=False,
        value_type="int",
        example_paths=["ac_bonus.monk"]
    ),
    "fast_movement": TargetPathInfo(
        prefix="fast_movement",
        description="Monk's fast movement bonus.",
        allowed_operators=["add", "subtract", "set", "min", "max"],
        requires_bonus_type=False,
        value_type="int",
        example_paths=["fast_movement.speed_bonus"]
    ),
    "evasion": TargetPathInfo(
        prefix="evasion",
        description="Monk's Evasion ability.",
        allowed_operators=["set"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["evasion.active"]
    ),
    "mighty_strike": TargetPathInfo(
        prefix="mighty_strike",
        description="Crusader's Mighty Strike ability.",
        allowed_operators=["add", "subtract", "set", "min", "max"],
        requires_bonus_type=False,
        value_type="int",
        example_paths=["mighty_strike.damage_bonus"]
    ),
    "steely_resolve": TargetPathInfo(
        prefix="steely_resolve",
        description="Crusader's Steely Resolve ability.",
        allowed_operators=["set"],
        requires_bonus_type=False,
        value_type="int",
        example_paths=["steely_resolve.damage_reduction"]
    ),
    "furious_counterstrike": TargetPathInfo(
        prefix="furious_counterstrike",
        description="Crusader's Furious Counterstrike ability.",
        allowed_operators=["add", "subtract", "set", "min", "max"],
        requires_bonus_type=False,
        value_type="int",
        example_paths=["furious_counterstrike.attack_bonus"]
    ),
    "smite": TargetPathInfo(
        prefix="smite",
        description="Paladin/Crusader's Smite ability.",
        allowed_operators=["add", "subtract", "set", "min", "max"],
        requires_bonus_type=False,
        value_type="int",
        example_paths=["smite.damage_bonus"]
    ),
    "soulmelds": TargetPathInfo(
        prefix="soulmelds",
        description="Totemist's soulmelds shaped.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["soulmelds.lammasu_wing_charge"]
    ),
    "essentia": TargetPathInfo(
        prefix="essentia",
        description="Totemist's essentia pool.",
        allowed_operators=["add", "subtract", "set", "min", "max"],
        requires_bonus_type=False,
        value_type="int",
        example_paths=["essentia.current", "essentia.max"]
    ),
    "totem_bind": TargetPathInfo(
        prefix="totem_bind",
        description="Totemist's totem bind ability.",
        allowed_operators=["set"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["totem_bind.active"]
    ),
    "rebind": TargetPathInfo(
        prefix="rebind",
        description="Totemist's rebind ability.",
        allowed_operators=["set"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["rebind.available"]
    ),
    "maneuvers": TargetPathInfo(
        prefix="maneuvers",
        description="Martial maneuvers known or readied.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["maneuvers.strike_of_the_broken_shield"]
    ),
    "stances": TargetPathInfo(
        prefix="stances",
        description="Martial stances known or active.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["stances.iron_guard_s_glare"]
    ),
    "spell_slots_per_day": TargetPathInfo(
        prefix="spell_slots_per_day",
        description="Number of spell slots per day for a given level.",
        allowed_operators=["add", "subtract", "set", "min", "max"],
        requires_bonus_type=False,
        value_type="int",
        example_paths=["spell_slots_per_day.level1", "spell_slots_per_day.level9"]
    ),
    "spells_known": TargetPathInfo(
        prefix="spells_known",
        description="Number of spells known for a given level.",
        allowed_operators=["add", "subtract", "set", "min", "max"],
        requires_bonus_type=False,
        value_type="int",
        example_paths=["spells_known.level1", "spells_known.level9"]
    ),
    "prepared_spells": TargetPathInfo(
        prefix="prepared_spells",
        description="Number of prepared spells for a given level.",
        allowed_operators=["add", "subtract", "set", "min", "max"],
        requires_bonus_type=False,
        value_type="int",
        example_paths=["prepared_spells.level1", "prepared_spells.level9"]
    ),
    "bonus_feats": TargetPathInfo(
        prefix="bonus_feats",
        description="Number of bonus feats available.",
        allowed_operators=["add", "subtract", "set", "min", "max"],
        requires_bonus_type=False,
        value_type="int",
        example_paths=["bonus_feats.total"]
    ),
    "skill_points": TargetPathInfo(
        prefix="skill_points",
        description="Skill points available per level.",
        allowed_operators=["add", "subtract", "set", "min", "max"],
        requires_bonus_type=False,
        value_type="int",
        example_paths=["skill_points.total"]
    ),
    "gold": TargetPathInfo(
        prefix="gold",
        description="Character's gold pieces.",
        allowed_operators=["add", "subtract", "set"],
        requires_bonus_type=False,
        value_type="float",
        example_paths=["gold.current"]
    ),
    "xp": TargetPathInfo(
        prefix="xp",
        description="Character's experience points.",
        allowed_operators=["add", "subtract", "set"],
        requires_bonus_type=False,
        value_type="int",
        example_paths=["xp.current"]
    ),
    "alignment_change": TargetPathInfo(
        prefix="alignment_change",
        description="Changes to alignment (e.g., for specific effects).",
        allowed_operators=["set"],
        requires_bonus_type=False,
        value_type="str",
        example_paths=["alignment_change.moral", "alignment_change.ethical"]
    ),
    "condition_duration": TargetPathInfo(
        prefix="condition_duration",
        description="Duration of a specific condition.",
        allowed_operators=["add", "subtract", "set", "min", "max"],
        requires_bonus_type=False,
        value_type="int",
        example_paths=["condition_duration.prone", "condition_duration.stunned"]
    ),
    "resource_capacity": TargetPathInfo(
        prefix="resource_capacity",
        description="Capacity of a specific resource.",
        allowed_operators=["add", "subtract", "set", "min", "max"],
        requires_bonus_type=False,
        value_type="int",
        example_paths=["resource_capacity.ki_points"]
    ),
    "resource_current": TargetPathInfo(
        prefix="resource_current",
        description="Current value of a specific resource.",
        allowed_operators=["add", "subtract", "set", "min", "max"],
        requires_bonus_type=False,
        value_type="int",
        example_paths=["resource_current.ki_points"]
    ),
    "zone_duration": TargetPathInfo(
        prefix="zone_duration",
        description="Duration of a specific zone.",
        allowed_operators=["add", "subtract", "set", "min", "max"],
        requires_bonus_type=False,
        value_type="int",
        example_paths=["zone_duration.grease_area"]
    ),
    "zone_size": TargetPathInfo(
        prefix="zone_size",
        description="Size of a specific zone.",
        allowed_operators=["add", "subtract", "set", "min", "max"],
        requires_bonus_type=False,
        value_type="int",
        example_paths=["zone_size.grease_area"]
    ),
    "item_property": TargetPathInfo(
        prefix="item_property",
        description="Properties of an item (e.g., damage, weight).",
        allowed_operators=["add", "subtract", "set", "multiply", "divide"],
        requires_bonus_type=False,
        value_type="any",
        example_paths=["item_property.longsword.damage", "item_property.chain_shirt.ac_bonus"]
    ),
    "weapon_property": TargetPathInfo(
        prefix="weapon_property",
        description="Properties specific to weapons.",
        allowed_operators=["add", "subtract", "set", "multiply", "divide"],
        requires_bonus_type=False,
        value_type="any",
        example_paths=["weapon_property.longsword.crit_range"]
    ),
    "armor_property": TargetPathInfo(
        prefix="armor_property",
        description="Properties specific to armor.",
        allowed_operators=["add", "subtract", "set", "multiply", "divide"],
        requires_bonus_type=False,
        value_type="any",
        example_paths=["armor_property.chain_shirt.max_dex_bonus"]
    ),
    "shield_property": TargetPathInfo(
        prefix="shield_property",
        description="Properties specific to shields.",
        allowed_operators=["add", "subtract", "set", "multiply", "divide"],
        requires_bonus_type=False,
        value_type="any",
        example_paths=["shield_property.heavy_wooden_shield.ac_bonus"]
    ),
    "feat_property": TargetPathInfo(
        prefix="feat_property",
        description="Properties of a feat.",
        allowed_operators=["add", "subtract", "set", "multiply", "divide"],
        requires_bonus_type=False,
        value_type="any",
        example_paths=["feat_property.power_attack.damage_multiplier"]
    ),
    "spell_property": TargetPathInfo(
        prefix="spell_property",
        description="Properties of a spell.",
        allowed_operators=["add", "subtract", "set", "multiply", "divide"],
        requires_bonus_type=False,
        value_type="any",
        example_paths=["spell_property.fireball.damage_dice"]
    ),
    "condition_property": TargetPathInfo(
        prefix="condition_property",
        description="Properties of a condition.",
        allowed_operators=["add", "subtract", "set", "multiply", "divide"],
        requires_bonus_type=False,
        value_type="any",
        example_paths=["condition_property.prone.ac_penalty"]
    ),
    "resource_property": TargetPathInfo(
        prefix="resource_property",
        description="Properties of a resource.",
        allowed_operators=["add", "subtract", "set", "multiply", "divide"],
        requires_bonus_type=False,
        value_type="any",
        example_paths=["resource_property.ki_points.refresh_rate"]
    ),
    "zone_property": TargetPathInfo(
        prefix="zone_property",
        description="Properties of a zone.",
        allowed_operators=["add", "subtract", "set", "multiply", "divide"],
        requires_bonus_type=False,
        value_type="any",
        example_paths=["zone_property.grease_area.dc"]
    ),
    "task_property": TargetPathInfo(
        prefix="task_property",
        description="Properties of a task.",
        allowed_operators=["add", "subtract", "set", "multiply", "divide"],
        requires_bonus_type=False,
        value_type="any",
        example_paths=["task_property.craft_item.progress_per_day"]
    ),
    "race_property": TargetPathInfo(
        prefix="race_property",
        description="Properties of a race.",
        allowed_operators=["add", "subtract", "set", "multiply", "divide"],
        requires_bonus_type=False,
        value_type="any",
        example_paths=["race_property.human.bonus_skill_points"]
    ),
    "class_property": TargetPathInfo(
        prefix="class_property",
        description="Properties of a class.",
        allowed_operators=["add", "subtract", "set", "multiply", "divide"],
        requires_bonus_type=False,
        value_type="any",
        example_paths=["class_property.fighter.bonus_feats_at_level"]
    ),
    "alignment_property": TargetPathInfo(
        prefix="alignment_property",
        description="Properties related to alignment.",
        allowed_operators=["set"],
        requires_bonus_type=False,
        value_type="str",
        example_paths=["alignment_property.lawful_good.aura_strength"]
    ),
    "deity_property": TargetPathInfo(
        prefix="deity_property",
        description="Properties related to a deity.",
        allowed_operators=["set"],
        requires_bonus_type=False,
        value_type="str",
        example_paths=["deity_property.bahamut.favored_weapon"]
    ),
    "game_state": TargetPathInfo(
        prefix="game_state",
        description="Global game state variables.",
        allowed_operators=["add", "subtract", "set", "min", "max"],
        requires_bonus_type=False,
        value_type="any",
        example_paths=["game_state.current_round", "game_state.weather"]
    ),
    "player_character": TargetPathInfo(
        prefix="player_character",
        description="Properties of the player character.",
        allowed_operators=["add", "subtract", "set", "min", "max"],
        requires_bonus_type=False,
        value_type="any",
        example_paths=["player_character.name", "player_character.gold"]
    ),
    "npc": TargetPathInfo(
        prefix="npc",
        description="Properties of a non-player character.",
        allowed_operators=["add", "subtract", "set", "min", "max"],
        requires_bonus_type=False,
        value_type="any",
        example_paths=["npc.goblin_1.hp", "npc.goblin_1.status"]
    ),
    "party": TargetPathInfo(
        prefix="party",
        description="Properties of the player's party.",
        allowed_operators=["add", "subtract", "set", "min", "max"],
        requires_bonus_type=False,
        value_type="any",
        example_paths=["party.members", "party.average_level"]
    ),
    "encounter": TargetPathInfo(
        prefix="encounter",
        description="Properties of the current encounter.",
        allowed_operators=["add", "subtract", "set", "min", "max"],
        requires_bonus_type=False,
        value_type="any",
        example_paths=["encounter.round_number", "encounter.enemies_remaining"]
    ),
    "world": TargetPathInfo(
        prefix="world",
        description="Properties of the game world.",
        allowed_operators=["set"],
        requires_bonus_type=False,
        value_type="any",
        example_paths=["world.current_area", "world.time_of_day"]
    ),
    "inventory": TargetPathInfo(
        prefix="inventory",
        description="Inventory management (adding/removing items).",
        allowed_operators=["grantTag", "removeTag"], # Using grantTag/removeTag for items
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["inventory.has_item.potion_of_healing"]
    ),
    "equipment": TargetPathInfo(
        prefix="equipment",
        description="Equipped items.",
        allowed_operators=["set"], # Setting equipped item in a slot
        requires_bonus_type=False,
        value_type="str", # Item ID
        example_paths=["equipment.main_hand", "equipment.armor"]
    ),
    "feats_granted": TargetPathInfo(
        prefix="feats_granted",
        description="Feats granted by an effect or ability.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["feats_granted.power_attack"]
    ),
    "spells_granted": TargetPathInfo(
        prefix="spells_granted",
        description="Spells granted by an effect or ability.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["spells_granted.fireball"]
    ),
    "abilities_granted": TargetPathInfo(
        prefix="abilities_granted",
        description="Special abilities granted by an effect or ability.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["abilities_granted.darkvision"]
    ),
    "conditions_applied": TargetPathInfo(
        prefix="conditions_applied",
        description="Conditions applied by an effect or ability.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["conditions_applied.prone"]
    ),
    "resources_granted": TargetPathInfo(
        prefix="resources_granted",
        description="Resources granted by an effect or ability.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["resources_granted.ki_points"]
    ),
    "zones_created": TargetPathInfo(
        prefix="zones_created",
        description="Zones created by an effect or ability.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["zones_created.grease_area"]
    ),
    "tasks_granted": TargetPathInfo(
        prefix="tasks_granted",
        description="Tasks granted by an effect or ability.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["tasks_granted.craft_magic_item"]
    ),
    "rule_hooks_granted": TargetPathInfo(
        prefix="rule_hooks_granted",
        description="Rule hooks granted by an effect or ability.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["rule_hooks_granted.on_damage_taken_reduce"]
    ),
    "immunities_granted": TargetPathInfo(
        prefix="immunities_granted",
        description="Immunities granted by an effect or ability.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["immunities_granted.fire"]
    ),
    "vulnerabilities_granted": TargetPathInfo(
        prefix="vulnerabilities_granted",
        description="Vulnerabilities granted by an effect or ability.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["vulnerabilities_granted.cold"]
    ),
    "resistances_granted": TargetPathInfo(
        prefix="resistances_granted",
        description="Resistances granted by an effect or ability.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["resistances_granted.fire"]
    ),
    "dr_granted": TargetPathInfo(
        prefix="dr_granted",
        description="Damage Reduction granted by an effect or ability.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["dr_granted.physical"]
    ),
    "speed_granted": TargetPathInfo(
        prefix="speed_granted",
        description="Speed bonuses granted by an effect or ability.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["speed_granted.fast_movement"]
    ),
    "senses_granted": TargetPathInfo(
        prefix="senses_granted",
        description="Senses granted by an effect or ability.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["senses_granted.darkvision"]
    ),
    "ac_granted": TargetPathInfo(
        prefix="ac_granted",
        description="AC bonuses granted by an effect or ability.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["ac_granted.shield_of_faith"]
    ),
    "save_granted": TargetPathInfo(
        prefix="save_granted",
        description="Save bonuses granted by an effect or ability.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["save_granted.resistance"]
    ),
    "attack_granted": TargetPathInfo(
        prefix="attack_granted",
        description="Attack bonuses granted by an effect or ability.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["attack_granted.bless"]
    ),
    "bab_granted": TargetPathInfo(
        prefix="bab_granted",
        description="BAB bonuses granted by an effect or ability.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["bab_granted.divine_power"]
    ),
    "caster_level_granted": TargetPathInfo(
        prefix="caster_level_granted",
        description="Caster level bonuses granted by an effect or ability.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["caster_level_granted.orange_prismatic_ray"]
    ),
    "initiator_level_granted": TargetPathInfo(
        prefix="initiator_level_granted",
        description="Initiator level bonuses granted by an effect or ability.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["initiator_level_granted.stance_of_alacrity"]
    ),
    "hd_granted": TargetPathInfo(
        prefix="hd_granted",
        description="Hit Dice granted by an effect or ability.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["hd_granted.draconic_aura"]
    ),
    "level_granted": TargetPathInfo(
        prefix="level_granted",
        description="Level bonuses granted by an effect or ability.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["level_granted.epic_destiny"]
    ),
    "class_level_granted": TargetPathInfo(
        prefix="class_level_granted",
        description="Class level bonuses granted by an effect or ability.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["class_level_granted.prestige_class_level"]
    ),
    "skills_granted": TargetPathInfo(
        prefix="skills_granted",
        description="Skill bonuses granted by an effect or ability.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["skills_granted.skill_focus"]
    ),
    "spell_slots_granted": TargetPathInfo(
        prefix="spell_slots_granted",
        description="Spell slots granted by an effect or ability.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["spell_slots_granted.extra_slot"]
    ),
    "domains_granted": TargetPathInfo(
        prefix="domains_granted",
        description="Domains granted by an effect or ability.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["domains_granted.fire_domain"]
    ),
    "alignment_granted": TargetPathInfo(
        prefix="alignment_granted",
        description="Alignment changes granted by an effect or ability.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["alignment_granted.chaos_aura"]
    ),
    "deity_granted": TargetPathInfo(
        prefix="deity_granted",
        description="Deity changes granted by an effect or ability.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["deity_granted.divine_favor"]
    ),
    "hp_regen_granted": TargetPathInfo(
        prefix="hp_regen_granted",
        description="HP regeneration granted by an effect or ability.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["hp_regen_granted.troll_regeneration"]
    ),
    "fast_healing_granted": TargetPathInfo(
        prefix="fast_healing_granted",
        description="Fast healing granted by an effect or ability.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["fast_healing_granted.ring_of_regeneration"]
    ),
    "spell_resistance_granted": TargetPathInfo(
        prefix="spell_resistance_granted",
        description="Spell resistance granted by an effect or ability.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["spell_resistance_granted.cloak_of_resistance"]
    ),
    "channel_energy_granted": TargetPathInfo(
        prefix="channel_energy_granted",
        description="Channel Energy ability granted by an effect or ability.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["channel_energy_granted.holy_aura"]
    ),
    "turn_undead_granted": TargetPathInfo(
        prefix="turn_undead_granted",
        description="Turn Undead ability granted by an effect or ability.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["turn_undead_granted.sun_domain"]
    ),
    "rebuke_undead_granted": TargetPathInfo(
        prefix="rebuke_undead_granted",
        description="Rebuke Undead ability granted by an effect or ability.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["rebuke_undead_granted.death_domain"]
    ),
    "flurry_of_blows_granted": TargetPathInfo(
        prefix="flurry_of_blows_granted",
        description="Flurry of Blows ability granted by an effect or ability.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["flurry_of_blows_granted.monk_level"]
    ),
    "unarmed_strike_damage_granted": TargetPathInfo(
        prefix="unarmed_strike_damage_granted",
        description="Unarmed strike damage granted by an effect or ability.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["unarmed_strike_damage_granted.monk_level"]
    ),
    "ac_bonus_granted": TargetPathInfo(
        prefix="ac_bonus_granted",
        description="AC bonus granted by an effect or ability.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["ac_bonus_granted.monk_ac_bonus"]
    ),
    "fast_movement_granted": TargetPathInfo(
        prefix="fast_movement_granted",
        description="Fast movement granted by an effect or ability.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["fast_movement_granted.monk_fast_movement"]
    ),
    "evasion_granted": TargetPathInfo(
        prefix="evasion_granted",
        description="Evasion ability granted by an effect or ability.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["evasion_granted.monk_evasion"]
    ),
    "mighty_strike_granted": TargetPathInfo(
        prefix="mighty_strike_granted",
        description="Mighty Strike ability granted by an effect or ability.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["mighty_strike_granted.crusader_mighty_strike"]
    ),
    "steely_resolve_granted": TargetPathInfo(
        prefix="steely_resolve_granted",
        description="Steely Resolve ability granted by an effect or ability.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["steely_resolve_granted.crusader_steely_resolve"]
    ),
    "furious_counterstrike_granted": TargetPathInfo(
        prefix="furious_counterstrike_granted",
        description="Furious Counterstrike ability granted by an effect or ability.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["furious_counterstrike_granted.crusader_furious_counterstrike"]
    ),
    "smite_granted": TargetPathInfo(
        prefix="smite_granted",
        description="Smite ability granted by an effect or ability.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["smite_granted.paladin_smite"]
    ),
    "soulmelds_granted": TargetPathInfo(
        prefix="soulmelds_granted",
        description="Soulmelds granted by an effect or ability.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["soulmelds_granted.lammasu_wing_charge"]
    ),
    "essentia_granted": TargetPathInfo(
        prefix="essentia_granted",
        description="Essentia granted by an effect or ability.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["essentia_granted.incandescent_cloud"]
    ),
    "totem_bind_granted": TargetPathInfo(
        prefix="totem_bind_granted",
        description="Totem bind ability granted by an effect or ability.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["totem_bind_granted.totem_golem"]
    ),
    "rebind_granted": TargetPathInfo(
        prefix="rebind_granted",
        description="Rebind ability granted by an effect or ability.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["rebind_granted.totem_rebind"]
    ),
    "maneuvers_granted": TargetPathInfo(
        prefix="maneuvers_granted",
        description="Martial maneuvers granted by an effect or ability.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["maneuvers_granted.strike_of_the_broken_shield"]
    ),
    "stances_granted": TargetPathInfo(
        prefix="stances_granted",
        description="Martial stances granted by an effect or ability.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["stances_granted.iron_guard_s_glare"]
    ),
    "spell_slots_per_day_granted": TargetPathInfo(
        prefix="spell_slots_per_day_granted",
        description="Spell slots per day granted by an effect or ability.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["spell_slots_per_day_granted.extra_spell_slots"]
    ),
    "spells_known_granted": TargetPathInfo(
        prefix="spells_known_granted",
        description="Spells known granted by an effect or ability.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["spells_known_granted.bonus_spells"]
    ),
    "prepared_spells_granted": TargetPathInfo(
        prefix="prepared_spells_granted",
        description="Prepared spells granted by an effect or ability.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["prepared_spells_granted.bonus_prepared_spells"]
    ),
    "bonus_feats_granted": TargetPathInfo(
        prefix="bonus_feats_granted",
        description="Bonus feats granted by an effect or ability.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["bonus_feats_granted.fighter_bonus_feat"]
    ),
    "skill_points_granted": TargetPathInfo(
        prefix="skill_points_granted",
        description="Skill points granted by an effect or ability.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["skill_points_granted.human_skill_points"]
    ),
    "gold_granted": TargetPathInfo(
        prefix="gold_granted",
        description="Gold granted by an effect or ability.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["gold_granted.treasure_chest"]
    ),
    "xp_granted": TargetPathInfo(
        prefix="xp_granted",
        description="XP granted by an effect or ability.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["xp_granted.quest_completion"]
    ),
    "alignment_change_granted": TargetPathInfo(
        prefix="alignment_change_granted",
        description="Alignment changes granted by an effect or ability.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["alignment_change_granted.corrupting_influence"]
    ),
    "condition_duration_granted": TargetPathInfo(
        prefix="condition_duration_granted",
        description="Condition duration changes granted by an effect or ability.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["condition_duration_granted.extended_condition"]
    ),
    "resource_capacity_granted": TargetPathInfo(
        prefix="resource_capacity_granted",
        description="Resource capacity changes granted by an effect or ability.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["resource_capacity_granted.extra_ki"]
    ),
    "resource_current_granted": TargetPathInfo(
        prefix="resource_current_granted",
        description="Resource current value changes granted by an effect or ability.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["resource_current_granted.restore_spell_slots"]
    ),
    "zone_duration_granted": TargetPathInfo(
        prefix="zone_duration_granted",
        description="Zone duration changes granted by an effect or ability.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["zone_duration_granted.extended_zone"]
    ),
    "zone_size_granted": TargetPathInfo(
        prefix="zone_size_granted",
        description="Zone size changes granted by an effect or ability.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["zone_size_granted.enlarged_zone"]
    ),
    "item_property_granted": TargetPathInfo(
        prefix="item_property_granted",
        description="Item property changes granted by an effect or ability.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["item_property_granted.flaming_sword"]
    ),
    "weapon_property_granted": TargetPathInfo(
        prefix="weapon_property_granted",
        description="Weapon property changes granted by an effect or ability.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["weapon_property_granted.keen_edge"]
    ),
    "armor_property_granted": TargetPathInfo(
        prefix="armor_property_granted",
        description="Armor property changes granted by an effect or ability.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["armor_property_granted.fortification"]
    ),
    "shield_property_granted": TargetPathInfo(
        prefix="shield_property_granted",
        description="Shield property changes granted by an effect or ability.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["shield_property_granted.animated_shield"]
    ),
    "feat_property_granted": TargetPathInfo(
        prefix="feat_property_granted",
        description="Feat property changes granted by an effect or ability.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["feat_property_granted.improved_initiative"]
    ),
    "spell_property_granted": TargetPathInfo(
        prefix="spell_property_granted",
        description="Spell property changes granted by an effect or ability.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["spell_property_granted.empowered_spell"]
    ),
    "condition_property_granted": TargetPathInfo(
        prefix="condition_property_granted",
        description="Condition property changes granted by an effect or ability.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["condition_property_granted.greater_blindness"]
    ),
    "resource_property_granted": TargetPathInfo(
        prefix="resource_property_granted",
        description="Resource property changes granted by an effect or ability.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["resource_property_granted.enhanced_resource"]
    ),
    "zone_property_granted": TargetPathInfo(
        prefix="zone_property_granted",
        description="Zone property changes granted by an effect or ability.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["zone_property_granted.persistent_zone"]
    ),
    "task_property_granted": TargetPathInfo(
        prefix="task_property_granted",
        description="Task property changes granted by an effect or ability.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["task_property_granted.accelerated_crafting"]
    ),
    "race_property_granted": TargetPathInfo(
        prefix="race_property_granted",
        description="Race property changes granted by an effect or ability.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["race_property_granted.improved_darkvision"]
    ),
    "class_property_granted": TargetPathInfo(
        prefix="class_property_granted",
        description="Class property changes granted by an effect or ability.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["class_property_granted.bonus_spell_slots"]
    ),
    "alignment_property_granted": TargetPathInfo(
        prefix="alignment_property_granted",
        description="Alignment property changes granted by an effect or ability.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["alignment_property_granted.aura_of_good"]
    ),
    "deity_property_granted": TargetPathInfo(
        prefix="deity_property_granted",
        description="Deity property changes granted by an effect or ability.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["deity_property_granted.divine_grace"]
    ),
    "game_state_granted": TargetPathInfo(
        prefix="game_state_granted",
        description="Game state changes granted by an effect or ability.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["game_state_granted.time_stop"]
    ),
    "player_character_granted": TargetPathInfo(
        prefix="player_character_granted",
        description="Player character property changes granted by an effect or ability.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["player_character_granted.heroic_might"]
    ),
    "npc_granted": TargetPathInfo(
        prefix="npc_granted",
        description="NPC property changes granted by an effect or ability.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["npc_granted.charmed_monster"]
    ),
    "party_granted": TargetPathInfo(
        prefix="party_granted",
        description="Party property changes granted by an effect or ability.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["party_granted.bless_party"]
    ),
    "encounter_granted": TargetPathInfo(
        prefix="encounter_granted",
        description="Encounter property changes granted by an effect or ability.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["encounter_granted.surprise_round"]
    ),
    "world_granted": TargetPathInfo(
        prefix="world_granted",
        description="World property changes granted by an effect or ability.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["world_granted.planar_shift"]
    ),
    "inventory_granted": TargetPathInfo(
        prefix="inventory_granted",
        description="Inventory changes granted by an effect or ability.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["inventory_granted.summon_item"]
    ),
    "equipment_granted": TargetPathInfo(
        prefix="equipment_granted",
        description="Equipment changes granted by an effect or ability.",
        allowed_operators=["grantTag", "removeTag"],
        requires_bonus_type=False,
        value_type="bool",
        example_paths=["equipment_granted.magic_weapon"]
    ),
}

# Helper function to get info for a given targetPath
def get_target_path_info(target_path: str) -> Optional[TargetPathInfo]:
    prefix = target_path.split(".", 1)[0]
    return TARGET_PATH_REGISTRY.get(prefix)
```

```
File: D:\Projects\Game Dev\D&D text RPG\src\dndrpg\engine\trace.py
from __future__ import annotations
from typing import List

class TraceSession:
    def __init__(self) -> None:
        self.lines: List[str] = []

    def add(self, line: str) -> None:
        self.lines.append(line)

    def extend(self, many: list[str]) -> None:
        self.lines.extend(many)

    def dump(self) -> list[str]:
        return list(self.lines)
```

```
File: D:\Projects\Game Dev\D&D text RPG\src\dndrpg\engine\wealth.py
import random

CLASS_WEALTH_DICE = {
    "fighter": (6, 4),   # 6d4 Ã— 10 gp
    "cleric":  (5, 4),
    "sorcerer":(3, 4),
    "monk":    (5, 4),   # (monk uses gp differently; keep simple)
}

def roll_class_gold(clazz: str, rng: random.Random) -> int:
    n, die = CLASS_WEALTH_DICE.get(clazz, (3, 4))
    return sum(rng.randint(1, die) for _ in range(n)) * 10
```

```
File: D:\Projects\Game Dev\D&D text RPG\src\dndrpg\engine\zones_runtime.py
from __future__ import annotations
from typing import Optional, List, Tuple, TYPE_CHECKING
from uuid import uuid4
from pydantic import BaseModel, Field
from dndrpg.engine.schema_models import ZoneDefinition, AreaSpec, DurationSpec, RuleHook
from dndrpg.engine.loader import ContentIndex
from dndrpg.engine.rulehooks_runtime import RuleHooksRegistry
if TYPE_CHECKING:
    from .state import GameState

class ZoneInstance(BaseModel):
    instance_id: str = Field(default_factory=lambda: uuid4().hex)
    definition_id: Optional[str] = None
    name: str
    owner_entity_id: Optional[str] = None

    shape: AreaSpec
    duration_type: str = "instantaneous"
    remaining_rounds: Optional[int] = None
    active: bool = True
    notes: Optional[str] = None

class ZoneEngine:
    """
    Minimal zone manager:
     - create_from_definition() or create_inline()
     - registers hooks on the owner's entity via RuleHooksRegistry
     - tick_round() reduces remaining rounds and unregisters hooks on expiry
    """

    def __init__(self, content: ContentIndex, state: "GameState", hooks: RuleHooksRegistry):
        self.content = content
        self.state = state
        self.hooks = hooks

    def is_entity_under_antimagic(self, owner_entity_id: str) -> bool:
        for zi in self.state.active_zones.get(owner_entity_id, []):
            # If zone was created from a definition, read suppression there
            if zi.definition_id:
                zd = self.content.zones.get(zi.definition_id)
                if zd and zd.suppression and zd.suppression.kind == "antimagic":
                    if zi.active:
                        return True
            # Inline zones could encode antimagic via hooks; for now, only typed suppression is checked
        return False

    def update_suppression_for_entity(self, owner_entity_id: str) -> list[str]:
        logs: list[str] = []
        under_am = self.is_entity_under_antimagic(owner_entity_id)
        if not self.state.active_effects.get(owner_entity_id):
            return logs
        for inst in self.state.active_effects[owner_entity_id]:
            # Ex unaffected; Su/Sp/Spell suppressed in antimagic
            if inst.abilityType in ("Su", "Sp", "Spell"):
                if under_am and not inst.suppressed:
                    inst.suppressed = True
                    logs.append(f"[AMF] Suppressed {inst.name}")
                elif not under_am and inst.suppressed:
                    inst.suppressed = False
                    logs.append(f"[AMF] Unsuppressed {inst.name}")
            else:
                # Ex always unaffected
                if inst.suppressed:
                    inst.suppressed = False
        return logs

    def update_suppression_all(self) -> list[str]:
        out: list[str] = []
        # Only owner-scoped zones exist in this MVP; iterate all owners
        for owner_id in self.state.active_zones.keys():
            out += self.update_suppression_for_entity(owner_id)
        # Also update entities that might not have zones but may have suppression removed
        out += self.update_suppression_for_entity(self.state.player.id)
        return out

    def _snapshot_duration(self, zd: ZoneDefinition) -> Tuple[str, Optional[int]]:
        ds = zd.duration
        if ds is None:
            return ("permanent", None)
        if ds.type == "rounds":
            if ds.value is not None:
                return ("rounds", max(0, int(ds.value)))
            return ("rounds", None)
        return (ds.type, None)

    def create_from_definition(self, zone_id: str, owner_entity_id: str) -> Tuple[Optional[ZoneInstance], List[str]]:
        logs: List[str] = []
        zd = self.content.zones.get(zone_id)
        if not zd:
            logs.append(f"[Zone] unknown zone id: {zone_id}")
            return (None, logs)
        dur_type, rem = self._snapshot_duration(zd)
        zi = ZoneInstance(
            definition_id=zd.id,
            name=zd.name,
            owner_entity_id=owner_entity_id,
            shape=zd.shape,
            duration_type=dur_type,
            remaining_rounds=rem
        )
        self.state.active_zones.setdefault(owner_entity_id, []).append(zi)
        # Register hooks on owner's entity
        for h in zd.hooks or []:
            self.hooks._register(h, source_kind="zone", source_id=zd.id, source_name=zd.name,
                                 parent_instance_id=zi.instance_id, target_entity_id=owner_entity_id)
        logs.append(f"[Zone] Created {zd.name} ({dur_type}{f' {rem} rounds' if rem is not None else ''}) on {owner_entity_id}")
        logs += self.update_suppression_for_entity(owner_entity_id)
        return (zi, logs)

    def create_inline(self, name: str, shape: AreaSpec, duration: DurationSpec, hooks: List[RuleHook], owner_entity_id: str) -> Tuple[ZoneInstance, List[str]]:
        logs: List[str] = []
        zi = ZoneInstance(
            definition_id=None,
            name=name,
            owner_entity_id=owner_entity_id,
            shape=shape,
            duration_type=duration.type,
            remaining_rounds=duration.value if duration.type == "rounds" else None
        )
        self.state.active_zones.setdefault(owner_entity_id, []).append(zi)
        for h in hooks or []:
            self.hooks._register(h, source_kind="zone", source_id=f"zone:{name}", source_name=name,
                                 parent_instance_id=zi.instance_id, target_entity_id=owner_entity_id)
        logs.append(f"[Zone] Created {name} ({duration.type}{f' {zi.remaining_rounds} rounds' if zi.remaining_rounds is not None else ''}) on {owner_entity_id}")
        return (zi, logs)

    def destroy(self, owner_entity_id: str, *, zone_definition_id: Optional[str] = None, zone_instance_id: Optional[str] = None) -> List[str]:
        logs: List[str] = []
        lst = self.state.active_zones.get(owner_entity_id, [])
        keep: List[ZoneInstance] = []
        for zi in lst:
            match = (zone_instance_id and zi.instance_id == zone_instance_id) or (zone_definition_id and zi.definition_id == zone_definition_id)
            if match:
                self.hooks.unregister_by_parent(zi.instance_id)
                logs.append(f"[Zone] Destroyed {zi.name}")
            else:
                keep.append(zi)
        self.state.active_zones[owner_entity_id] = keep
        logs += self.update_suppression_for_entity(owner_entity_id)
        return logs

    def tick_round(self) -> List[str]:
        logs: List[str] = []
        for owner_id, lst in list(self.state.active_zones.items()):
            keep: List[ZoneInstance] = []
            for zi in lst:
                if zi.duration_type == "rounds" and zi.remaining_rounds is not None:
                    if zi.remaining_rounds > 0:
                        zi.remaining_rounds -= 1
                    if zi.remaining_rounds <= 0:
                        self.hooks.unregister_by_parent(zi.instance_id)
                        logs.append(f"[Zone] {zi.name} expired")
                        continue
                keep.append(zi)
            self.state.active_zones[owner_id] = keep
        logs += self.update_suppression_all()
        return logs
```

```
File: D:\Projects\Game Dev\D&D text RPG\src\dndrpg\engine\__init__.py

```

```
File: D:\Projects\Game Dev\D&D text RPG\src\dndrpg\tools\export_schemas.py
from __future__ import annotations
from pathlib import Path
import json
from dndrpg.engine.schema_models import (
    EffectDefinition, ConditionDefinition, ResourceDefinition, TaskDefinition, ZoneDefinition
)

def export_schemas(out_dir: Path) -> None:
    out_dir.mkdir(parents=True, exist_ok=True)
    schemas = {
        "EffectDefinition.schema.json": EffectDefinition.model_json_schema(),
        "ConditionDefinition.schema.json": ConditionDefinition.model_json_schema(),
        "ResourceDefinition.schema.json": ResourceDefinition.model_json_schema(),
        "TaskDefinition.schema.json": TaskDefinition.model_json_schema(),
        "ZoneDefinition.schema.json": ZoneDefinition.model_json_schema(),
    }
    for name, schema in schemas.items():
        (out_dir / name).write_text(json.dumps(schema, indent=2), encoding="utf-8")

if __name__ == "__main__":
    root = Path(__file__).resolve().parents[3] / "docs" / "schemas"
    export_schemas(root)
    print(f"Exported schemas to {root}")
```

```
File: D:\Projects\Game Dev\D&D text RPG\src\dndrpg\tools\validate.py
from __future__ import annotations
from pathlib import Path
import json
import re
from typing import List, Dict, Set, Literal
import yaml
import typer
from py_expression_eval import Parser
from pydantic import TypeAdapter, ValidationError
from dndrpg.engine.schema_models import (
    EffectDefinition, ConditionDefinition, ResourceDefinition, TaskDefinition, ZoneDefinition
)
from dndrpg.engine.loader import ItemAdapter, CampaignAdapter, KitAdapter
from collections import defaultdict


# Linting and error reporting
class LintCounters:
    def __init__(self):
        self.errors = 0
        self.warnings = 0

def emit_error(msg: str, counters: LintCounters):
    typer.echo(f"[ERROR] {msg}", err=True)
    counters.errors += 1

def emit_warn(msg: str, counters: LintCounters):
    typer.echo(f"[WARN] {msg}")
    counters.warnings += 1


CURRENT_SCHEMA_VERSION = "1"  # bump when schemas change incompatibly

# Allowed namespace prefixes by content group
PREFIXES = {
    "effects": {"spell.", "feat."},  # extend later as needed: "power.","maneuver.","stance.","soulmeld.","binding.","class.","race.","item.","other."
    "conditions": {"cond."},
    "resources": {"res."},
    "tasks": {"task."},
    "zones": {"zone."},
    "items": {"item.", "wp.", "ar.", "sh.", "it."},  # accept legacy 'wp./ar./sh./it.'; prefer 'item.' (warn)
    "kits": {"kit."},
    "campaigns": {"camp."},
}

def _enforce_prefix(id_value: str, group: str, strict: bool, counters: LintCounters, file_path: str):
    allowed = PREFIXES.get(group, set())
    if not allowed:
        return
    if not any(id_value.startswith(p) for p in allowed):
        emit_error(f"{file_path}: id '{id_value}' must start with one of {sorted(allowed)}", counters)
        return
    # Soft preference: items should slowly converge to 'item.' prefix
    if group == "items" and strict and not id_value.startswith("item."):
        emit_warn(f"{file_path}: id '{id_value}' uses legacy prefix; prefer 'item.'", counters)

def _check_schema_version(raw: dict, file_path: str, strict: bool, counters: LintCounters):
    sv = raw.get("schema_version", None)
    if sv is None:
        msg = f"{file_path}: missing top-level 'schema_version' (expected '{CURRENT_SCHEMA_VERSION}')"
        if strict:
            emit_error(msg, counters)
        else:
            emit_warn(msg, counters)
        return
    # normalize to string
    sv_str = str(sv)
    if sv_str != CURRENT_SCHEMA_VERSION:
        msg = f"{file_path}: schema_version '{sv_str}' != expected '{CURRENT_SCHEMA_VERSION}'"
        if strict:
            emit_error(msg, counters)
        else:
            emit_warn(msg, counters)

MIGRATIONS = {
    # Example: ("0", "1"): callable
    # ("0", "1"): migrate_0_to_1,
}

def _maybe_migrate_in_place(data: dict, src_version: str) -> dict:
    # Placeholder for future migrations
    # e.g., rename keys, move from old op shapes to typed union
    return data


# Expression validation config
ALLOWED_FUNCTIONS = {
    "min", "max", "floor", "ceil",
    "ability_mod", "level", "class_level", "caster_level", "initiator_level", "hd",
}

# Common variables used across content (expand as needed)
ALLOWED_SYMBOLS_BASE = {
    # tasks/crafting/downtime
    "item_price", "item_dc", "check_result", "progress",
    "elapsed_hours", "elapsed_minutes", "elapsed_days",
    # zones/effects
    "spell_level", "capacity",
    # ability shorthands sometimes used as variables in ability_mod(â€¦)
    "str", "dex", "con", "int", "wis", "cha",
    # generic names sometimes used in simple math snippets
    "value", "amount", "dc", "n",
}

# Keys that we treat as expressions when their value is a string
EXPR_KEYS = {
    # generic
    "formula", "amount", "value", "dc", "increment_by", "current", "initial_current", "initial",
    "targetAmount", "magnitudeExpr", "factor", "cap", "max_cl", "when",
}

_parser = Parser()

def _expr_functions(expr: str) -> set[str]:
    # Very pragmatic: find identifiers followed by '('
    return set(re.findall(r"\b([A-Za-z_][A-Za-z0-9_]*)\s*\(", expr))

def _expr_symbols(expr: str, used_funcs: set[str]) -> set[str]:
    # All identifiers; subtract function names and numeric-only tokens
    syms = set(re.findall(r"\b([A-Za-z_][A-Za-z0-9_]*)\b", expr))
    return {s for s in syms if s not in used_funcs}

def _prevalidate_expr_string(expr: str, *, strict: bool, file_path: str, field_path: str) -> list[str]:
    errors: list[str] = []
    # Parse
    try:
        _parser.parse(expr)
    except Exception as e:
        errors.append(f"{file_path}:{field_path}: invalid expression syntax: {e}")
        return errors

    funcs = _expr_functions(expr)
    unknown_funcs = funcs - ALLOWED_FUNCTIONS
    if unknown_funcs:
        errors.append(f"{file_path}:{field_path}: unknown function(s): {sorted(unknown_funcs)}; allowed: {sorted(ALLOWED_FUNCTIONS)}")

    if strict:
        # Conservative variable check: allow a common base set and snake_case names; warn on odd tokens
        syms = _expr_symbols(expr, funcs)
        # Filter out numeric-looking tokens (shouldn't be present anyway)
        syms = {s for s in syms if not re.fullmatch(r"\d+(\.\d+)?", s)}
        suspicious = set()
        for s in syms:
            if s in ALLOWED_SYMBOLS_BASE:
                continue
            # allow snake_case-ish names (authors may introduce new vars; keep strict but not hostile)
            if not re.fullmatch(r"[A-Za-z_][A-Za-z0-9_]*", s):
                suspicious.add(s)
        if suspicious:
            errors.append(f"{file_path}:{field_path}: suspicious symbol name(s): {sorted(suspicious)} "
                          f"(variables should be snake_case identifiers; functions allowed: {sorted(ALLOWED_FUNCTIONS)})")
    return errors

def _walk_exprs(data: object, *, file_path: str, prefix: str, strict: bool) -> list[str]:
    """
    Recursively walk a dict/list tree; for any key in EXPR_KEYS whose value is a str,
    parse and prevalidate the expression. Returns a list of error strings.
    """
    errs: list[str] = []
    if isinstance(data, dict):
        for k, v in data.items():
            path = f"{prefix}.{k}" if prefix else k
            if isinstance(v, str) and k in EXPR_KEYS:
                errs.extend(_prevalidate_expr_string(v, strict=strict, file_path=file_path, field_path=path))
            # Nested containers
            if isinstance(v, (dict, list)):
                errs.extend(_walk_exprs(v, file_path=file_path, prefix=path, strict=strict))
    elif isinstance(data, list):
        for idx, item in enumerate(data):
            path = f"{prefix}[{idx}]"
            errs.extend(_walk_exprs(item, file_path=file_path, prefix=path, strict=strict))
    return errs

RefCats = Literal["effect","condition","resource","zone","item","kit","campaign","task"]

def _add_ref(refmap: Dict[str, Dict[str, Set[str]]], cat: str, rid: str, file_path: str):
    if not isinstance(rid, str) or not rid:
        return
    refmap.setdefault(cat, {}).setdefault(rid, set()).add(file_path)

# Walk operations/actions in raw dicts (handles nested schedules and save branches)
def _collect_refs_from_op_dict(node: object, refmap: Dict[str, Dict[str, Set[str]]], file_path: str):
    if isinstance(node, dict):
        op = node.get("op")
        if isinstance(op, str):
            if op == "condition.apply":
                cid = node.get("id") or (node.get("params") or {}).get("id")
                _add_ref(refmap, "condition", cid, file_path)
            elif op in ("resource.create","resource.spend","resource.restore","resource.set"):
                rid = node.get("resource_id") or (node.get("params") or {}).get("resource_id")
                _add_ref(refmap, "resource", rid, file_path)
            elif op == "zone.create":
                zid = node.get("zone_id") or (node.get("params") or {}).get("zone_id")
                if zid:
                    _add_ref(refmap, "zone", zid, file_path)
            elif op == "zone.destroy":
                zid = node.get("zone_id")  # instance ids are runtime; only check definition refs
                if zid:
                    _add_ref(refmap, "zone", zid, file_path)
            elif op in ("attach","detach"):
                eid = node.get("effect_id")
                _add_ref(refmap, "effect", eid, file_path)
            elif op == "save":
                for branch_key in ("on_fail","onFail","on_success","onSuccess"):
                    for action in (node.get(branch_key) or []):
                        _collect_refs_from_op_dict(action, refmap, file_path)
            elif op == "schedule":
                for action in (node.get("actions") or []):
                    _collect_refs_from_op_dict(action, refmap, file_path)
        # Recurse into nested containers
        for v in node.values():
            if isinstance(v, (dict, list)):
                _collect_refs_from_op_dict(v, refmap, file_path)
    elif isinstance(node, list):
        for item in node:
            _collect_refs_from_op_dict(item, refmap, file_path)

def _collect_refs_from_effect(raw: dict, file_path: str, refmap: Dict[str, Dict[str, Set[str]]]):
    for op in raw.get("operations", []) or []:
        _collect_refs_from_op_dict(op, refmap, file_path)
    for hook in raw.get("ruleHooks", []) or []:
        for action in hook.get("action", []) or []:
            _collect_refs_from_op_dict(action, refmap, file_path)

def _collect_refs_from_zone(raw: dict, file_path: str, refmap: Dict[str, Dict[str, Set[str]]]):
    for hook in raw.get("hooks", []) or []:
        for action in hook.get("action", []) or []:
            _collect_refs_from_op_dict(action, refmap, file_path)

def _collect_refs_from_task(raw: dict, file_path: str, refmap: Dict[str, Dict[str, Set[str]]]):
    # Costs referencing resources
    for cost in raw.get("costs", []) or []:
        if cost.get("kind") == "resource":
            _add_ref(refmap, "resource", cost.get("resource_id"), file_path)
    # Hooks/actions
    for hook in raw.get("hooks", []) or []:
        for action in hook.get("action", []) or []:
            _collect_refs_from_op_dict(action, refmap, file_path)
    # Completion actions
    comp = raw.get("completion") or {}
    for action in comp.get("actions", []) or []:
        _collect_refs_from_op_dict(action, refmap, file_path)

def _collect_refs_from_kit(raw: dict, file_path: str, refmap: Dict[str, Dict[str, Set[str]]]):
    for iid in raw.get("items", []) or []:
        _add_ref(refmap, "item", iid, file_path)
    for slot, iid in (raw.get("auto_equip") or {}).items():
        if isinstance(iid, str):
            _add_ref(refmap, "item", iid, file_path)

def _collect_refs_from_campaign(raw: dict, file_path: str, refmap: Dict[str, Dict[str, Set[str]]]):
    packs = raw.get("starting_equipment_packs") or {}
    for _cls, kit_ids in packs.items():
        for kid in kit_ids or []:
            _add_ref(refmap, "kit", kid, file_path)

app = typer.Typer(add_completion=False)

def _load(path: Path) -> dict:
    text = path.read_text(encoding="utf-8")
    if path.suffix.lower() in (".yaml", ".yml"):
        return yaml.safe_load(text) or {}
    return json.loads(text)

def _iter(root: Path, exts=(".json",".yaml",".yml")):
    if not root.exists():
        return
    for p in root.rglob("*"):
        if p.is_file() and p.suffix.lower() in exts:
            yield p

@app.command("export-schemas")
def export_schemas_cmd(out: Path = typer.Option(Path("docs/schemas"), "--out")):
    from dndrpg.tools.export_schemas import export_schemas
    export_schemas(out)
    typer.echo(f"Exported schemas to {out}")

@app.command("validate-content")
def validate_content(
    content_dir: Path = typer.Argument(Path("src/dndrpg/content")),
    strict: bool = typer.Option(False, "--strict", help="Strict mode: schema + strict expressions + cross-refs + id policy + version; warnings do not fail"),
    warn_unused: bool = typer.Option(False, "--warn-unused", help="Also warn on unused ids (implied by --strict)")
):
    strict_expr = strict
    if strict:
        warn_unused = True

    counters = LintCounters()
    groups = [
        ("effects", TypeAdapter(EffectDefinition)),
        ("conditions", TypeAdapter(ConditionDefinition)),
        ("resources", TypeAdapter(ResourceDefinition)),
        ("tasks", TypeAdapter(TaskDefinition)),
        ("zones", TypeAdapter(ZoneDefinition)),
        ("items", ItemAdapter),
        ("kits", KitAdapter),
        ("campaigns", CampaignAdapter),
    ]

    parsed: dict[str, list] = {k: [] for k, _ in groups}
    total_files = 0

    # 1) Per-file typing + expr + id prefix + schema_version
    for sub, adapter in groups:
        folder = content_dir / sub
        if not folder.exists():
            continue
        for fp in _iter(folder):
            total_files += 1
            data = _load(fp)
            # id prefix and schema_version checks happen regardless of schema pass/fail (give more feedback)
            rid = data.get("id")
            if isinstance(rid, str):
                _enforce_prefix(rid, sub, strict, counters, str(fp))
            _check_schema_version(data, str(fp), strict, counters)

            # Migration hook (if implemented)
            sv_raw = data.get("schema_version")
            if sv_raw is not None and str(sv_raw) != CURRENT_SCHEMA_VERSION:
                data = _maybe_migrate_in_place(data, str(sv_raw))

            # Migration hook (if implemented)
            sv_raw = data.get("schema_version")
            if sv_raw is not None and str(sv_raw) != CURRENT_SCHEMA_VERSION:
                data = _maybe_migrate_in_place(data, str(sv_raw))

            # schema typing
            try:
                obj = adapter.validate_python(data)
                parsed[sub].append((fp, obj, data))
            except ValidationError as e:
                emit_error(f"{fp}: {e}", counters)
                continue

            # expressions
            expr_errs = _walk_exprs(data, file_path=str(fp), prefix=sub, strict=strict_expr)
            for msg in expr_errs:
                emit_error(msg, counters)

    # 2) Cross-refs (as in your previous step)
    defined: dict[str, set[str]] = {
        "effect": {getattr(o, "id") for _, o, _ in parsed["effects"]},
        "condition": {getattr(o, "id") for _, o, _ in parsed["conditions"]},
        "resource": {getattr(o, "id") for _, o, _ in parsed["resources"]},
        "zone": {getattr(o, "id") for _, o, _ in parsed["zones"]},
        "task": {getattr(o, "id") for _, o, _ in parsed["tasks"]},
        "item": {getattr(o, "id") for _, o, _ in parsed["items"]},
        "kit": {getattr(o, "id") for _, o, _ in parsed["kits"]},
        "campaign": {getattr(o, "id") for _, o, _ in parsed["campaigns"]},
    }
    refs: dict[str, dict[str, set[str]]] = defaultdict(lambda: defaultdict(set))

    for fp, _o, raw in parsed["effects"]:
        _collect_refs_from_effect(raw, str(fp), refs)
    for fp, _o, raw in parsed["zones"]:
        _collect_refs_from_zone(raw, str(fp), refs)
    for fp, _o, raw in parsed["tasks"]:
        _collect_refs_from_task(raw, str(fp), refs)
    for fp, _o, raw in parsed["kits"]:
        _collect_refs_from_kit(raw, str(fp), refs)
    for fp, _o, raw in parsed["campaigns"]:
        _collect_refs_from_campaign(raw, str(fp), refs)

    def _report_missing(cat: str):
        used = refs.get(cat, {})
        missing = set(used.keys()) - defined.get(cat, set())
        for mid in sorted(missing):
            locs = ", ".join(sorted(used[mid]))
            emit_error(f"Missing {cat} id '{mid}' referenced from: {locs}", counters)

    for cat in ("condition","resource","zone","effect","item","kit"):
        _report_missing(cat)

    # Unused warnings
    if warn_unused:
        for cat in ("effect","condition","resource","zone","item","kit","campaign","task"):
            defined_set = defined.get(cat, set())
            used_set = set(refs.get(cat, {}).keys())
            for uid in sorted(defined_set - used_set):
                emit_warn(f"Unused {cat} id: {uid}", counters)

    # 3) Cross-file checks: condition precedence uniqueness
    precedences: dict[int, list[str]] = {}
    for fp, cond, _raw in parsed.get("conditions", []):
        prec = getattr(cond, "precedence", None)
        if prec is None:
            continue
        precedences.setdefault(prec, []).append(getattr(cond, "id", str(fp)))
    for p, ids in precedences.items():
        if len(ids) > 1:
            emit_error(f"Condition precedence '{p}' is used by multiple conditions: {', '.join(ids)}", counters)

    # 4) Summary / exit code
    typer.echo(f"Validated {total_files} content files â€” {counters.errors} error(s), {counters.warnings} warning(s).")
    if counters.errors > 0:
        raise typer.Exit(code=1)

# Map a file path to its adapter based on subfolder
TYPE_MAP = {
    "effects": TypeAdapter(EffectDefinition),
    "conditions": TypeAdapter(ConditionDefinition),
    "resources": TypeAdapter(ResourceDefinition),
    "tasks": TypeAdapter(TaskDefinition),
    "zones": TypeAdapter(ZoneDefinition),
}

def _which_adapter(path: Path) -> TypeAdapter | None:
    # Expect content/<kind>/... paths
    parts = path.as_posix().split("/")
    try:
        idx = parts.index("content")
        kind = parts[idx + 1]
    except Exception:
        return None
    return TYPE_MAP.get(kind)

@app.command("validate-files")
def validate_files(
    paths: List[Path] = typer.Argument(...),
    strict_expr: bool = typer.Option(False, "--strict-expr", help="Disallow unknown functions and suspicious symbols in expressions")
):
    ok = True
    for fp in paths:
        if fp.suffix.lower() not in (".json", ".yaml", ".yml"):
            continue
        data = _load(fp)
        adapter = _which_adapter(fp)
        if adapter is None:
            continue
        try:
            adapter.validate_python(data)
        except ValidationError as e:
            ok = False
            typer.echo(f"[ERROR] {fp}: {e}", err=True)
            continue
        # Expression prevalidation
        expr_errs = _walk_exprs(data, file_path=str(fp), prefix=fp.as_posix(), strict=strict_expr)
        if expr_errs:
            ok = False
            for msg in expr_errs:
                typer.echo(f"[ERROR] {msg}", err=True)

    if not ok:
        raise typer.Exit(code=1)
    typer.echo("Selected files validated successfully.")

if __name__ == "__main__":
    app()
```

```
File: D:\Projects\Game Dev\D&D text RPG\src\dndrpg\ui\chargen\base.py
from __future__ import annotations
from textual.screen import Screen
from dndrpg.engine.chargen import CharBuildState

class CharGenState:
    def __init__(self):
        self.picks = CharBuildState()

class StepBase(Screen):
    def __init__(self, app_ref):
        super().__init__()
        self.app_ref = app_ref  # DnDApp
```

```
File: D:\Projects\Game Dev\D&D text RPG\src\dndrpg\ui\chargen\step_ability.py
from __future__ import annotations
from textual.widgets import Button, Input, Label, Select, Static
from textual.containers import Vertical, Horizontal
from textual import on

from dndrpg.engine.chargen_helpers import STANDARD_ARRAYS, generate_4d6

from .base import StepBase
from .step_race_class import StepRaceClass

class StepAbility(StepBase):
    def _point_cost(self, score: int) -> int:
        # 3.5 point-buy costs (8=0, 9=1, 10=2, 11=3, 12=4, 13=5, 14=6, 15=8, 16=10, 17:13, 18:16)
        table = {8:0,9:1,10:2,11:3,12:4,13:5,14:6,15:8,16:10,17:13,18:16}
        if score < 8 or score > 18:
            return 0
        return table.get(score, 0)

    def _validate_pb(self, vals: dict) -> tuple[bool, str]:
        try:
            scores = {k:int(v) for k,v in vals.items()}
        except ValueError:
            return (False, "All abilities must be integers.")
        if min(scores.values()) < 8 or max(scores.values()) > 18:
            return (False, "Scores must be between 8 and 18.")
        total = sum(self._point_cost(s) for s in scores.values())
        campaign_pb_limit = self.app_ref.engine.campaign.houserules.point_buy
        if total > campaign_pb_limit:
            return (False, f"Point-buy exceeds {campaign_pb_limit} (used {total}).")
        return (True, f"Point-buy OK (used {total}/{campaign_pb_limit}).")

    def compose(self):
        yield Vertical(
            Label("Ability Scores"),
            Label("Method:"),
            Select(options=[("Point Buy (28)","point_buy"),
                            ("Standard Array (15,14,13,12,10,8)","standard"),
                            ("4d6 drop lowest (random)","4d6")], id="method"),
            # Point-buy inputs
            Horizontal(
                Input(placeholder="STR", id="pb_str", classes="pb_input"),
                Input(placeholder="DEX", id="pb_dex", classes="pb_input"),
                Input(placeholder="CON", id="pb_con", classes="pb_input")
            ),
            Horizontal(
                Input(placeholder="INT", id="pb_int", classes="pb_input"),
                Input(placeholder="WIS", id="pb_wis", classes="pb_wis"),
                Input(placeholder="CHA", id="pb_cha", classes="pb_cha")
            ),
            # Standard array/Scores generated â†’ user chooses assignment order
            Label("Assignment order (comma-separated, e.g., str,dex,con,int,wis,cha):", id="assign_label"),
            Input(placeholder="str,dex,con,int,wis,cha", id="assign_input"),
            Button("Generate (4d6)", id="gen4d6_button"),
            Static("", id="scores_display"),
            Button("Next", id="next"), Button("Back", id="back")
        )

    def on_mount(self):
        self._update_ui_visibility("point_buy")

    @on(Select.Changed, "#method")
    def on_method_changed(self, event: Select.Changed):
        self._update_ui_visibility(event.value)

    def _update_ui_visibility(self, method: str):
        is_point_buy = method == "point_buy"
        is_4d6 = method == "4d6"

        for input_widget in self.query(".pb_input"):
            input_widget.display = is_point_buy

        self.query_one("#assign_label").display = not is_point_buy
        self.query_one("#assign_input").display = not is_point_buy
        self.query_one("#gen4d6_button").display = is_4d6
        self.query_one("#scores_display").display = is_4d6

    def on_button_pressed(self, ev):
        method = self.query_one("#method", Select).value or "point_buy"
        if ev.button.id == "gen4d6_button" and method == "4d6":
            scores = generate_4d6(self.app_ref.engine.rng)
            self.query_one("#scores_display", Static).update(f"Rolled scores: {scores} (assign in the order field)")
            return
        if ev.button.id == "next":
            if method == "point_buy":
                vals = {
                    "str": int(self.query_one("#pb_str", Input).value or 15),
                    "dex": int(self.query_one("#pb_dex", Input).value or 12),
                    "con": int(self.query_one("#pb_con", Input).value or 14),
                    "int": int(self.query_one("#pb_int", Input).value or 10),
                    "wis": int(self.query_one("#pb_wis", Input).value or 12),
                    "cha": int(self.query_one("#pb_cha", Input).value or 8),
                }
                ok, msg = self._validate_pb(vals)
                if not ok:
                    print(f"[CharGen] {msg}")
                    return
                self.app_ref.cg_state.picks.abilities = vals
            elif method == "standard":
                arr = STANDARD_ARRAYS["classic"]
                order_str = self.query_one("#assign_input", Input).value
                if not order_str:
                    print("[CharGen] Please provide an assignment order (e.g., str,dex,con,int,wis,cha).")
                    return
                order = [a.strip().lower() for a in order_str.split(",")]
                if len(order) != 6 or len(set(order)) != 6 or not all(ab in ["str", "dex", "con", "int", "wis", "cha"] for ab in order):
                    print("[CharGen] Invalid assignment order. Must be 6 unique abilities (str,dex,con,int,wis,cha).")
                    return
                self.app_ref.cg_state.picks.abilities = dict(zip(order, arr))
            else:  # 4d6
                text = self.query_one("#scores_display", Static).renderable
                if not text:
                    print("[CharGen] Generate scores first, then assign.")
                    return
                import re
                m = re.search(r"\[(.*?)\]", str(text))
                scores = [int(x) for x in m.group(1).split(",")] if m else []
                if not scores or len(scores) != 6: # Ensure 6 scores are present
                    print("[CharGen] No valid scores generated or not enough scores. Click 'Generate (4d6)' first.")
                    return

                order_str = self.query_one("#assign_input", Input).value
                if not order_str:
                    print("[CharGen] Please provide an assignment order (e.g., str,dex,con,int,wis,cha).")
                    return
                order = [a.strip().lower() for a in order_str.split(",")]
                if len(order) != 6 or len(set(order)) != 6 or not all(ab in ["str", "dex", "con", "int", "wis", "cha"] for ab in order):
                    print("[CharGen] Invalid assignment order. Must be 6 unique abilities (str,dex,con,int,wis,cha).")
                    return
                self.app_ref.cg_state.picks.abilities = dict(zip(order, scores))

            self.app_ref.push_screen(StepRaceClass(self.app_ref))
        elif ev.button.id == "back":
            self.app_ref.pop_screen()
```

```
File: D:\Projects\Game Dev\D&D text RPG\src\dndrpg\ui\chargen\step_deity_domains.py
from __future__ import annotations
import copy # Import the copy module
from textual.widgets import Button, Label, Select
from textual.containers import Vertical

from dndrpg.engine.chargen import validate_character_picks # Import the validation function
from .base import StepBase
from .step_skills import StepSkills

class StepDeityDomains(StepBase):
    def compose(self):
        picks = self.app_ref.cg_state.picks
        if picks.clazz != "cleric":
            # skip for non-cleric
            self.app_ref.push_screen(StepSkills(self.app_ref))
            return
        
        # Get available deities and format for Select widget
        deity_options = [("None", None)]
        deity_options.extend(sorted([(d.name, d.id) for d in self.app_ref.engine.content.deities.values()], key=lambda x: x[0]))

        # Simplify: list domains from content effects with id prefix "domain."
        domains = [eid for eid, eff in self.app_ref.engine.content.effects.items() if eid.startswith("domain.")]
        domain_options = [(d.split(".")[1].title(), d) for d in domains]  # name only, but value is full ID
        yield Vertical(
            Label("Deity (optional):"), Select(options=deity_options, id="deity_select", value=None),
            Label("Pick two domains:"), Select(options=domain_options, id="dom1"), Select(options=domain_options, id="dom2"),
            Label("", id="message_label", classes="error"), # Added message label
            Button("Next", id="next"), Button("Back", id="back")
        )
    def on_button_pressed(self, ev):
        if ev.button.id == "back":
            self.app_ref.pop_screen()
        if ev.button.id == "next":
            # Clear previous messages
            self.query_one("#message_label", Label).update("")

            deity_id = self.query_one("#deity_select", Select).value
            self.app_ref.cg_state.picks.deity = deity_id

            d1 = self.query_one("#dom1", Select).value
            d2 = self.query_one("#dom2", Select).value

            if self.app_ref.cg_state.picks.clazz == "cleric":
                if not deity_id:
                    self.query_one("#message_label", Label).update("[CharGen] Clerics must select a deity.")
                    return
                if not d1 or not d2 or d1 == d2:
                    self.query_one("#message_label", Label).update("[CharGen] Pick two distinct domains.")
                    return
                
                # Perform validation using the engine's function
                temp_picks = copy.deepcopy(self.app_ref.cg_state.picks) # Create a deep copy to test validation
                temp_picks.deity = deity_id
                temp_picks.domains = [d1, d2]

                is_valid, validation_message = validate_character_picks(self.app_ref.engine.content, temp_picks)
                
                if not is_valid:
                    self.query_one("#message_label", Label).update(f"[CharGen] {validation_message}")
                    return
            
            self.app_ref.cg_state.picks.domains = [d1, d2]
            self.app_ref.push_screen(StepSkills(self.app_ref))
```

```
File: D:\Projects\Game Dev\D&D text RPG\src\dndrpg\ui\chargen\step_feats.py
from __future__ import annotations
from textual.widgets import Button, Input, Label, Static, Checkbox, Select
from textual.containers import Vertical
from textual import on

from dndrpg.engine.prereq import eval_prereq, BuildView

from .base import StepBase
from .step_spells import StepSpells

class StepFeats(StepBase):
    def compose(self):
        feats_container = Vertical(id="feats_container")
        yield Vertical(
            Label("Feats"),
            feats_container,
            Button("Next", id="next"), Button("Back", id="back")
        )

    def on_mount(self):
        self._load_and_display_feats()

    def _load_and_display_feats(self):
        feats_container = self.query_one("#feats_container", Vertical)
        feats_container.remove_children() # Clear existing content

        available_feats = []
        # Assuming feats are effects with id starting with "feat."
        for feat_id, feat_def in self.app_ref.engine.content.effects.items():
            if feat_id.startswith("feat."):
                available_feats.append(feat_def)

        if not available_feats:
            feats_container.mount(Label("No feats available."))
            return

        # Create a BuildView for prerequisite evaluation
        import dataclasses
        picks = self.app_ref.cg_state.picks
        build_view = BuildView(entity=None, picks=dataclasses.asdict(picks))

        for feat_def in available_feats:
            # Display feat name and description
            feats_container.mount(Label(f"[b]{feat_def.name}[/b]"))
            if feat_def.notes:
                feats_container.mount(Label(feat_def.notes))
            feats_container.mount(Label(feat_def.description))

            # Prerequisite checking
            can_take_feat = True
            prereq_msg = ""
            if feat_def.prerequisites:
                can_take_feat = eval_prereq(feat_def.prerequisites, build_view)
                prereq_msg = feat_def.prerequisites

            checkbox_id = f"feat_checkbox_{feat_def.id}"
            checkbox = Checkbox(
                f"Select {feat_def.name}",
                id=checkbox_id,
                classes="feat_checkbox",
                disabled=not can_take_feat
            )
            feats_container.mount(checkbox)

            if not can_take_feat:
                feats_container.mount(Label(f"[i]Prerequisites not met: {prereq_msg}[/i]", classes="prereq_error"))
            
            # Check if the feat is already selected (e.g., from a previous step or if returning to this screen)
            if feat_def.id in picks.feats:
                checkbox.value = True

            # Handle feat choices
            if feat_def.choices:
                for choice in feat_def.choices:
                    choice_id = f"feat_choice_{feat_def.id}_{choice.id}"
                    feats_container.mount(Label(f"  {choice.name}:"))
                    if choice.type == "text":
                        input_widget = Input(
                            placeholder=choice.placeholder or "",
                            id=choice_id,
                            classes="feat_choice_input"
                        )
                        feats_container.mount(input_widget)
                        # Restore previous choice if available
                        if feat_def.id in picks.feat_choices and choice.id in picks.feat_choices[feat_def.id]:
                            input_widget.value = picks.feat_choices[feat_def.id][choice.id]
                    elif choice.type == "select":
                        select_options = [(opt.label, opt.value) for opt in choice.options]
                        select_widget = Select(
                            options=select_options,
                            id=choice_id,
                            classes="feat_choice_select"
                        )
                        feats_container.mount(select_widget)
                        # Restore previous choice if available
                        if feat_def.id in picks.feat_choices and choice.id in picks.feat_choices[feat_def.id]:
                            select_widget.value = picks.feat_choices[feat_def.id][choice.id]
            feats_container.mount(Static("")) # Spacer

    @on(Checkbox.Changed, ".feat_checkbox")
    def on_feat_checkbox_changed(self, event: Checkbox.Changed):
        feat_id = event.widget.id.replace("feat_checkbox_", "")
        if event.value: # Checkbox is checked
            self.app_ref.cg_state.picks.feats.add(feat_id)
        else: # Checkbox is unchecked
            self.app_ref.cg_state.picks.feats.discard(feat_id)
        self.app_ref.log_panel.push(f"Selected feats: {sorted(list(self.app_ref.cg_state.picks.feats))}")

    @on(Input.Changed, ".feat_choice_input")
    def on_feat_choice_input_changed(self, event: Input.Changed):
        parts = event.widget.id.split("_")
        # Assuming ID format: feat_choice_feat.id_choice.id
        # This needs to be robust for different feat_id formats (e.g., feat.power_attack)
        # A better way might be to store feat_id and choice_id in data attributes of the widget
        # For now, let's assume feat_id is always two parts separated by a dot.
        feat_id_parts = parts[2:-1] # Get all parts between "feat_choice_" and "_choice.id"
        feat_id = ".".join(feat_id_parts)
        choice_id = parts[-1]
        
        if feat_id not in self.app_ref.cg_state.picks.feat_choices:
            self.app_ref.cg_state.picks.feat_choices[feat_id] = {}
        self.app_ref.cg_state.picks.feat_choices[feat_id][choice_id] = event.value
        self.app_ref.log_panel.push(f"Feat choice for {feat_id} ({choice_id}): {event.value}")

    @on(Select.Changed, ".feat_choice_select")
    def on_feat_choice_select_changed(self, event: Select.Changed):
        parts = event.widget.id.split("_")
        # Assuming ID format: feat_choice_feat.id_choice.id
        feat_id_parts = parts[2:-1]
        feat_id = ".".join(feat_id_parts)
        choice_id = parts[-1]

        if feat_id not in self.app_ref.cg_state.picks.feat_choices:
            self.app_ref.cg_state.picks.feat_choices[feat_id] = {}
        self.app_ref.cg_state.picks.feat_choices[feat_id][choice_id] = event.value
        self.app_ref.log_panel.push(f"Feat choice for {feat_id} ({choice_id}): {event.value}")
         
    def on_button_pressed(self, ev):
        if ev.button.id == "next":
            # Prerequisite validation
            picks = self.app_ref.cg_state.picks
            import dataclasses
            build_view = BuildView(entity=None, picks=dataclasses.asdict(picks))

            all_feats_valid = True
            for feat_id in picks.feats:
                feat_def = self.app_ref.engine.content.effects.get(feat_id)
                if feat_def and feat_def.prerequisites:
                    if not eval_prereq(feat_def.prerequisites, build_view):
                        self.app_ref.log_panel.push(f"[CharGen] Prerequisite not met for {feat_def.name}: {feat_def.prerequisites}")
                        all_feats_valid = False
            
            if not all_feats_valid:
                return # Stop if any feat is invalid

            self.app_ref.push_screen(StepSpells(self.app_ref))
        elif ev.button.id == "back":
            self.app_ref.pop_screen()
```

```
File: D:\Projects\Game Dev\D&D text RPG\src\dndrpg\ui\chargen\step_kits.py
from __future__ import annotations
from textual.widgets import Button, Label, Select
from textual.containers import Vertical

from dndrpg.engine.chargen import build_entity_from_state

from .base import StepBase

class StepKits(StepBase):
    def compose(self):
        # show class kits from campaign
        kits = self.app_ref.engine.campaign.starting_equipment_packs.get(self.app_ref.cg_state.picks.clazz, [])
        opts = [(k, k) for k in kits] if kits else [("None","none")]
        yield Vertical(
            Label("Starting Kit"),
            Select(options=opts, id="kit"),
            Label("", id="message_label", classes="error"), # Added message label
            Button("Finish", id="finish"), Button("Back", id="back")
        )
    def on_button_pressed(self, ev):
        if ev.button.id == "finish":
            sel = self.query_one("#kit", Select).value
            if sel and sel != "none":
                kit = self.app_ref.engine.content.kits[sel]
                self.app_ref.cg_state.picks.gear_ids = list(kit.items)
            
            # Clear previous messages
            self.query_one("#message_label", Label).update("")

            # Build entity
            entity, error_message = build_entity_from_state(self.app_ref.engine.content, self.app_ref.engine.state, self.app_ref.cg_state.picks,
                                    self.app_ref.engine.effects, self.app_ref.engine.resources,
                                    self.app_ref.engine.conditions, self.app_ref.engine.hooks)
            
            if entity is None:
                self.query_one("#message_label", Label).update(f"[CharGen] {error_message}")
                return

            # Start new game with the built entity
            self.app_ref.engine.start_new_game(
                self.app_ref.engine.content.campaigns[next(iter(self.app_ref.engine.content.campaigns))].id, # Use the first campaign ID
                self.app_ref.engine.state.player, # The entity is already set in state.player by build_entity_from_state
                slot_id="slot1" # Or allow user to pick slot
            )

            self.app_ref.log_panel.push("Character created. Entering exploration.") # Use log_panel
            
            # Pop all chargen screens to return to the main game UI
            num_chargen_screens = 0
            for screen in reversed(self.app_ref._screen_stack):
                if isinstance(screen, StepBase):
                    num_chargen_screens += 1
            
            for _ in range(num_chargen_screens):
                self.app_ref.pop_screen()
            
            # Also pop CampaignSelectScreen and TitleScreen
            self.app_ref.pop_screen()
            self.app_ref.pop_screen()
            
            self.app_ref.refresh_all() # Refresh main game UI
        elif ev.button.id == "back":
            self.app_ref.pop_screen()
```

```
File: D:\Projects\Game Dev\D&D text RPG\src\dndrpg\ui\chargen\step_name_alignment.py
from __future__ import annotations
from textual.widgets import Button, Input, Label, Select
from textual.containers import Vertical

from .base import StepBase
from .step_ability import StepAbility

class StepNameAlignment(StepBase):
    def compose(self):
        yield Vertical(
            Label("Name & Alignment"),
            Input(placeholder="Name", id="name"),
            Select(options=[(a,a) for a in ("lawful good","neutral good","chaotic good","lawful neutral","neutral","chaotic neutral","lawful evil","neutral evil","chaotic evil")], id="alignment"),
            Button("Next", id="next")
        )
    def on_button_pressed(self, ev):
        if ev.button.id == "next":
            name = self.query_one("#name", Input).value or "Hero"
            alig = self.query_one("#alignment", Select).value or "neutral"
            self.app_ref.cg_state.picks.name = name
            self.app_ref.cg_state.picks.alignment = alig
            self.app_ref.push_screen(StepAbility(self.app_ref))
```

```
File: D:\Projects\Game Dev\D&D text RPG\src\dndrpg\ui\chargen\step_race_class.py
from __future__ import annotations
from textual.widgets import Button, Label, Select
from textual.containers import Vertical

from .base import StepBase
from .step_deity_domains import StepDeityDomains
from .step_skills import StepSkills

class StepRaceClass(StepBase):
    def compose(self):
        yield Vertical(
            Label("Race & Class"),
            Select(options=[("Human","human"),("Dwarf","dwarf"),("Elf","elf")], id="race"),
            Select(options=[("Fighter","fighter"),("Cleric","cleric"),("Sorcerer","sorcerer"),("Monk","monk")], id="class"),
            Button("Next", id="next"), Button("Back", id="back")
        )
    def on_button_pressed(self, ev):
        if ev.button.id == "next":
            race = self.query_one("#race", Select).value or "human"
            clazz = self.query_one("#class", Select).value or "fighter"
            self.app_ref.cg_state.picks.race = race
            self.app_ref.cg_state.picks.clazz = clazz
            if clazz == "cleric":
                self.app_ref.push_screen(StepDeityDomains(self.app_ref))
            else:
                self.app_ref.push_screen(StepSkills(self.app_ref))
        elif ev.button.id == "back":
            self.app_ref.pop_screen()
```

```
File: D:\Projects\Game Dev\D&D text RPG\src\dndrpg\ui\chargen\step_skills.py
from __future__ import annotations
from textual.widgets import Button, Input, Label, Static
from textual.containers import Vertical, Horizontal, ScrollableContainer
from textual import on # Import on decorator
from textual import events # Import events for focus handling

from dndrpg.engine.skills import skill_points_at_level1, max_ranks, CLASS_SKILLS

from .base import StepBase
from .step_feats import StepFeats

class StepSkills(StepBase):
    def compose(self):
        yield Vertical(
            Label("Skills"),
            Static("Skill Points Available: 0", id="skill_points_display"),
            Static("Remaining: 0", id="skill_points_remaining"),
            Label("", id="skill_message_label", classes="error"), # Added message label
            ScrollableContainer(
                Horizontal(
                    Vertical(
                        Label("Appraise:"), Input(placeholder="0", id="skill_appraise", classes="skill_input"),
                        Label("Autohypnosis:"), Input(placeholder="0", id="skill_autohypnosis", classes="skill_input"),
                        Label("Balance:"), Input(placeholder="0", id="skill_balance", classes="skill_input"),
                        Label("Bluff:"), Input(placeholder="0", id="skill_bluff", classes="skill_input"),
                        Label("Climb:"), Input(placeholder="0", id="skill_climb", classes="skill_input"),
                        Label("Concentration:"), Input(placeholder="0", id="skill_concentration", classes="skill_input"),
                        Label("Control Shape:"), Input(placeholder="0", id="skill_control_shape", classes="skill_input"),
                        Label("Craft:"), Input(placeholder="0", id="skill_craft", classes="skill_input"),
                        Label("Decipher Script:"), Input(placeholder="0", id="skill_decipher_script", classes="skill_input"),
                        Label("Diplomacy:"), Input(placeholder="0", id="skill_diplomacy", classes="skill_input"),
                        Label("Disable Device:"), Input(placeholder="0", id="skill_disable_device", classes="skill_input"),
                        Label("Disguise:"), Input(placeholder="0", id="skill_disguise", classes="skill_input"),
                        Label("Escape Artist:"), Input(placeholder="0", id="skill_escape_artist", classes="skill_input"),
                        Label("Forgery:"), Input(placeholder="0", id="skill_forgery", classes="skill_input"),
                        Label("Gather Information:"), Input(placeholder="0", id="skill_gather_information", classes="skill_input"),
                        Label("Handle Animal:"), Input(placeholder="0", id="skill_handle_animal", classes="skill_input"),
                        Label("Heal:"), Input(placeholder="0", id="skill_heal", classes="skill_input"),
                        Label("Hide:"), Input(placeholder="0", id="skill_hide", classes="skill_input"),
                        Label("Intimidate:"), Input(placeholder="0", id="skill_intimidate", classes="skill_input"),
                        Label("Jump:"), Input(placeholder="0", id="skill_jump", classes="skill_input"),
                        Label("Knowledge:"), Input(placeholder="0", id="skill_knowledge", classes="skill_input"),
                        Label("Listen:"), Input(placeholder="0", id="skill_listen", classes="skill_input"),
                        Label("Martial Lore:"), Input(placeholder="0", id="skill_martial_lore", classes="skill_input"),
                    ),
                    Vertical(
                        Label("Move Silently:"), Input(placeholder="0", id="skill_move_silently", classes="skill_input"),
                        Label("Open Lock:"), Input(placeholder="0", id="skill_open_lock", classes="skill_input"),
                        Label("Perform:"), Input(placeholder="0", id="skill_perform", classes="skill_input"),
                        Label("Profession:"), Input(placeholder="0", id="skill_profession", classes="skill_input"),
                        Label("Psicraft:"), Input(placeholder="0", id="skill_psicraft", classes="skill_input"),
                        Label("Ride:"), Input(placeholder="0", id="skill_ride", classes="skill_input"),
                        Label("Search:"), Input(placeholder="0", id="skill_search", classes="skill_input"),
                        Label("Sense Motive:"), Input(placeholder="0", id="skill_sense_motive", classes="skill_input"),
                        Label("Sleight of Hand:"), Input(placeholder="0", id="skill_sleight_of_hand", classes="skill_input"),
                        Label("Speak Language:"), Input(placeholder="0", id="skill_speak_language", classes="skill_input"),
                        Label("Spellcraft:"), Input(placeholder="0", id="skill_spellcraft", classes="skill_input"),
                        Label("Spot:"), Input(placeholder="0", id="skill_spot", classes="skill_input"),
                        Label("Survival:"), Input(placeholder="0", id="skill_survival", classes="skill_input"),
                        Label("Swim:"), Input(placeholder="0", id="skill_swim", classes="skill_input"),
                        Label("Truespeak:"), Input(placeholder="0", id="skill_truespeak", classes="skill_input"),
                        Label("Tumble:"), Input(placeholder="0", id="skill_tumble", classes="skill_input"),
                        Label("Use Magic Device:"), Input(placeholder="0", id="skill_use_magic_device", classes="skill_input"),
                        Label("Use Psionic Device:"), Input(placeholder="0", id="skill_use_psionic_device", classes="skill_input"),
                        Label("Use Rope:"), Input(placeholder="0", id="skill_use_rope", classes="skill_input"),
                    )
                ),
                classes="skill_scroll_container" # Added class for CSS
            ),
            Button("Next", id="next"), Button("Back", id="back")
        )

    def on_mount(self):
        self._update_skill_points()

    @on(Input.Changed, ".skill_input")
    def on_skill_input_changed(self, event: Input.Changed):
        # Clear previous messages
        self.query_one("#skill_message_label", Label).update("")
        self.app_ref.log_panel.push(f"[CharGen] Skill input changed: {event.control.id} value: {event.value}")
        self._update_skill_points()

    def _update_skill_points(self):
        picks = self.app_ref.cg_state.picks
        # For initial calculation, we need a dummy entity to get INT mod
        # This is a simplification; a proper solution would pass the current ability scores
        # or calculate them based on picks.abilities
        temp_int_score = picks.abilities.get("int", 10) # Default to 10 if not set yet
        temp_int_mod = (temp_int_score - 10) // 2

        total_skill_points = skill_points_at_level1(picks.clazz, temp_int_mod, picks.race == "human")
        self.query_one("#skill_points_display", Static).update(f"Skill Points Available: {total_skill_points}")

        allocated_points = 0
        current_skills = {}
        for skill_input in self.query(".skill_input"):
            skill_name = skill_input.id.replace("skill_", "")
            try:
                ranks = int(skill_input.value or 0)
                if ranks < 0:
                    ranks = 0
                    skill_input.value = "0" # Reset invalid input
                    self.query_one("#skill_message_label", Label).update(f"[CharGen] {skill_name.title()} ranks cannot be negative. Reset to 0.")
                
                # Validate max ranks
                is_class_skill = skill_name in CLASS_SKILLS.get(picks.clazz, [])
                max_allowed_ranks = max_ranks(1, is_class_skill) # Assuming level 1

                if ranks > max_allowed_ranks:
                    self.query_one("#skill_message_label", Label).update(f"[CharGen] {skill_name.title()} ranks cannot exceed {max_allowed_ranks}. Reset to {max_allowed_ranks}.")
                    ranks = max_allowed_ranks
                    skill_input.value = str(ranks) # Correct invalid input

                current_skills[skill_name] = ranks
                allocated_points += ranks
            except ValueError:
                self.query_one("#skill_message_label", Label).update(f"[CharGen] Invalid input for {skill_name.title()} ranks. Please enter a number. Reset to 0.")
                skill_input.value = "0" # Reset invalid input
                current_skills[skill_name] = 0

        picks.skills = current_skills
        remaining_points = total_skill_points - allocated_points
        self.query_one("#skill_points_remaining", Static).update(f"Remaining: {remaining_points}")

        if remaining_points < 0:
            self.query_one("#skill_points_remaining", Static).add_class("error")
            self.query_one("#skill_message_label", Label).update(f"[CharGen] You have allocated {abs(remaining_points)} too many skill points!")
        else:
            self.query_one("#skill_points_remaining", Static).remove_class("error")
            # Clear message if everything is valid
            if not self.query_one("#skill_message_label", Label).has_class("error"): # Only clear if no other error is present
                self.query_one("#skill_message_label", Label).update("")

    def on_button_pressed(self, ev):
        if ev.button.id == "next":
            # Clear previous messages
            self.query_one("#skill_message_label", Label).update("")

            # Final validation before proceeding
            picks = self.app_ref.cg_state.picks
            temp_int_score = picks.abilities.get("int", 10)
            temp_int_mod = (temp_int_score - 10) // 2
            total_skill_points = skill_points_at_level1(picks.clazz, temp_int_mod, picks.race == "human")

            allocated_points = sum(picks.skills.values())
            if allocated_points > total_skill_points:
                self.query_one("#skill_message_label", Label).update(f"[CharGen] You have allocated {allocated_points - total_skill_points} too many skill points. Please adjust.")
                return
            
            # Proceed to next step (StepFeats)
            self.app_ref.push_screen(StepFeats(self.app_ref))
        elif ev.button.id == "back":
            self.app_ref.pop_screen()

    @on(events.Focus)
    def on_skill_input_focus(self, event: events.Focus) -> None:
        """Scroll the container to the focused input."""
        if isinstance(event.widget, Input) and "skill_input" in event.widget.classes:
            self.query_one(".skill_scroll_container", ScrollableContainer).scroll_to_widget(event.widget)
```

```
File: D:\Projects\Game Dev\D&D text RPG\src\dndrpg\ui\chargen\step_spells.py
from __future__ import annotations
from textual.widgets import Button, Input, Label, Static
from textual.containers import Vertical
from textual import on

from dndrpg.engine.spells import bonus_slots_from_mod, sorcerer_spells_known_from_cha

from .base import StepBase
from .step_kits import StepKits
from .step_wealth_shop import StepWealthShop

class StepSpells(StepBase):
    def compose(self):
        picks = self.app_ref.cg_state.picks
        clazz = picks.clazz
        
        if clazz == "cleric":
            yield Vertical(
                Label("Cleric Spells Preparation"),
                Label("Prepared Spells (Level 0):"),
                Input(placeholder="spell.light, spell.detect_magic", id="spells_0", classes="spell_input"),
                Label("Prepared Spells (Level 1):"),
                Input(placeholder="spell.cure_light_wounds, spell.bless", id="spells_1", classes="spell_input"),
                Static("", id="cleric_slots_display"),
                Button("Next", id="next"), Button("Back", id="back")
            )
        elif clazz == "sorcerer":
            yield Vertical(
                Label("Sorcerer Spells Known"),
                Label("Spells Known (comma-separated IDs):"),
                Input(placeholder="spell.magic_missile, spell.shield", id="spells_known_input"),
                Static("", id="sorcerer_slots_display"),
                Button("Next", id="next"), Button("Back", id="back")
            )
        else:
            yield Vertical(
                Label("No spells for this class."),
                Button("Next", id="next"), Button("Back", id="back")
            )

    def on_mount(self):
        self._update_spell_slots_display()

    @on(Input.Changed, ".spell_input")
    @on(Input.Changed, "#spells_known_input")
    def on_spell_input_changed(self, event: Input.Changed):
        self._update_spell_slots_display()

    def _update_spell_slots_display(self):
        picks = self.app_ref.cg_state.picks
        clazz = picks.clazz
        
        if clazz == "cleric":
            wis_mod = (picks.abilities.get("wis", 10) - 10) // 2
            expected_slots = bonus_slots_from_mod(wis_mod, max_level=picks.level)
            
            display_text = "Available Slots:\n"
            for level, count in expected_slots.items():
                display_text += f"Level {level}: {count} slots\n"
            
            self.query_one("#cleric_slots_display", Static).update(display_text)

        elif clazz == "sorcerer":
            cha_mod = (picks.abilities.get("cha", 10) - 10) // 2
            expected_known = sorcerer_spells_known_from_cha(picks.level, cha_mod)
            
            display_text = "Spells Known (Max):\n"
            for level, count in expected_known.items():
                display_text += f"Level {level}: {count} spells\n"
            
            self.query_one("#sorcerer_slots_display", Static).update(display_text)

    def on_button_pressed(self, ev):
        if ev.button.id == "back":
            self.app_ref.pop_screen()
        elif ev.button.id == "next":
            picks = self.app_ref.cg_state.picks
            clazz = picks.clazz

            if clazz == "cleric":
                prepared_spells = {}
                for level in range(2): # Levels 0 and 1 for now
                    input_id = f"#spells_{level}"
                    spells_str = self.query_one(input_id, Input).value or ""
                    spells_list = [s.strip() for s in spells_str.split(",") if s.strip()]
                    prepared_spells[level] = spells_list
                picks.spells_prepared = prepared_spells

                # Basic validation for cleric prepared spells
                wis_mod = (picks.abilities.get("wis", 10) - 10) // 2
                expected_slots = bonus_slots_from_mod(wis_mod, max_level=picks.level)
                for level, spells in prepared_spells.items():
                    if len(spells) > expected_slots.get(level, 0):
                        self.app_ref.log_panel.push(f"[CharGen] Too many Level {level} spells prepared for Cleric. Max: {expected_slots.get(level, 0)}")
                        return

            elif clazz == "sorcerer":
                spells_str = self.query_one("#spells_known_input", Input).value or ""
                spells_list = [s.strip() for s in spells_str.split(",") if s.strip()]
                picks.spells_known = spells_list

                # Basic validation for sorcerer spells known
                cha_mod = (picks.abilities.get("cha", 10) - 10) // 2
                expected_known = sorcerer_spells_known_from_cha(picks.level, cha_mod)
                total_expected_known = sum(expected_known.values())
                if len(spells_list) > total_expected_known:
                    self.app_ref.log_panel.push(f"[CharGen] Too many spells known for Sorcerer. Max: {total_expected_known}")
                    return

            # Route to wealth/shop step
            campaign = self.app_ref.engine.campaign
            if campaign.wealth.mode == "kits":
                self.app_ref.push_screen(StepKits(self.app_ref))
            else:
                self.app_ref.push_screen(StepWealthShop(self.app_ref))
```

```
File: D:\Projects\Game Dev\D&D text RPG\src\dndrpg\ui\chargen\step_summary.py
from __future__ import annotations
from textual.widgets import Button, Label, Static
from textual.containers import Vertical

from dndrpg.engine.chargen import build_entity_from_state, validate_character_picks

from .base import StepBase

class StepSummary(StepBase):
    def compose(self):
        picks = self.app_ref.cg_state.picks
        yield Vertical(
            Label("Summary (preview)"),
            Static(f"Name: {picks.name}  Race: {picks.race}  Class: {picks.clazz}  Align: {picks.alignment}"),
            Static(f"Abilities: {picks.abilities}"),
            Static(f"Skills: {picks.skills}"),
            Static(f"Feats: {sorted(picks.feats)}"),
            Static(f"Domains: {picks.domains}"),
            Static(f"Gear: {picks.gear_ids}"),
            Button("Confirm", id="confirm"), Button("Back", id="back")
        )
    def on_button_pressed(self, ev):
        if ev.button.id == "back":
            self.app_ref.pop_screen()
        if ev.button.id == "confirm":
            # Explicitly validate character picks before building the entity
            is_valid, validation_message = validate_character_picks(
                self.app_ref.engine.content, self.app_ref.cg_state.picks
            )
            if not is_valid:
                self.app_ref.log_panel.push(f"[CharGen Validation Error] {validation_message}")
                return

            build_entity_from_state(self.app_ref.engine.content, self.app_ref.engine.state, self.app_ref.cg_state.picks,
                                    self.app_ref.engine.effects, self.app_ref.engine.resources,
                                    self.app_ref.engine.conditions, self.app_ref.engine.hooks)
            self.app_ref.engine.state.mode = "exploration"
            self.app_ref.log.push("Character created. Entering exploration.")
            self.app_ref.pop_screen()
            self.app_ref.refresh_all()
```

```
File: D:\Projects\Game Dev\D&D text RPG\src\dndrpg\ui\chargen\step_wealth_shop.py
from __future__ import annotations
from textual.widgets import Button, Input, Label
from textual.containers import Vertical

from dndrpg.engine.wealth import roll_class_gold

from .base import StepBase
from .step_kits import StepKits
from .step_summary import StepSummary

class StepWealthShop(StepBase):
    def compose(self):
        picks = self.app_ref.cg_state.picks
        mode = self.app_ref.engine.campaign.wealth.mode
        if mode == "kits":
            self.app_ref.push_screen(StepKits(self.app_ref))
            return
        if mode == "roll":
            gp = roll_class_gold(picks.clazz, self.app_ref.engine.rng)
        else:
            gp = self.app_ref.engine.campaign.wealth.fixed_gp or 100
        self.gp = gp
        # For MVP, allow item ids comma-separated with "buy id:qty", no prices enforced (we can add prices later)
        yield Vertical(
            Label(f"Wealth: {gp} gp (enter item ids comma-separated)"),
            Input(placeholder="wp.mace.heavy, ar.chain_shirt, sh.heavy_wooden", id="buy"),
            Button("Next", id="next"), Button("Back", id="back")
        )
    def on_button_pressed(self, ev):
        if ev.button.id == "back":
            self.app_ref.pop_screen()
        if ev.button.id == "next":
            ids = [t.strip() for t in (self.query_one("#buy", Input).value or "").split(",") if t.strip()]
            self.app_ref.cg_state.picks.gear_ids = ids
            self.app_ref.push_screen(StepSummary(self.app_ref))
```

```
File: D:\Projects\Game Dev\D&D text RPG\src\dndrpg\ui\chargen\__init__.py
from .base import CharGenState, StepBase
from .step_name_alignment import StepNameAlignment
from .step_ability import StepAbility
from .step_race_class import StepRaceClass
from .step_deity_domains import StepDeityDomains
from .step_skills import StepSkills
from .step_feats import StepFeats
from .step_spells import StepSpells
from .step_wealth_shop import StepWealthShop
from .step_kits import StepKits
from .step_summary import StepSummary

__all__ = [
    "CharGenState",
    "StepBase",
    "StepNameAlignment",
    "StepAbility",
    "StepRaceClass",
    "StepDeityDomains",
    "StepSkills",
    "StepFeats",
    "StepSpells",
    "StepWealthShop",
    "StepKits",
    "StepSummary",
]
```

```
File: D:\Projects\Game Dev\D&D text RPG\src\dndrpg\ui\panels.py
from textual.widgets import Input, Static
from textual.reactive import reactive
from rich.table import Table
from ..engine.state import GameState
from ..engine.models import Item
from ..engine.engine import GameEngine

class StatsPanel(Static):
    engine: GameEngine | None = None

    def bind_engine(self, engine: GameEngine):
        self.engine = engine

    def update_state(self, state: GameState):
        if not state or not self.engine:
            self.update("No state")
            return
        p = state.player
        resolved = self.engine.modifiers.resolved_stats(p)

        table = Table(title="Stats (resolved)", pad_edge=False, show_header=False)
        table.add_row("HP", f"{p.hp_current}/{p.hp_max}")
        table.add_row("AC", f"{resolved['ac_total']} (T {resolved['ac_touch']} / FF {resolved['ac_ff']})")
        table.add_row("Initiative", f"+{p.initiative_bonus}")  # init modifiers can be added later
        table.add_row("Melee", f"+{resolved['attack_melee_bonus']}")
        table.add_row("Ranged", f"+{resolved['attack_ranged_bonus']}")
        table.add_row("Saves", f"F+{resolved['save_fort']} R+{resolved['save_ref']} W+{resolved['save_will']}")
        self.update(table)

class InventoryPanel(Static):
    def update_inventory(self, items: list[Item], resources: dict[str, int]):
        table = Table(title="Inventory / Resources", pad_edge=False, show_header=False)
        if items:
            table.add_row("Items", ", ".join(it.name for it in items))
        if resources:
            for k, v in resources.items():
                table.add_row(k, str(v))
        self.update(table)

class LogPanel(Static):
    log_lines: list[str] = reactive([])

    def push(self, line: str):
        self.log_lines.append(line)
        self.update("\n".join(self.log_lines[-200:]))

class CommandBar(Input):
    pass
```

```
File: D:\Projects\Game Dev\D&D text RPG\src\dndrpg\ui\__init__.py

```

```
File: D:\Projects\Game Dev\D&D text RPG\src\dndrpg\util\paths.py
from __future__ import annotations
from pathlib import Path
import sys

def frozen_base_dir() -> Path:
    # When packaged with PyInstaller --onefile, data is unpacked to sys._MEIPASS
    if hasattr(sys, "_MEIPASS"):
        return Path(sys._MEIPASS)  # type: ignore[attr-defined]
    # dev mode: src/dndrpg
    return Path(__file__).resolve().parent.parent # This should be src/dndrpg

def content_dir() -> Path:
    # In dev, this resolves to src/dndrpg/content
    # In onefile, use --add-data to embed content as "dndrpg/content"
    base = frozen_base_dir()
    return base / "content" # This should be content directly under src/dndrpg
```

```
File: D:\Projects\Game Dev\D&D text RPG\src\dndrpg\app.py
from textual.app import App, ComposeResult
from textual.widgets import Header, Footer, Input, Static
from textual.containers import Horizontal, Vertical
from textual.screen import Screen
from textual.widgets import Button, Label, Select
from textual import on
from .engine.save import list_saves, delete_save
from .engine.engine import GameEngine
from .ui.panels import StatsPanel, LogPanel, InventoryPanel, CommandBar
from .ui.chargen import CharGenState, StepNameAlignment # Import new chargen screens

class TitleScreen(Screen):
    BINDINGS = [("escape", "app.quit", "Quit")]
    def compose(self) -> ComposeResult:
        yield Vertical(
            Label("D&D 3.5e â€” Text RPG", id="title"),
            Button("New Game", id="new"),
            Button("Continue", id="cont"),
            Button("Load Game", id="load"),
            Button("Quit", id="quit"),
            classes="centered"
        )
    @on(Button.Pressed, "#new")
    def _new(self) -> None:
        self.app.push_screen(CampaignSelectScreen()) # Start with campaign selection
    @on(Button.Pressed, "#cont")
    def _cont(self) -> None:
        lines = self.app.engine.continue_latest()
        for ln in lines:
            self.app.log_panel.push(ln)
        self.app.pop_screen()  # return to game UI
        self.app.refresh_all("Continue loaded.")
    @on(Button.Pressed, "#load")
    def _load(self) -> None:
        self.app.push_screen(LoadScreen())
    @on(Button.Pressed, "#quit")
    def _quit(self) -> None:
        self.app.exit()

class CampaignSelectScreen(Screen):
    def compose(self) -> ComposeResult:
        opts = [(c.name, cid) for cid, c in self.app.engine.content.campaigns.items()]
        yield Vertical(Label("Select Campaign"), Select(options=opts, id="camp"), Button("Next", id="next"), Button("Back", id="back"))
    @on(Button.Pressed, "#back")
    def _back(self) -> None:
        self.app.pop_screen()
    @on(Button.Pressed, "#next")
    def _next(self) -> None:
        sel = self.query_one("#camp", Select).value
        if not sel:
            return
        self.app.engine.campaign = self.app.engine.content.campaigns[sel] # Set the campaign in the engine
        self.app.push_screen(StepNameAlignment(self.app)) # Start chargen after campaign selection

class LoadScreen(Screen):
    def compose(self) -> ComposeResult:
        from rich.table import Table
        table = Table(title="Saves", show_header=True, header_style="bold")
        table.add_column("Slot")
        table.add_column("Campaign")
        table.add_column("When")
        table.add_column("Desc")
        self.saves = list_saves()
        for m in self.saves:
            from datetime import datetime
            when = datetime.fromtimestamp(m.last_played_ts).strftime("%Y-%m-%d %H:%M")
            table.add_row(m.slot_id, m.campaign_id, when, m.description)
        yield Vertical(Label("Select a slot id and type it below:"), Static(table), Input(placeholder="slot id", id="slot"), Button("Load", id="load"), Button("Delete", id="del"), Button("Back", id="back"))
    @on(Button.Pressed, "#back")
    def _back(self) -> None: self.app.pop_screen()
    @on(Button.Pressed, "#load")
    def _load(self) -> None:
        slot = self.query_one("#slot", Input).value.strip()
        if not slot:
            return
        lines = self.app.engine.load_slot(slot)
        for ln in lines:
            self.app.log_panel.push(ln)
        # Check if the load was successful before popping screens
        if not any("Error:" in line for line in lines):
            # Pop LoadScreen and TitleScreen to reveal the main game UI
            self.app.pop_screen() # Pop LoadScreen
            self.app.pop_screen() # Pop TitleScreen
            self.app.refresh_all("Save loaded.")
        else:
            # If there was an error, stay on the LoadScreen and show the error
            pass
    @on(Button.Pressed, "#del")
    def _del(self) -> None:
        slot = self.query_one("#slot", Input).value.strip()
        if not slot:
            return
        delete_save(slot)
        self.app.log_panel.push(f"Deleted save: {slot}")
        self.app.pop_screen()
        self.app.push_screen(LoadScreen())

class DnDApp(App):
    CSS = """
    Screen { layout: vertical; }
    .main { layout: horizontal; height: 1fr; }
    .col { width: 1fr; border: solid gray; }
    .left  { width: 30%; }
    .center{ width: 40%; }
    .right { width: 30%; }
    .log { overflow: auto; }
    .centered { align: center middle; }
    #title { text-align: center; margin-bottom: 2; }
    Button { width: 30%; margin: 1; }
    Input { width: 30%; margin: 1; }
    Select { width: 30%; margin: 1; }
    .error { color: red; }
    .skill_scroll_container {
        height: 20; /* Take up available vertical space */
        overflow-y: scroll; /* Enable vertical scrolling */
        border: solid green; /* For debugging, remove later */
    }
    """

    BINDINGS = [("ctrl+c", "quit", "Quit")]

    def __init__(self):
        super().__init__()
        self.engine = GameEngine()
        self.state = self.engine.state
        self.cg_state = CharGenState() # Initialize CharGenState

    def compose(self) -> ComposeResult:
        yield Header()
        with Horizontal(classes="main"):
            self.stats_panel = StatsPanel(classes="col left")
            self.log_panel = LogPanel(classes="col center log")
            self.inv_panel = InventoryPanel(classes="col right")
            yield self.stats_panel
            yield self.log_panel
            yield self.inv_panel
        self.cmd_bar = CommandBar(placeholder="Type commands (help, status, attack goblin, cast divine power, travel east 10m, rest 8h) and press Enter")
        yield self.cmd_bar
        yield Footer()

    def on_mount(self) -> None:
        # Start at title screen
        self.push_screen(TitleScreen())
        self.stats_panel.bind_engine(self.engine)
        self.refresh_all("Welcome! Use the title screen to start or load a game.")

    def refresh_all(self, msg: str | None = None):
        if msg:
            self.log_panel.push(msg)
        self.stats_panel.update_state(self.engine.state)
        p = self.engine.state.player
        self.inv_panel.update_inventory(p.inventory, self.engine.state.resources_summary())

    async def on_input_submitted(self, event: Input.Submitted):
        text = event.value.strip()
        self.cmd_bar.value = ""
        if not text:
            return
        out_lines = self.engine.execute(text)
        for line in out_lines:
            self.log_panel.push(line)
        self.refresh_all()
        if self.engine.should_quit:
            self.exit()

def run_app():
    try:
        app = DnDApp()
        app.run()
    except Exception as e:
        print(f"Error running app: {e}")
```

```
File: D:\Projects\Game Dev\D&D text RPG\src\dndrpg\cli.py
import typer
from dndrpg.engine.engine import GameEngine
from dndrpg.engine.chargen import CharBuildState, build_entity_from_state
from dndrpg.engine.save import delete_save

app = typer.Typer()

@app.command()
def new(campaign_id: str = "camp.srd_sandbox", name: str = "Hero", clazz: str = "fighter", race: str = "human"):
    eng = GameEngine()
    picks = CharBuildState(name=name, clazz=clazz, race=race)
    # minimal set
    build_entity_from_state(eng.content, eng.state, picks, eng.effects, eng.resources, eng.conditions, eng.hooks)
    for line in eng.start_new_game(campaign_id, eng.state.player, slot_id="slot1"):
        typer.echo(line)

@app.command()
def continue_latest():
    eng = GameEngine()
    for line in eng.continue_latest():
        typer.echo(line)

@app.command()
def load(slot_id: str):
    eng = GameEngine()
    for line in eng.load_slot(slot_id):
        typer.echo(line)

@app.command()
def delete(slot_id: str):
    delete_save(slot_id)
    typer.echo(f"Deleted save: {slot_id}")

@app.command()
def create_character():
    typer.echo("Starting character creation wizard (CLI)...")
    name = typer.prompt("Enter character name", default="Hero")
    alignment = typer.prompt("Enter alignment (e.g., lawful good)", default="neutral")
    race = typer.prompt("Enter race (e.g., human)", default="human")
    clazz = typer.prompt("Enter class (e.g., fighter)", default="fighter")

    # Simplified ability score generation for CLI
    typer.echo("Enter ability scores (STR, DEX, CON, INT, WIS, CHA) separated by spaces:")
    scores_input = typer.prompt("e.g., 15 14 13 12 10 8", default="15 14 13 12 10 8")
    scores_list = [int(s.strip()) for s in scores_input.split()]
    abilities_dict = {"str": scores_list[0], "dex": scores_list[1], "con": scores_list[2],
                      "int": scores_list[3], "wis": scores_list[4], "cha": scores_list[5]}

    picks = CharBuildState(name=name, alignment=alignment, race=race, clazz=clazz, abilities=abilities_dict)

    eng = GameEngine()
    build_entity_from_state(eng.content, eng.state, picks, eng.effects, eng.resources, eng.conditions, eng.hooks)
    
    typer.echo("Character created successfully!")
    typer.echo(f"Name: {eng.state.player.name}")
    typer.echo(f"Class: {eng.state.player.classes}")
    typer.echo(f"Abilities: {eng.state.player.abilities}")


if __name__ == "__main__":
    app()
```

```
File: D:\Projects\Game Dev\D&D text RPG\src\dndrpg\main.py
from dndrpg.app import DnDApp

def main():
    """
    The main function of the application.
    """
    app = DnDApp()
    app.run()

if __name__ == "__main__":
    main()
```

```
File: D:\Projects\Game Dev\D&D text RPG\src\dndrpg\__init__.py

```

```
File: D:\Projects\Game Dev\D&D text RPG\src\dndrpg\__main__.py
from dndrpg.main import main

if __name__ == "__main__":
    main()
```

```
File: D:\Projects\Game Dev\D&D text RPG\tests\test_resources.py
import pytest
from pydantic import ValidationError
from dndrpg.engine.schema_models import ResourceDefinition, CapacitySpec, ResourceRefresh, AbsorptionSpec
from dndrpg.engine.resources_runtime import ResourceEngine
from dndrpg.engine.models import Entity
from dndrpg.engine.loader import ContentIndex
from dndrpg.engine.state import GameState

# Mock ContentIndex and GameState for testing
@pytest.fixture
def mock_content_index():
    return ContentIndex(
        effects={},
        
        resources={
            "test_resource_level_capacity": ResourceDefinition(
                id="test_resource_level_capacity",
                name="Level Capacity Resource",
                scope="entity",
                capacity=CapacitySpec(formula="level * 5")
            ),
            "test_resource_fixed_capacity": ResourceDefinition(
                id="test_resource_fixed_capacity",
                name="Fixed Capacity Resource",
                scope="entity",
                capacity=CapacitySpec(formula="10")
            ),
            "test_resource_capped_capacity": ResourceDefinition(
                id="test_resource_capped_capacity",
                name="Capped Capacity Resource",
                scope="entity",
                capacity=CapacitySpec(formula="level * 10", cap=20)
            ),
            "test_resource_refresh_reset": ResourceDefinition(
                id="test_resource_refresh_reset",
                name="Refresh Reset Resource",
                scope="entity",
                capacity=CapacitySpec(formula="10"),
                initial_current=5,
                refresh=ResourceRefresh(cadence="per_round", behavior="reset_to_max")
            ),
            "test_resource_refresh_increment": ResourceDefinition(
                id="test_resource_refresh_increment",
                name="Refresh Increment Resource",
                scope="entity",
                capacity=CapacitySpec(formula="10"),
                initial_current=5,
                refresh=ResourceRefresh(cadence="per_round", behavior="increment_by", increment_by="1")
            ),
            "test_resource_refresh_increment_formula": ResourceDefinition(
                id="test_resource_refresh_increment_formula",
                name="Refresh Increment Formula Resource",
                scope="entity",
                capacity=CapacitySpec(formula="level * 2"),
                refresh=ResourceRefresh(cadence="per_round", behavior="increment_by", increment_by="level / 2")
            ),
        },
        items_by_id={},
        weapons={},
        armors={},
        shields={},
        kits={},
        
        
        campaigns={}
    )

@pytest.fixture
def mock_game_state(mock_content_index):
    player_entity = Entity(id="player1", name="Test Player", level=5)
    gs = GameState(
        player=player_entity,
        entities={"player1": player_entity},
        current_round=0,
        resources={}
    )
    return gs

@pytest.fixture
def resource_engine(mock_content_index, mock_game_state):
    return ResourceEngine(mock_content_index, mock_game_state)

# --- ResourceDefinition Schema Tests ---

def test_resource_definition_valid():
    rd = ResourceDefinition(
        id="hp",
        name="Hit Points",
        scope="entity",
        capacity=CapacitySpec(formula="level * 10 + con_mod"),
        initial_current="capacity",
        refresh=ResourceRefresh(cadence="per_day", behavior="reset_to_max"),
        absorption=AbsorptionSpec(absorbTypes=["physical"])
    )
    assert rd.id == "hp"
    assert rd.capacity.formula == "level * 10 + con_mod"
    assert rd.refresh.cadence == "per_day"

def test_resource_definition_invalid_capacity_cap():
    with pytest.raises(ValidationError, match="capacity.cap must be >= 0"):
        ResourceDefinition(
            id="invalid_cap",
            name="Invalid Cap",
            scope="entity",
            capacity=CapacitySpec(formula="10", cap=-5)
        )

def test_resource_definition_invalid_refresh_increment_by_missing():
    with pytest.raises(ValidationError, match="refresh.behavior 'increment_by' requires increment_by"):
        ResourceDefinition(
            id="invalid_refresh",
            name="Invalid Refresh",
            scope="entity",
            capacity=CapacitySpec(formula="10"),
            refresh=ResourceRefresh(cadence="per_round", behavior="increment_by")
        )

def test_resource_definition_invalid_absorption_types_empty():
    with pytest.raises(ValidationError, match="absorption.absorbTypes must be a non-empty list"):
        ResourceDefinition(
            id="invalid_absorb",
            name="Invalid Absorb",
            scope="entity",
            capacity=CapacitySpec(formula="10"),
            absorption=AbsorptionSpec(absorbTypes=[])
        )

# --- ResourceEngine Functionality Tests ---

def test_resource_engine_create_from_definition_level_capacity(resource_engine, mock_game_state):
    rs, logs = resource_engine.create_from_definition(
        "test_resource_level_capacity",
        owner_scope="entity",
        owner_entity_id="player1"
    )
    assert rs is not None
    assert rs.definition_id == "test_resource_level_capacity"
    assert rs.owner_entity_id == "player1"
    # Player level is 5, formula is level * 5 = 25
    assert rs.max_computed == 25
    assert rs.current == 25 # initial_current defaults to max_computed

def test_resource_engine_create_from_definition_fixed_capacity(resource_engine, mock_game_state):
    rs, logs = resource_engine.create_from_definition(
        "test_resource_fixed_capacity",
        owner_scope="entity",
        owner_entity_id="player1"
    )
    assert rs is not None
    assert rs.max_computed == 10
    assert rs.current == 10

def test_resource_engine_create_from_definition_capped_capacity(resource_engine, mock_game_state):
    rs, logs = resource_engine.create_from_definition(
        "test_resource_capped_capacity",
        owner_scope="entity",
        owner_entity_id="player1"
    )
    assert rs is not None
    # Player level is 5, formula is level * 10 = 50, cap is 20
    assert rs.max_computed == 20
    assert rs.current == 20

def test_resource_engine_refresh_cadence_reset_to_max(resource_engine, mock_game_state):
    rs, logs = resource_engine.create_from_definition(
        "test_resource_refresh_reset",
        owner_scope="entity",
        owner_entity_id="player1"
    )
    assert rs.current == 5 # initial_current set to 5 in definition
    rs.current = 2 # Simulate resource being spent
    assert rs.current == 2

    resource_engine.refresh_cadence("per_round")
    assert rs.current == rs.max_computed # Should reset to max (10)

def test_resource_engine_refresh_cadence_increment_by(resource_engine, mock_game_state):
    rs, logs = resource_engine.create_from_definition(
        "test_resource_refresh_increment",
        owner_scope="entity",
        owner_entity_id="player1"
    )
    assert rs.current == 5 # initial_current set to 5 in definition
    rs.current = 2 # Simulate resource being spent
    assert rs.current == 2

    resource_engine.refresh_cadence("per_round")
    # Should increment by 1 (from definition)
    assert rs.current == 3 # 2 + 1

    resource_engine.refresh_cadence("per_round")
    assert rs.current == 4 # 3 + 1

def test_resource_engine_refresh_cadence_increment_by_formula(resource_engine, mock_game_state):
    rs, logs = resource_engine.create_from_definition(
        "test_resource_refresh_increment_formula",
        owner_scope="entity",
        owner_entity_id="player1"
    )
    # Player level is 5, capacity formula is level * 2 = 10
    assert rs.max_computed == 10
    assert rs.current == 10 # initial_current defaults to max_computed

    rs.current = 5 # Simulate resource being spent
    assert rs.current == 5

    # Increment by level / 2 = 5 / 2 = 2.5, int(2.5) = 2
    resource_engine.refresh_cadence("per_round")
    assert rs.current == 7 # 5 + 2

    resource_engine.refresh_cadence("per_round")
    assert rs.current == 9 # 7 + 2

    resource_engine.refresh_cadence("per_round")
    assert rs.current == 10 # 9 + 2, capped at max_computed

def test_resource_engine_refresh_cadence_other_cadence_not_triggered(resource_engine, mock_game_state):
    rs, logs = resource_engine.create_from_definition(
        "test_resource_refresh_reset",
        owner_scope="entity",
        owner_entity_id="player1"
    )
    rs.current = 2
    resource_engine.refresh_cadence("per_day") # Should not trigger per_round refresh
    assert rs.current == 2
```

```
File: D:\Projects\Game Dev\D&D text RPG\tests\test_schema_models.py
import pytest
from pydantic import ValidationError
from dndrpg.engine.schema_models import Modifier

def test_modifier_prefix_allowlist():
    with pytest.raises(ValidationError):
        Modifier(targetPath="combat.bab.effective", operator="add", value=1, bonusType="enhancement")

def test_modifier_bonusType_required_on_ac_add():
    with pytest.raises(ValidationError):
        Modifier(targetPath="ac.deflection", operator="add", value=1)

def test_modifier_speed_multiply_ok():
    Modifier(targetPath="speed.land", operator="multiply", value=1.5)

def test_modifier_tags_only_grant_remove():
    with pytest.raises(ValidationError):
        Modifier(targetPath="tags.haste", operator="add", value=1)
    Modifier(targetPath="tags.haste", operator="grantTag")
    Modifier(targetPath="tags.haste", operator="removeTag")

def test_modifier_replaceFormula_deprecated():
    with pytest.raises(ValidationError):
        Modifier(targetPath="ac.deflection", operator="replaceFormula", value="level()")

def test_valid_modifiers():
    # Valid AC modifier
    Modifier(targetPath="ac.deflection", operator="add", value=2, bonusType="deflection")
    # Valid ability modifier
    Modifier(targetPath="abilities.str.enhancement", operator="add", value=4, bonusType="enhancement")
    # Valid save modifier
    Modifier(targetPath="save.fort.resistance", operator="add", value=2, bonusType="resistance")
    # Valid attack modifier
    Modifier(targetPath="attack.melee.enhancement", operator="add", value=1, bonusType="enhancement")
    # Valid BAB modifier
    Modifier(targetPath="bab.base", operator="add", value=1, bonusType="unnamed")
    # Valid speed modifier
    Modifier(targetPath="speed.land", operator="add", value=10, bonusType="enhancement")
    # Valid resistance
    Modifier(targetPath="resist.fire", operator="add", value=10, bonusType="resistance")
    # Valid DR
    Modifier(targetPath="dr.adamantine", operator="add", value=5, bonusType="unnamed")
    # Valid senses
    Modifier(targetPath="senses.darkvision", operator="set", value=60)
    # Valid resource
    Modifier(targetPath="resources.rage", operator="add", value=1, bonusType="unnamed")

def test_invalid_operator_target_combos():
    # multiply on ac
    with pytest.raises(ValidationError):
        Modifier(targetPath="ac.armor", operator="multiply", value=2, bonusType="unnamed")
    # divide on saves
    with pytest.raises(ValidationError):
        Modifier(targetPath="save.will", operator="divide", value=2, bonusType="unnamed")
    # multiply on resist
    with pytest.raises(ValidationError):
        Modifier(targetPath="resist.cold", operator="multiply", value=2, bonusType="unnamed")
    # add on tags
    with pytest.raises(ValidationError):
        Modifier(targetPath="tags.confused", operator="add", value=1, bonusType="unnamed")
    # invalid operator for speed
    with pytest.raises(ValidationError):
        Modifier(targetPath="speed.fly", operator="grantTag", value=1, bonusType="unnamed")

def test_bonustype_not_required_for_non_add_sub():
    Modifier(targetPath="ac.deflection", operator="max", value=15)
    Modifier(targetPath="abilities.dex", operator="set", value=18)

def test_replaceformula_is_deprecated():
    with pytest.raises(ValidationError, match="deprecated"):
        Modifier(targetPath="ac.armor", operator="replaceFormula", value="10")

def test_converttype_is_invalid():
    with pytest.raises(ValidationError, match="not valid as a generic Modifier"):
        Modifier(targetPath="damage.base", operator="convertType", value="fire")
```

```
File: D:\Projects\Game Dev\D&D text RPG\tests\test_smoke.py
from pathlib import Path
from dndrpg.engine.loader import load_content
from dndrpg.engine.state import default_state, GameState
from dndrpg.engine.damage_runtime import DamageEngine, DamagePacket
from dndrpg.engine.models import DREntry
from dndrpg.engine.resources_runtime import ResourceState
from dndrpg.engine.schema_models import AbsorptionSpec

def test_smoke_default_player_stats():
    content_dir = Path(__file__).resolve().parents[1] / "src" / "dndrpg" / "content"
    content = load_content(content_dir)
    state: GameState = default_state(content)
    p = state.player

    assert p.hp_max >= 1 and p.hp_current == p.hp_max
    assert isinstance(p.ac_total, int) and p.ac_total > 0
    assert isinstance(p.ac_touch, int) and p.ac_touch > 0
    assert isinstance(p.ac_ff, int) and p.ac_ff > 0
    assert p.save_fort == int(p.save_fort)
    assert p.save_ref == int(p.save_ref)
    assert p.save_will == int(p.save_will)

def test_damage_pipeline():
    content_dir = Path(__file__).resolve().parents[1] / "src" / "dndrpg" / "content"
    content = load_content(content_dir)
    state: GameState = default_state(content)
    p = state.player

    # Setup defenses
    p.dr = [DREntry(value=5, bypass_magic=True)]
    p.energy_resist = {"fire": 10}
    p.vulnerabilities = {"cold": 1.5}
    p.hp_current = 50
    p.hp_max = 50

    damage_engine = DamageEngine(content, state)

    # Test 1: Physical damage, not magic -> DR applies
    p.hp_current = 50
    packets = [DamagePacket(amount=12, dkind="physical.bludgeoning", counts_as_magic=False)]
    result = damage_engine.apply_packets(p.id, packets)
    assert p.hp_current == 50 - (12 - 5)
    assert result.physical_damage_applied == 7
    assert any("[Dmg] DR 5/- reduces total physical 12 by 5 (per attack)" in log for log in result.logs)

    # Test 2: Fire damage -> resistance applies
    p.hp_current = 50
    packets = [DamagePacket(amount=15, dkind="fire")]
    result = damage_engine.apply_packets(p.id, packets)
    assert p.hp_current == 50 - (15 - 10)
    assert any("[Dmg] Resist fire 10 â†’ 15->5" in log for log in result.logs)

    # Test 3: Cold damage -> vulnerability applies
    p.hp_current = 50
    packets = [DamagePacket(amount=10, dkind="cold")]
    result = damage_engine.apply_packets(p.id, packets)
    assert p.hp_current == 50 - int(10 * 1.5)
    assert any("[Dmg] Vulnerability cold x1.5 â†’ 10->15" in log for log in result.logs)

    # Test 4: Physical damage, but magic -> DR is bypassed
    p.hp_current = 50
    packets = [DamagePacket(amount=12, dkind="physical.slashing", counts_as_magic=True)]
    result = damage_engine.apply_packets(p.id, packets)
    assert p.hp_current == 50 - 12
    assert result.physical_damage_applied == 12
    assert not any("DR" in log for log in result.logs)

    # Test 5: Mixed damage
    p.hp_current = 50
    packets = [
        DamagePacket(amount=10, dkind="physical.piercing"),
        DamagePacket(amount=8, dkind="fire"),
        DamagePacket(amount=6, dkind="cold"),
    ]
    result = damage_engine.apply_packets(p.id, packets)
    # physical: 10 - 5(DR) = 5
    # fire: 8 - 10(resist) = 0
    # cold: 6 * 1.5(vuln) = 9
    # total = 5 + 0 + 9 = 14
    assert p.hp_current == 50 - 14

def test_damage_pipeline_with_temp_hp():
    content_dir = Path(__file__).resolve().parents[1] / "src" / "dndrpg" / "content"
    content = load_content(content_dir)
    state: GameState = default_state(content)
    p = state.player

    # Temp HP as a resource
    temp_hp_res = ResourceState(definition_id="res:temp_hp", name="Temporary HP", current=20, capacity=20, owner_entity_id=p.id)
    temp_hp_res.absorption = AbsorptionSpec(absorbTypes=["any"])
    state.resources[f"entity:{p.id}"] = [temp_hp_res]

    p.hp_current = 50
    p.hp_max = 50

    damage_engine = DamageEngine(content, state)

    packets = [DamagePacket(amount=30, dkind="physical.bludgeoning")]
    result = damage_engine.apply_packets(p.id, packets)

    # 20 damage absorbed by temp hp, 10 to player hp
    assert temp_hp_res.current == 0
    assert p.hp_current == 50 - 10
    assert any("[Dmg] Temporary HP absorbed 20 (0 left)" in log for log in result.logs)
```
